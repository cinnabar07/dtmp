{"version":3,"file":"array.spec.js","names":["description","makeTestGroup","keysOf","ShaderValidationTest","g","kValidCases","i32","u32","f32","f16","bool","vec2u","vec3i","vec4f","array","struct","mat2x2f","mat4x4h","atomicu","atomici","literal_count","literali_count","literalu_count","const_count","const_expr_count1","const_expr_count2","const_expr_func","override_count","override_expr1","override_expr2","override_zero","override_neg","same_const_value1","same_const_value2","same_const_value3","same_override","same_rta","shadow","trailing_comma1","trailing_comma2","alias_element","test","desc","params","u","combine","beforeAllSubcases","t","code","case","indexOf","selectDeviceOrSkipTestCase","fn","skipIf","hasLanguageFeature","expectCompileResult","kInvalidCases","f16_without_enable","texture","sampler","runtime_nested","override_nested","override_nested_struct","zero_size","negative_size","const_zero","const_neg","float_size","incompatible_overrides","incompatible_size","incompatible_element","incompatible_rta","incompatible_override_element","override_function","override_private","override_uniform","override_storage","missing_r_template","missing_l_template","missing_type","bad_type","missing_l_template_rta","missing_r_template_rta","bad_size","inline_struct"],"sources":["../../../../../src/webgpu/shader/validation/types/array.spec.ts"],"sourcesContent":["/**\n* AUTO-GENERATED - DO NOT EDIT. Source: https://github.com/gpuweb/cts\n**/export const description = `\nValidation tests for array types\n`;import { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { keysOf } from '../../../../common/util/data_tables.js';\nimport { ShaderValidationTest } from '../shader_validation_test.js';\n\nexport const g = makeTestGroup(ShaderValidationTest);\n\nconst kValidCases = {\n  // Basic element types.\n  i32: `alias T = array<i32>;`,\n  u32: `alias T = array<u32>;`,\n  f32: `alias T = array<f32>;`,\n  f16: `enable f16;\\nalias T = array<f16>;`,\n  bool: `alias T = array<bool>;`,\n\n  // Composite elements\n  vec2u: `alias T = array<vec2u>;`,\n  vec3i: `alias T = array<vec3i>;`,\n  vec4f: `alias T = array<vec4f>;`,\n  array: `alias T = array<array<u32, 4>>;`,\n  struct: `struct S { x : u32 }\\nalias T = array<S>;`,\n  mat2x2f: `alias T = array<mat2x2f>;`,\n  mat4x4h: `enable f16;\\nalias T = array<mat4x4h>;`,\n\n  // Atomic elements\n  atomicu: `alias T = array<atomic<u32>>;`,\n  atomici: `alias T = array<atomic<i32>>;`,\n\n  // Count expressions\n  literal_count: `alias T = array<u32, 4>;`,\n  literali_count: `alias T = array<u32, 4i>;`,\n  literalu_count: `alias T = array<u32, 4u>;`,\n  const_count: `const x = 8;\\nalias T = array<u32, x>;`,\n  const_expr_count1: `alias T = array<u32, 1 + 3>;`,\n  const_expr_count2: `const x = 4;\\nalias T = array<u32, x * 2>;`,\n  const_expr_func: `alias T = array<u32, max(1,2)>;`,\n  override_count: `override x : u32;\\nalias T = array<u32, x>;`,\n  override_expr1: `override x = 2;\\nalias T = array<u32, vec2(x,x).x>;`,\n  override_expr2: `override x = 1;\\nalias T = array<u32, x + 1>;`,\n  override_zero: `override x = 0;\\nalias T = array<u32, x>;`,\n  override_neg: `override x = -1;\\nalias T = array<u32, x>;`,\n\n  // Same array types\n  same_const_value1: `\n    const x = 8;\n    const y = 8;\n    var<private> v : array<u32, x> = array<u32, y>();`,\n  same_const_value2: `\n    const x = 8;\n    var<private> v : array<u32, x> = array<u32, 8>();`,\n  same_const_value3: `\n    var<private> v : array<u32, 8i> = array<u32, 8u>();`,\n  same_override: `\n    requires unrestricted_pointer_parameters;\n    override x : u32;\n    var<workgroup> v : array<u32, x>;\n    fn bar(p : ptr<workgroup, array<u32, x>>) { }\n    fn foo() { bar(&v); }`,\n  same_rta: `\n    requires unrestricted_pointer_parameters;\n    @group(0) @binding(0) var<storage> x : array<u32>;\n    fn foo(p : ptr<storage, array<u32>>) { }\n    fn bar() { foo(&x); }`,\n\n  // Shadow\n  shadow: `alias array = vec2f;`,\n\n  trailing_comma1: `alias T = array<u32,4,>;`,\n  trailing_comma2: `alias T = array<u32,>;`,\n\n  alias_element: `alias T = u32; alias U = array<T>;`\n};\n\ng.test('valid').\ndesc('Valid array type tests').\nparams((u) => u.combine('case', keysOf(kValidCases))).\nbeforeAllSubcases((t) => {\n  const code = kValidCases[t.params.case];\n  if (code.indexOf('f16') >= 0) {\n    t.selectDeviceOrSkipTestCase('shader-f16');\n  }\n}).\nfn((t) => {\n  const code = kValidCases[t.params.case];\n  t.skipIf(\n    code.indexOf('unrestricted') >= 0 && !t.hasLanguageFeature('unrestricted_pointer_parameters'),\n    'Test requires unrestricted_pointer_parameters'\n  );\n  t.expectCompileResult(true, code);\n});\n\nconst kInvalidCases = {\n  f16_without_enable: `alias T = array<f16>;`,\n  texture: `alias T = array<texture_2d<f32>, 4>;`,\n  sampler: `alias T = array<sampler>;`,\n  runtime_nested: `alias T = array<array<u32>, 4>;`,\n  override_nested: `\n    override x : u32;\n    alias T = array<array<u32, x>, 4>;`,\n  override_nested_struct: `\n    override x : u32;\n    struct T { x : array<u32, x> }`,\n  zero_size: `alias T = array<u32, 0>;`,\n  negative_size: `alias T = array<u32, 1 - 2>;`,\n  const_zero: `const x = 0;\\nalias T = array<u32, x>;`,\n  const_neg: `const x = 1;\\nconst y = 2;\\nalias T = array<u32, x - y>;`,\n  float_size: `alias T = array<u32, max(1f, 2f)>;`,\n  incompatible_overrides: `\n    requires unrestricted_pointer_parameters;\n    override x = 8;\n    override y = 8;\n    var<workgroup> v : array<u32, x>\n    fn bar(p : ptr<workgroup, array<u32 y>>) { }\n    fn foo() { bar(&v); }`,\n  incompatible_size: `\n    var<private> x : array<u32, 4>;\n    fn foo(a : array<u32, 2>) { }\n    fn bar() { foo(x); }`,\n  incompatible_element: `\n    const x : array<i32, 4> = array(1,2,3,4);\n    var<private> y : array<u32, 4>  = x;`,\n  incompatible_rta: `\n    requires unrestricted_pointer_parameters;\n    @group(0) @binding(0) var<storage> x : array<u32>;\n    fn foo(p : ptr<storage, array<i32>>) { }\n    fn bar() { foo(&x); }`,\n  incompatible_override_element: `\n    requires unrestricted_pointer_parameters;\n    override x : i32;\n    var<workgroup> v : array<u32, v>;\n    fn bar(p : ptr<workgroup, array<i32 c>>) { }\n    fn foo() { bar(&v); }`,\n  override_function: `\n    override x : i32;\n    fn foo() { var v : array<u32, x>; }`,\n  override_private: `\n    override x : u32;\n    var<private> v : array<u32, x>;`,\n  override_uniform: `\n    override x : u32;\n    @group(0) @binding(0) var<uniform> v : array<u32, x>;`,\n  override_storage: `\n    override x : u32;\n    @group(0) @binding(0) var<storage> v : array<u32, x>;`,\n\n  // Parsing failures\n  missing_r_template: `alias T = array<u32, 4;`,\n  missing_l_template: `alias T = arrayu32,4>;`,\n  missing_type: `alias T = array<4>;`,\n  bad_type: `alias T = array<bad_type, 4>;`,\n  missing_l_template_rta: `alias T = arrayu32>;`,\n  missing_r_template_rta: `alias T = array<u32;`,\n  bad_size: `alias T = array<u32,u32>;`,\n  inline_struct: `alias T = array<struct S { x : u32 }, 4>;`\n};\n\ng.test('invalid').\ndesc('Invalid array type tests').\nparams((u) => u.combine('case', keysOf(kInvalidCases))).\nbeforeAllSubcases((t) => {\n  const code = kInvalidCases[t.params.case];\n  if (code.indexOf('f16') >= 0) {\n    t.selectDeviceOrSkipTestCase('shader-f16');\n  }\n}).\nfn((t) => {\n  const code = kInvalidCases[t.params.case];\n  t.skipIf(\n    code.indexOf('unrestricted') >= 0 && !t.hasLanguageFeature('unrestricted_pointer_parameters'),\n    'Test requires unrestricted_pointer_parameters'\n  );\n  t.expectCompileResult(false, code);\n});"],"mappings":"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","ignoreList":[]}