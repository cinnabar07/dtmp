{"version":3,"file":"pointer.spec.js","names":["description","makeTestGroup","keysOf","kAccessModeInfo","kAddressSpaceInfo","pointerType","explicitSpaceExpander","accessModeExpander","getVarDeclShader","supportsWrite","ShaderValidationTest","g","test","desc","params","u","combine","fn","t","code","aspace","comma","expectCompileResult","success","access","kTypeCases","bool","type","storable","u32","i32","f32","f16","vec2u","vec3i","vec4f","vec2_bool","vec3h","mat2x2f","mat3x4h","atomic_u32","atomic_i32","array_sized_u32","array_sized_vec4f","array_sized_S","array_runtime_u32","array_runtime_S","array_runtime_atomic_u32","array_override_u32","struct_S","struct_T","ptr_function_u32","ptr_workgroup_bool","sampler","texture_2d","alias","reference","beforeAllSubcases","case","selectDeviceOrSkipTestCase","testcase","includes","kNonHandleAddressSpaces","filter","as","specURL","expand","prog","ok","ptrStoreType","typePart","inferPtrType","storeType","i","spellAccessMode","addressSpace","accessMode","kStoreTypeNotInstantiable","ptr","privateAtomic","functionAtomic","uniformAtomic","workgroupRTArray","uniformRTArray","privateRTArray","functionRTArray","RTArrayNotLast","nestedRTArray"],"sources":["../../../../../src/webgpu/shader/validation/types/pointer.spec.ts"],"sourcesContent":["/**\n* AUTO-GENERATED - DO NOT EDIT. Source: https://github.com/gpuweb/cts\n**/export const description = 'Test pointer type validation';import { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { keysOf } from '../../../../common/util/data_tables.js';\nimport { kAccessModeInfo, kAddressSpaceInfo } from '../../types.js';\nimport {\n  pointerType,\n  explicitSpaceExpander,\n  accessModeExpander,\n  getVarDeclShader,\n  supportsWrite } from\n\n'../decl/util.js';\nimport { ShaderValidationTest } from '../shader_validation_test.js';\n\nexport const g = makeTestGroup(ShaderValidationTest);\n\ng.test('missing_type').\ndesc('Test that pointer types require an element type').\nparams((u) =>\nu.\ncombine('aspace', ['function', 'private', 'workgroup', 'storage', 'uniform']).\ncombine('comma', ['', ','])\n).\nfn((t) => {\n  const code = `alias T = ptr<${t.params.aspace}${t.params.comma}>;`;\n  t.expectCompileResult(false, code);\n});\n\ng.test('address_space').\ndesc('Test address spaces in pointer type parameterization').\nparams((u) =>\nu.\ncombine('aspace', [\n'function',\n'private',\n'workgroup',\n'storage',\n'uniform',\n'handle',\n'bad_aspace']\n).\ncombine('comma', ['', ','])\n).\nfn((t) => {\n  const code = `alias T = ptr<${t.params.aspace}, u32${t.params.comma}>;`;\n  const success = t.params.aspace !== 'handle' && t.params.aspace !== 'bad_aspace';\n  t.expectCompileResult(success, code);\n});\n\ng.test('access_mode').\ndesc('Test access mode in pointer type parameterization').\nparams((u) =>\nu.\ncombine('aspace', ['function', 'private', 'storage', 'uniform', 'workgroup']).\ncombine('access', ['read', 'write', 'read_write']).\ncombine('comma', ['', ','])\n).\nfn((t) => {\n  // Default access mode is tested above.\n  const code = `alias T = ptr<${t.params.aspace}, u32, ${t.params.access}${t.params.comma}>;`;\n  const success = t.params.aspace === 'storage' && t.params.access !== 'write';\n  t.expectCompileResult(success, code);\n});\n\n\n\n\n\n\n\n\nconst kTypeCases = {\n  // Scalars\n  bool: { type: `bool`, storable: true, aspace: 'function' },\n  u32: { type: `u32`, storable: true },\n  i32: { type: `i32`, storable: true },\n  f32: { type: `f32`, storable: true },\n  f16: { type: `f16`, storable: true, f16: true },\n\n  // Vectors\n  vec2u: { type: `vec2u`, storable: true },\n  vec3i: { type: `vec3i`, storable: true },\n  vec4f: { type: `vec4f`, storable: true },\n  vec2_bool: { type: `vec2<bool>`, storable: true, aspace: 'workgroup' },\n  vec3h: { type: `vec3h`, storable: true, f16: true },\n\n  // Matrices\n  mat2x2f: { type: `mat2x2f`, storable: true },\n  mat3x4h: { type: `mat3x4h`, storable: true, f16: true },\n\n  // Atomics\n  atomic_u32: { type: `atomic<u32>`, storable: true },\n  atomic_i32: { type: `atomic<i32>`, storable: true },\n\n  // Arrays\n  array_sized_u32: { type: `array<u32, 4>`, storable: true },\n  array_sized_vec4f: { type: `array<vec4f, 16>`, storable: true },\n  array_sized_S: { type: `array<S, 2>`, storable: true },\n  array_runtime_u32: { type: `array<u32>`, storable: true },\n  array_runtime_S: { type: `array<S>`, storable: true },\n  array_runtime_atomic_u32: { type: `array<atomic<u32>>`, storable: true },\n  array_override_u32: { type: `array<u32, o>`, storable: true, aspace: 'workgroup' },\n\n  // Structs\n  struct_S: { type: `S`, storable: true },\n  struct_T: { type: `T`, storable: true },\n\n  // Pointers\n  ptr_function_u32: { type: `ptr<function, u32>`, storable: false },\n  ptr_workgroup_bool: { type: `ptr<workgroup, bool>`, storable: false },\n\n  // Sampler (while storable, can only be in the handle address space)\n  sampler: { type: `sampler`, storable: false },\n\n  // Texture (while storable, can only be in the handle address space)\n  texture_2d: { type: `texture_2d<f32>`, storable: false },\n\n  // Alias\n  alias: { type: `u32_alias`, storable: true },\n\n  // Reference\n  reference: { type: `ref<function, u32>`, storable: false, aspace: 'function' }\n};\n\ng.test('type').\ndesc('Tests that pointee type must be storable').\nparams((u) => u.combine('case', keysOf(kTypeCases))).\nbeforeAllSubcases((t) => {\n  if (kTypeCases[t.params.case].f16) {\n    t.selectDeviceOrSkipTestCase('shader-f16');\n  }\n}).\nfn((t) => {\n  const testcase = kTypeCases[t.params.case];\n  const aspace = testcase.aspace ?? 'storage';\n  const access = testcase.type.includes('atomic') ? ', read_write' : '';\n  const code = `${testcase.f16 ? 'enable f16;' : ''}\n    override o : u32;\n    struct S { x : u32 }\n    struct T { s : array<S> }\n    alias u32_alias = u32;\n    alias Type = ptr<${aspace}, ${testcase.type}${access}>;`;\n  t.expectCompileResult(testcase.storable, code);\n});\n\n// Address spaces that can hold an i32 variable.\nconst kNonHandleAddressSpaces = keysOf(kAddressSpaceInfo).filter(\n  (as) => as !== 'handle'\n);\n\ng.test('let_ptr_explicit_type_matches_var').\ndesc(\n  'Let-declared pointer with explicit type initialized from var with same address space and access mode'\n).\nspecURL('https://w3.org/TR#ref-ptr-types').\nparams((u) =>\nu // Generate non-handle variables in all valid permutations of address space and access mode.\n.combine('addressSpace', kNonHandleAddressSpaces).\nexpand('explicitSpace', explicitSpaceExpander).\ncombine('explicitAccess', [false, true]).\nexpand('accessMode', accessModeExpander).\ncombine('stage', ['compute']) // Only need to check compute shaders\n// Vary the store type.\n.combine('ptrStoreType', ['i32', 'u32'])\n).\nfn((t) => {\n  // Match the address space and access mode.\n  const prog = getVarDeclShader(t.params, `let p: ${pointerType(t.params)} = &x;`);\n  const ok = t.params.ptrStoreType === 'i32'; // The store type matches the variable's store type.\n\n  t.expectCompileResult(ok, prog);\n});\n\ng.test('let_ptr_reads').\ndesc('Validate reading via ptr when permitted by access mode').\nparams((u) =>\nu // Generate non-handle variables in all valid permutations of address space and access mode.\n.combine('addressSpace', kNonHandleAddressSpaces).\nexpand('explicitSpace', explicitSpaceExpander).\ncombine('explicitAccess', [false, true]).\nexpand('accessMode', accessModeExpander).\ncombine('stage', ['compute']) // Only need to check compute shaders\n.combine('inferPtrType', [false, true]).\ncombine('ptrStoreType', ['i32'])\n).\nfn((t) => {\n  // Try reading through the pointer.\n  const typePart = t.params.inferPtrType ? `: ${pointerType(t.params)}` : '';\n  const prog = getVarDeclShader(t.params, `let p${typePart} = &x; let read = *p;`);\n  const ok = true; // We can always read.\n\n  t.expectCompileResult(ok, prog);\n});\n\ng.test('let_ptr_writes').\ndesc('Validate writing via ptr when permitted by access mode').\nspecURL('https://w3.org/TR#ref-ptr-types').\nparams((u) =>\nu // Generate non-handle variables in all valid permutations of address space and access mode.\n.combine('addressSpace', kNonHandleAddressSpaces).\nexpand('explicitSpace', explicitSpaceExpander).\ncombine('explicitAccess', [false, true]).\nexpand('accessMode', accessModeExpander).\ncombine('stage', ['compute']) // Only need to check compute shaders\n.combine('inferPtrType', [false, true]).\ncombine('ptrStoreType', ['i32'])\n).\nfn((t) => {\n  // Try writing through the pointer.\n  const typePart = t.params.inferPtrType ? `: ${pointerType(t.params)}` : '';\n  const prog = getVarDeclShader(t.params, `let p${typePart} = &x; *p = 42;`);\n  const ok = supportsWrite(t.params);\n\n  t.expectCompileResult(ok, prog);\n});\n\ng.test('ptr_handle_space_invalid').fn((t) => {\n  t.expectCompileResult(false, 'alias p = ptr<handle,u32>;');\n});\n\ng.test('ptr_bad_store_type').\nparams((u) => u.combine('storeType', ['undeclared', 'clamp', '1'])).\nfn((t) => {\n  t.expectCompileResult(false, `alias p = ptr<private,${t.params.storeType}>;`);\n});\n\ng.test('ptr_address_space_never_uses_access_mode').\nparams((u) =>\nu.\ncombine(\n  'addressSpace',\n  keysOf(kAddressSpaceInfo).filter((i) => kAddressSpaceInfo[i].spellAccessMode === 'never')\n).\ncombine('accessMode', keysOf(kAccessModeInfo))\n).\nfn((t) => {\n  const prog = `alias pty = ptr<${t.params.addressSpace},u32,;${t.params.accessMode}>;`;\n  t.expectCompileResult(false, prog);\n});\n\nconst kStoreTypeNotInstantiable = {\n  ptr: 'alias p = ptr<storage,ptr<private,i32>>;',\n  privateAtomic: 'alias p = ptr<private,atomic<u32>>;',\n  functionAtomic: 'alias p = ptr<function,atomic<u32>>;',\n  uniformAtomic: 'alias p = ptr<uniform,atomic<u32>>;',\n  workgroupRTArray: 'alias p = ptr<workgroup,array<i32>>;',\n  uniformRTArray: 'alias p = ptr<uniform,array<i32>>;',\n  privateRTArray: 'alias p = ptr<private,array<i32>>;',\n  functionRTArray: 'alias p = ptr<function,array<i32>>;',\n  RTArrayNotLast: 'struct S { a: array<i32>, b: i32 } alias p = ptr<storage,S>;',\n  nestedRTArray: 'struct S { a: array<i32>, b: i32 } struct { s: S } alias p = ptr<storage,T>;'\n};\n\ng.test('ptr_not_instantiable').\ndesc(\n  'Validate that ptr type must correspond to a variable that could be declared somewhere; test bad cases'\n).\nparams((u) => u.combine('case', keysOf(kStoreTypeNotInstantiable))).\nfn((t) => {\n  t.expectCompileResult(false, kStoreTypeNotInstantiable[t.params.case]);\n});"],"mappings":"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","ignoreList":[]}