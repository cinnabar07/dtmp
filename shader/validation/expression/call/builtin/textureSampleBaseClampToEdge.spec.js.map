{"version":3,"file":"textureSampleBaseClampToEdge.spec.js","names":["builtin","description","makeTestGroup","keysOf","objectsToRecord","Type","kAllScalarsAndVectors","isConvertible","isUnsignedType","ShaderValidationTest","kTestTextureTypes","kTextureSampleBaseClampToEdgeTextureTypes","kValuesTypes","g","test","specURL","desc","params","u","combine","fn","t","returnType","textureType","returnVarType","varWGSL","toString","code","expectSuccess","vec4f","expectCompileResult","beginSubcases","filter","coordType","value","coordArgType","coordWGSL","create","wgsl","vec2f","testTextureType","includes","use"],"sources":["../../../../../../../src/webgpu/shader/validation/expression/call/builtin/textureSampleBaseClampToEdge.spec.ts"],"sourcesContent":["/**\n* AUTO-GENERATED - DO NOT EDIT. Source: https://github.com/gpuweb/cts\n**/const builtin = 'textureSampleBaseClampToEdge';export const description = `\nValidation tests for the ${builtin}() builtin.\n\n* test textureSampleBaseClampToEdge coords parameter must be correct type\n* test textureSampleBaseClampToEdge returns the correct type\n* test textureSampleBaseClampToEdge doesn't work with texture types it's not supposed to\n`;\nimport { makeTestGroup } from '../../../../../../common/framework/test_group.js';\nimport { keysOf, objectsToRecord } from '../../../../../../common/util/data_tables.js';\nimport {\n  Type,\n  kAllScalarsAndVectors,\n  isConvertible,\n  isUnsignedType } from\n'../../../../../util/conversion.js';\nimport { ShaderValidationTest } from '../../../shader_validation_test.js';\n\nimport { kTestTextureTypes } from './shader_builtin_utils.js';\n\nconst kTextureSampleBaseClampToEdgeTextureTypes = ['texture_2d<f32>', 'texture_external'];\nconst kValuesTypes = objectsToRecord(kAllScalarsAndVectors);\n\nexport const g = makeTestGroup(ShaderValidationTest);\n\ng.test('return_type').\nspecURL('https://gpuweb.github.io/gpuweb/wgsl/#texturesamplebaseclamptoedge').\ndesc(\n  `\nValidates the return type of ${builtin} is the expected type.\n`\n).\nparams((u) =>\nu.\ncombine('returnType', keysOf(kValuesTypes)).\ncombine('textureType', kTextureSampleBaseClampToEdgeTextureTypes)\n).\nfn((t) => {\n  const { returnType, textureType } = t.params;\n  const returnVarType = kValuesTypes[returnType];\n\n  const varWGSL = returnVarType.toString();\n\n  const code = `\n@group(0) @binding(0) var s: sampler;\n@group(0) @binding(1) var t: ${textureType};\n@fragment fn fs() -> @location(0) vec4f {\n  let v: ${varWGSL} = textureSampleBaseClampToEdge(t, s, vec2f(0));\n  return vec4f(0);\n}\n`;\n  const expectSuccess = isConvertible(Type.vec4f, returnVarType);\n  t.expectCompileResult(expectSuccess, code);\n});\n\ng.test('coords_argument').\nspecURL('https://gpuweb.github.io/gpuweb/wgsl/#texturesamplebaseclamptoedge').\ndesc(\n  `\nValidates that only incorrect coords arguments are rejected by ${builtin}\n`\n).\nparams((u) =>\nu.\ncombine('textureType', kTextureSampleBaseClampToEdgeTextureTypes).\ncombine('coordType', keysOf(kValuesTypes)).\nbeginSubcases().\ncombine('value', [-1, 0, 1])\n// filter out unsigned types with negative values\n.filter((t) => !isUnsignedType(kValuesTypes[t.coordType]) || t.value >= 0)\n).\nfn((t) => {\n  const { textureType, coordType, value } = t.params;\n  const coordArgType = kValuesTypes[coordType];\n  const coordWGSL = coordArgType.create(value).wgsl();\n\n  const code = `\n@group(0) @binding(0) var s: sampler;\n@group(0) @binding(1) var t: ${textureType};\n@fragment fn fs() -> @location(0) vec4f {\n  let v = textureSampleBaseClampToEdge(t, s, ${coordWGSL});\n  return vec4f(0);\n}\n`;\n  const expectSuccess = isConvertible(coordArgType, Type.vec2f);\n  t.expectCompileResult(expectSuccess, code);\n});\n\ng.test('texture_type').\nspecURL('https://gpuweb.github.io/gpuweb/wgsl/#texturesamplebaseclamptoedge').\ndesc(\n  `\nValidates that incompatible texture types don't work with ${builtin}\n`\n).\nparams((u) => u.combine('testTextureType', kTestTextureTypes)).\nfn((t) => {\n  const { testTextureType } = t.params;\n\n  const code = `\n@group(0) @binding(0) var s: sampler;\n@group(0) @binding(1) var t: ${testTextureType};\n@fragment fn fs() -> @location(0) vec4f {\n  let v = textureSampleBaseClampToEdge(t, s, vec2f(0));\n  return vec4f(0);\n}\n`;\n  const expectSuccess = kTextureSampleBaseClampToEdgeTextureTypes.includes(testTextureType);\n  t.expectCompileResult(expectSuccess, code);\n});\n\ng.test('must_use').\ndesc('Tests that the result must be used').\nparams((u) => u.combine('use', [true, false])).\nfn((t) => {\n  const code = `\n    @group(0) @binding(0) var t : texture_2d<f32>;\n    @group(0) @binding(1) var s : sampler;\n    fn foo() {\n      ${t.params.use ? '_ =' : ''} textureSampleBaseClampToEdge(t,s, vec2(0,0));\n    }`;\n  t.expectCompileResult(t.params.use, code);\n});"],"mappings":"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","ignoreList":[]}