{"version":3,"file":"and_or_xor.spec.js","names":["description","makeTestGroup","keysOf","objectsToRecord","concreteTypeOf","isAbstractType","isConvertible","isIntegerType","kAllScalarsAndVectors","scalarTypeOf","Type","ShaderValidationTest","resultType","g","kOperators","and","op","supportsBool","or","xor","kScalarAndVectorTypes","test","desc","params","u","combine","filter","value","startsWith","beginSubcases","beforeAllSubcases","t","lhs","f16","rhs","selectDeviceOrSkipTestCase","fn","lhsElement","rhsElement","hasBool","bool","hasF16","resType","canConvertScalarToVector","resTypeIsTypeable","code","compound_assignment","create","wgsl","valid","expectCompileResult","kInvalidTypes","mat2x2f","expr","control","e","array","ptr","atomic","texture","sampler","struct","type"],"sources":["../../../../../../src/webgpu/shader/validation/expression/binary/and_or_xor.spec.ts"],"sourcesContent":["/**\n* AUTO-GENERATED - DO NOT EDIT. Source: https://github.com/gpuweb/cts\n**/export const description = `\nValidation tests for logical and bitwise and/or/xor expressions.\n`;import { makeTestGroup } from '../../../../../common/framework/test_group.js';\nimport { keysOf, objectsToRecord } from '../../../../../common/util/data_tables.js';\nimport {\n  concreteTypeOf,\n  isAbstractType,\n  isConvertible,\n  isIntegerType,\n  kAllScalarsAndVectors,\n  scalarTypeOf,\n  Type } from\n'../../../../util/conversion.js';\nimport { ShaderValidationTest } from '../../shader_validation_test.js';\n\nimport { resultType } from './result_type.js';\n\nexport const g = makeTestGroup(ShaderValidationTest);\n\n// A list of operators and a flag for whether they support boolean values or not.\nconst kOperators = {\n  and: { op: '&', supportsBool: true },\n  or: { op: '|', supportsBool: true },\n  xor: { op: '^', supportsBool: false }\n};\n\n// A list of scalar and vector types.\nconst kScalarAndVectorTypes = objectsToRecord(kAllScalarsAndVectors);\n\ng.test('scalar_vector').\ndesc(\n  `\n  Validates that scalar and vector expressions are only accepted for bool or compatible integer types.\n  `\n).\nparams((u) =>\nu.\ncombine('lhs', keysOf(kScalarAndVectorTypes)).\ncombine(\n  'rhs',\n  // Skip vec3 and vec4 on the RHS to keep the number of subcases down.\n  // vec3 + vec3 and vec4 + vec4 is tested in execution tests.\n  keysOf(kScalarAndVectorTypes).filter(\n    (value) => !(value.startsWith('vec3') || value.startsWith('vec4'))\n  )\n).\ncombine('compound_assignment', [false, true]).\nbeginSubcases().\ncombine('op', keysOf(kOperators))\n).\nbeforeAllSubcases((t) => {\n  if (\n  scalarTypeOf(kScalarAndVectorTypes[t.params.lhs]) === Type.f16 ||\n  scalarTypeOf(kScalarAndVectorTypes[t.params.rhs]) === Type.f16)\n  {\n    t.selectDeviceOrSkipTestCase('shader-f16');\n  }\n}).\nfn((t) => {\n  const op = kOperators[t.params.op];\n  const lhs = kScalarAndVectorTypes[t.params.lhs];\n  const rhs = kScalarAndVectorTypes[t.params.rhs];\n  const lhsElement = scalarTypeOf(lhs);\n  const rhsElement = scalarTypeOf(rhs);\n  const hasBool = lhsElement === Type.bool || rhsElement === Type.bool;\n  const hasF16 = lhsElement === Type.f16 || rhsElement === Type.f16;\n  const resType =\n  isIntegerType(lhsElement) && isIntegerType(rhsElement) || hasBool && op.supportsBool ?\n  resultType({ lhs, rhs, canConvertScalarToVector: false }) :\n  null;\n  const resTypeIsTypeable = resType && !isAbstractType(scalarTypeOf(resType));\n  const code = t.params.compound_assignment ?\n  `\n${hasF16 ? 'enable f16;' : ''}\nfn f() {\n  var foo = ${lhs.create(0).wgsl()};\n  foo ${op.op}= ${rhs.create(0).wgsl()};\n}\n` :\n  `\n${hasF16 ? 'enable f16;' : ''}\nconst lhs = ${lhs.create(0).wgsl()};\nconst rhs = ${rhs.create(0).wgsl()};\nconst foo ${resTypeIsTypeable ? `: ${resType}` : ''} = lhs ${op.op} rhs;\n`;\n\n  let valid = resType !== null;\n  if (valid && t.params.compound_assignment) {\n    valid = valid && isConvertible(resType, concreteTypeOf(lhs));\n  }\n\n  t.expectCompileResult(valid, code);\n});\n\n\n\n\n\n\n\nconst kInvalidTypes = {\n  mat2x2f: {\n    expr: 'm',\n    control: (e) => `i32(${e}[0][0])`\n  },\n\n  array: {\n    expr: 'arr',\n    control: (e) => `${e}[0]`\n  },\n\n  ptr: {\n    expr: '(&u)',\n    control: (e) => `*${e}`\n  },\n\n  atomic: {\n    expr: 'a',\n    control: (e) => `atomicLoad(&${e})`\n  },\n\n  texture: {\n    expr: 't',\n    control: (e) => `i32(textureLoad(${e}, vec2(), 0).x)`\n  },\n\n  sampler: {\n    expr: 's',\n    control: (e) => `i32(textureSampleLevel(t, ${e}, vec2(), 0).x)`\n  },\n\n  struct: {\n    expr: 'str',\n    control: (e) => `${e}.u`\n  }\n};\n\ng.test('invalid_types').\ndesc(\n  `\n  Validates that expressions are never accepted for non-scalar and non-vector types.\n  `\n).\nparams((u) =>\nu.\ncombine('op', keysOf(kOperators)).\ncombine('type', keysOf(kInvalidTypes)).\ncombine('control', [true, false]).\nbeginSubcases()\n).\nfn((t) => {\n  const op = kOperators[t.params.op];\n  const type = kInvalidTypes[t.params.type];\n  const expr = t.params.control ? type.control(type.expr) : type.expr;\n  const code = `\n@group(0) @binding(0) var t : texture_2d<f32>;\n@group(0) @binding(1) var s : sampler;\n@group(0) @binding(2) var<storage, read_write> a : atomic<i32>;\n\nstruct S { u : u32 }\n\nvar<private> u : u32;\nvar<private> m : mat2x2f;\nvar<private> arr : array<i32, 4>;\nvar<private> str : S;\n\n@compute @workgroup_size(1)\nfn main() {\n  let foo = ${expr} ${op.op} ${expr};\n}\n`;\n\n  t.expectCompileResult(t.params.control, code);\n});"],"mappings":";;IAAA;AACA;AACA,GAAG,OAAO,MAAMA,WAAW,GAAG;AAC9B;AACA,CAAC,CAAC,SAASC,aAAa,QAAQ,+CAA+C,CAC/E,SAASC,MAAM,EAAEC,eAAe,QAAQ,2CAA2C,CACnF;EACEC,cAAc;EACdC,cAAc;EACdC,aAAa;EACbC,aAAa;EACbC,qBAAqB;EACrBC,YAAY;EACZC,IAAI;AACN,gCAAgC;AAChC,SAASC,oBAAoB,QAAQ,iCAAiC;;AAEtE,SAASC,UAAU,QAAQ,kBAAkB;;AAE7C,OAAO,MAAMC,CAAC,GAAGZ,aAAa,CAACU,oBAAoB,CAAC;;AAEpD;AACA,MAAMG,UAAU,GAAG;EACjBC,GAAG,EAAE,EAAEC,EAAE,EAAE,GAAG,EAAEC,YAAY,EAAE,IAAI,CAAC,CAAC;EACpCC,EAAE,EAAE,EAAEF,EAAE,EAAE,GAAG,EAAEC,YAAY,EAAE,IAAI,CAAC,CAAC;EACnCE,GAAG,EAAE,EAAEH,EAAE,EAAE,GAAG,EAAEC,YAAY,EAAE,KAAK,CAAC;AACtC,CAAC;;AAED;AACA,MAAMG,qBAAqB,GAAGjB,eAAe,CAACK,qBAAqB,CAAC;;AAEpEK,CAAC,CAACQ,IAAI,CAAC,eAAe,CAAC;AACvBC,IAAI;EACF;AACF;AACA;AACA,CAAC;AACDC,MAAM,CAAC,CAACC,CAAC;AACTA,CAAC;AACDC,OAAO,CAAC,KAAK,EAAEvB,MAAM,CAACkB,qBAAqB,CAAC,CAAC;AAC7CK,OAAO;EACL,KAAK;EACL;EACA;EACAvB,MAAM,CAACkB,qBAAqB,CAAC,CAACM,MAAM;IAClC,CAACC,KAAK,KAAK,EAAEA,KAAK,CAACC,UAAU,CAAC,MAAM,CAAC,IAAID,KAAK,CAACC,UAAU,CAAC,MAAM,CAAC;EACnE;AACF,CAAC;AACDH,OAAO,CAAC,qBAAqB,EAAE,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;AAC7CI,aAAa,CAAC,CAAC;AACfJ,OAAO,CAAC,IAAI,EAAEvB,MAAM,CAACY,UAAU,CAAC;AAChC,CAAC;AACDgB,iBAAiB,CAAC,CAACC,CAAC,KAAK;EACvB;EACAtB,YAAY,CAACW,qBAAqB,CAACW,CAAC,CAACR,MAAM,CAACS,GAAG,CAAC,CAAC,KAAKtB,IAAI,CAACuB,GAAG;EAC9DxB,YAAY,CAACW,qBAAqB,CAACW,CAAC,CAACR,MAAM,CAACW,GAAG,CAAC,CAAC,KAAKxB,IAAI,CAACuB,GAAG;EAC9D;IACEF,CAAC,CAACI,0BAA0B,CAAC,YAAY,CAAC;EAC5C;AACF,CAAC,CAAC;AACFC,EAAE,CAAC,CAACL,CAAC,KAAK;EACR,MAAMf,EAAE,GAAGF,UAAU,CAACiB,CAAC,CAACR,MAAM,CAACP,EAAE,CAAC;EAClC,MAAMgB,GAAG,GAAGZ,qBAAqB,CAACW,CAAC,CAACR,MAAM,CAACS,GAAG,CAAC;EAC/C,MAAME,GAAG,GAAGd,qBAAqB,CAACW,CAAC,CAACR,MAAM,CAACW,GAAG,CAAC;EAC/C,MAAMG,UAAU,GAAG5B,YAAY,CAACuB,GAAG,CAAC;EACpC,MAAMM,UAAU,GAAG7B,YAAY,CAACyB,GAAG,CAAC;EACpC,MAAMK,OAAO,GAAGF,UAAU,KAAK3B,IAAI,CAAC8B,IAAI,IAAIF,UAAU,KAAK5B,IAAI,CAAC8B,IAAI;EACpE,MAAMC,MAAM,GAAGJ,UAAU,KAAK3B,IAAI,CAACuB,GAAG,IAAIK,UAAU,KAAK5B,IAAI,CAACuB,GAAG;EACjE,MAAMS,OAAO;EACbnC,aAAa,CAAC8B,UAAU,CAAC,IAAI9B,aAAa,CAAC+B,UAAU,CAAC,IAAIC,OAAO,IAAIvB,EAAE,CAACC,YAAY;EACpFL,UAAU,CAAC,EAAEoB,GAAG,EAAEE,GAAG,EAAES,wBAAwB,EAAE,KAAK,CAAC,CAAC,CAAC;EACzD,IAAI;EACJ,MAAMC,iBAAiB,GAAGF,OAAO,IAAI,CAACrC,cAAc,CAACI,YAAY,CAACiC,OAAO,CAAC,CAAC;EAC3E,MAAMG,IAAI,GAAGd,CAAC,CAACR,MAAM,CAACuB,mBAAmB;EACzC;AACF,EAAEL,MAAM,GAAG,aAAa,GAAG,EAAE;AAC7B;AACA,cAAcT,GAAG,CAACe,MAAM,CAAC,CAAC,CAAC,CAACC,IAAI,CAAC,CAAC;AAClC,QAAQhC,EAAE,CAACA,EAAE,KAAKkB,GAAG,CAACa,MAAM,CAAC,CAAC,CAAC,CAACC,IAAI,CAAC,CAAC;AACtC;AACA,CAAC;EACC;AACF,EAAEP,MAAM,GAAG,aAAa,GAAG,EAAE;AAC7B,cAAcT,GAAG,CAACe,MAAM,CAAC,CAAC,CAAC,CAACC,IAAI,CAAC,CAAC;AAClC,cAAcd,GAAG,CAACa,MAAM,CAAC,CAAC,CAAC,CAACC,IAAI,CAAC,CAAC;AAClC,YAAYJ,iBAAiB,GAAG,KAAKF,OAAO,EAAE,GAAG,EAAE,UAAU1B,EAAE,CAACA,EAAE;AAClE,CAAC;;EAEC,IAAIiC,KAAK,GAAGP,OAAO,KAAK,IAAI;EAC5B,IAAIO,KAAK,IAAIlB,CAAC,CAACR,MAAM,CAACuB,mBAAmB,EAAE;IACzCG,KAAK,GAAGA,KAAK,IAAI3C,aAAa,CAACoC,OAAO,EAAEtC,cAAc,CAAC4B,GAAG,CAAC,CAAC;EAC9D;;EAEAD,CAAC,CAACmB,mBAAmB,CAACD,KAAK,EAAEJ,IAAI,CAAC;AACpC,CAAC,CAAC;;;;;;;;AAQF,MAAMM,aAAa,GAAG;EACpBC,OAAO,EAAE;IACPC,IAAI,EAAE,GAAG;IACTC,OAAO,EAAEA,CAACC,CAAC,KAAK,OAAOA,CAAC;EAC1B,CAAC;;EAEDC,KAAK,EAAE;IACLH,IAAI,EAAE,KAAK;IACXC,OAAO,EAAEA,CAACC,CAAC,KAAK,GAAGA,CAAC;EACtB,CAAC;;EAEDE,GAAG,EAAE;IACHJ,IAAI,EAAE,MAAM;IACZC,OAAO,EAAEA,CAACC,CAAC,KAAK,IAAIA,CAAC;EACvB,CAAC;;EAEDG,MAAM,EAAE;IACNL,IAAI,EAAE,GAAG;IACTC,OAAO,EAAEA,CAACC,CAAC,KAAK,eAAeA,CAAC;EAClC,CAAC;;EAEDI,OAAO,EAAE;IACPN,IAAI,EAAE,GAAG;IACTC,OAAO,EAAEA,CAACC,CAAC,KAAK,mBAAmBA,CAAC;EACtC,CAAC;;EAEDK,OAAO,EAAE;IACPP,IAAI,EAAE,GAAG;IACTC,OAAO,EAAEA,CAACC,CAAC,KAAK,6BAA6BA,CAAC;EAChD,CAAC;;EAEDM,MAAM,EAAE;IACNR,IAAI,EAAE,KAAK;IACXC,OAAO,EAAEA,CAACC,CAAC,KAAK,GAAGA,CAAC;EACtB;AACF,CAAC;;AAED1C,CAAC,CAACQ,IAAI,CAAC,eAAe,CAAC;AACvBC,IAAI;EACF;AACF;AACA;AACA,CAAC;AACDC,MAAM,CAAC,CAACC,CAAC;AACTA,CAAC;AACDC,OAAO,CAAC,IAAI,EAAEvB,MAAM,CAACY,UAAU,CAAC,CAAC;AACjCW,OAAO,CAAC,MAAM,EAAEvB,MAAM,CAACiD,aAAa,CAAC,CAAC;AACtC1B,OAAO,CAAC,SAAS,EAAE,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;AACjCI,aAAa,CAAC;AACd,CAAC;AACDO,EAAE,CAAC,CAACL,CAAC,KAAK;EACR,MAAMf,EAAE,GAAGF,UAAU,CAACiB,CAAC,CAACR,MAAM,CAACP,EAAE,CAAC;EAClC,MAAM8C,IAAI,GAAGX,aAAa,CAACpB,CAAC,CAACR,MAAM,CAACuC,IAAI,CAAC;EACzC,MAAMT,IAAI,GAAGtB,CAAC,CAACR,MAAM,CAAC+B,OAAO,GAAGQ,IAAI,CAACR,OAAO,CAACQ,IAAI,CAACT,IAAI,CAAC,GAAGS,IAAI,CAACT,IAAI;EACnE,MAAMR,IAAI,GAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAcQ,IAAI,IAAIrC,EAAE,CAACA,EAAE,IAAIqC,IAAI;AACnC;AACA,CAAC;;EAECtB,CAAC,CAACmB,mBAAmB,CAACnB,CAAC,CAACR,MAAM,CAAC+B,OAAO,EAAET,IAAI,CAAC;AAC/C,CAAC,CAAC","ignoreList":[]}