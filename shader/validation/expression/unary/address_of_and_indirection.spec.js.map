{"version":3,"file":"address_of_and_indirection.spec.js","names":["description","makeTestGroup","keysOf","ShaderValidationTest","g","kAddressSpaces","kAccessModes","kStorageTypes","kCompositeTypes","kDerefTypes","deref_address_of_identifier","wgsl","requires_pointer_composite_access","deref_pointer","address_of_identifier","pointer","test","desc","params","u","combine","filter","t","storageType","addressSpace","derefType","beforeAllSubcases","selectDeviceOrSkipTestCase","requiredFeatures","fn","isLocal","deref","commaAccessMode","accessMode","varDecl","expectCompileResult","beginSubcases","compositeType","shouldPass","hasLanguageFeature","kInvalidCases","address_of_let","address_of_texture","address_of_sampler","address_of_function","address_of_vector_elem_via_member","address_of_vector_elem_via_index","address_of_matrix_elem","deref_non_pointer","case"],"sources":["../../../../../../src/webgpu/shader/validation/expression/unary/address_of_and_indirection.spec.ts"],"sourcesContent":["/**\n* AUTO-GENERATED - DO NOT EDIT. Source: https://github.com/gpuweb/cts\n**/export const description = `\nValidation tests for unary address-of and indirection (dereference)\n`;import { makeTestGroup } from '../../../../../common/framework/test_group.js';\nimport { keysOf } from '../../../../../common/util/data_tables.js';\nimport { ShaderValidationTest } from '../../shader_validation_test.js';\n\nexport const g = makeTestGroup(ShaderValidationTest);\n\nconst kAddressSpaces = ['function', 'private', 'workgroup', 'uniform', 'storage'];\nconst kAccessModes = ['read', 'read_write'];\nconst kStorageTypes = ['bool', 'u32', 'i32', 'f32', 'f16'];\nconst kCompositeTypes = ['array', 'struct', 'vec', 'mat'];\nconst kDerefTypes = {\n  deref_address_of_identifier: {\n    wgsl: `(*(&a))`,\n    requires_pointer_composite_access: false\n  },\n  deref_pointer: {\n    wgsl: `(*p)`,\n    requires_pointer_composite_access: false\n  },\n  address_of_identifier: {\n    wgsl: `(&a)`,\n    requires_pointer_composite_access: true\n  },\n  pointer: {\n    wgsl: `p`,\n    requires_pointer_composite_access: true\n  }\n};\n\ng.test('basic').\ndesc(\n  `Validates address-of (&) every supported variable type, ensuring the type is correct by\n    assigning to an explicitly typed pointer. Also validates dereferencing the reference,\n    ensuring the type is correct by assigning to an explicitly typed variable.`\n).\nparams((u) =>\nu.\ncombine('addressSpace', kAddressSpaces).\ncombine('accessMode', kAccessModes).\ncombine('storageType', kStorageTypes).\ncombine('derefType', keysOf(kDerefTypes)).\nfilter((t) => {\n  if (t.storageType === 'bool') {\n    return t.addressSpace === 'function' || t.addressSpace === 'private';\n  }\n  return true;\n}).\nfilter((t) => {\n  // This test does not test composite access\n  return !kDerefTypes[t.derefType].requires_pointer_composite_access;\n})\n).\nbeforeAllSubcases((t) => {\n  if (t.params.storageType === 'f16') {\n    t.selectDeviceOrSkipTestCase({ requiredFeatures: ['shader-f16'] });\n  }\n}).\nfn((t) => {\n  const isLocal = t.params.addressSpace === 'function';\n  const deref = kDerefTypes[t.params.derefType];\n  // Only specify access mode for storage buffers\n  const commaAccessMode = t.params.addressSpace === 'storage' ? `, ${t.params.accessMode}` : '';\n\n  let varDecl = '';\n  if (t.params.addressSpace === 'uniform' || t.params.addressSpace === 'storage') {\n    varDecl += '@group(0) @binding(0) ';\n  }\n  varDecl += `var<${t.params.addressSpace}${commaAccessMode}> a : VarType;`;\n\n  const wgsl = `\n      ${t.params.storageType === 'f16' ? 'enable f16;' : ''}\n\n      alias VarType = ${t.params.storageType};\n      alias PtrType = ptr<${t.params.addressSpace}, VarType ${commaAccessMode}>;\n\n      ${isLocal ? '' : varDecl}\n\n      fn foo() {\n        ${isLocal ? varDecl : ''}\n        let p : PtrType = &a;\n        var deref : VarType = ${deref.wgsl};\n      }\n    `;\n\n  t.expectCompileResult(true, wgsl);\n});\n\ng.test('composite').\ndesc(\n  `Validates address-of (&) every supported variable type for composite types, ensuring the type\n    is correct by assigning to an explicitly typed pointer. Also validates dereferencing the\n    reference followed by member/index access, ensuring the type is correct by assigning to an\n    explicitly typed variable.`\n).\nparams((u) =>\nu.\ncombine('addressSpace', kAddressSpaces).\ncombine('compositeType', kCompositeTypes).\ncombine('storageType', kStorageTypes).\nbeginSubcases().\ncombine('derefType', keysOf(kDerefTypes)).\ncombine('accessMode', kAccessModes).\nfilter((t) => {\n  if (t.storageType === 'bool') {\n    return t.addressSpace === 'function' || t.addressSpace === 'private';\n  }\n  return true;\n}).\nfilter((t) => {\n  if (t.compositeType === 'mat') {\n    return t.storageType === 'f32' || t.storageType === 'f16';\n  }\n  return true;\n})\n).\nbeforeAllSubcases((t) => {\n  if (t.params.storageType === 'f16') {\n    t.selectDeviceOrSkipTestCase({ requiredFeatures: ['shader-f16'] });\n  }\n}).\nfn((t) => {\n  const isLocal = t.params.addressSpace === 'function';\n  const deref = kDerefTypes[t.params.derefType];\n  // Only specify access mode for storage buffers\n  const commaAccessMode = t.params.addressSpace === 'storage' ? `, ${t.params.accessMode}` : '';\n\n  let varDecl = '';\n  if (t.params.addressSpace === 'uniform' || t.params.addressSpace === 'storage') {\n    varDecl += '@group(0) @binding(0) ';\n  }\n  varDecl += `var<${t.params.addressSpace}${commaAccessMode}> a : VarType;`;\n\n  let wgsl = `\n          ${t.params.storageType === 'f16' ? 'enable f16;' : ''}`;\n\n  switch (t.params.compositeType) {\n    case 'array':\n      wgsl += `\n          struct S { @align(16) member : ${t.params.storageType} }\n          alias VarType = array<S, 10>;\n          alias PtrType = ptr<${t.params.addressSpace}, VarType ${commaAccessMode}>;\n          ${isLocal ? '' : varDecl}\n\n          fn foo() {\n            ${isLocal ? varDecl : ''}\n            let p : PtrType = &a;\n            var deref : ${t.params.storageType} = ${deref.wgsl}[0].member;\n          }`;\n      break;\n    case 'struct':\n      wgsl += `\n          struct S { member : ${t.params.storageType} }\n          alias VarType = S;\n          alias PtrType = ptr<${t.params.addressSpace}, VarType ${commaAccessMode}>;\n          ${isLocal ? '' : varDecl}\n\n          fn foo() {\n            ${isLocal ? varDecl : ''}\n            let p : PtrType = &a;\n            var deref : ${t.params.storageType} = ${deref.wgsl}.member;\n          }`;\n      break;\n    case 'vec':\n      wgsl += `\n          alias VarType = vec3<${t.params.storageType}>;\n          alias PtrType = ptr<${t.params.addressSpace}, VarType ${commaAccessMode}>;\n          ${isLocal ? '' : varDecl}\n\n          fn foo() {\n            ${isLocal ? varDecl : ''}\n            let p : PtrType = &a;\n            var deref_member : ${t.params.storageType} = ${deref.wgsl}.x;\n            var deref_index : ${t.params.storageType} = ${deref.wgsl}[0];\n          }`;\n      break;\n    case 'mat':\n      wgsl += `\n          alias VarType = mat2x3<${t.params.storageType}>;\n          alias PtrType = ptr<${t.params.addressSpace}, VarType ${commaAccessMode}>;\n          ${isLocal ? '' : varDecl}\n\n          fn foo() {\n            ${isLocal ? varDecl : ''}\n            let p : PtrType = &a;\n            var deref_vec : vec3<${t.params.storageType}> = ${deref.wgsl}[0];\n            var deref_elem : ${t.params.storageType} = ${deref.wgsl}[0][0];\n          }`;\n      break;\n  }\n\n  let shouldPass = true;\n  if (\n  kDerefTypes[t.params.derefType].requires_pointer_composite_access &&\n  !t.hasLanguageFeature('pointer_composite_access'))\n  {\n    shouldPass = false;\n  }\n\n  t.expectCompileResult(shouldPass, wgsl);\n});\n\nconst kInvalidCases = {\n  address_of_let: `\n    let a = 1;\n    let p = &a;`,\n  address_of_texture: `\n    let p = &t;`,\n  address_of_sampler: `\n    let p = &s;`,\n  address_of_function: `\n    let p = &func;`,\n  address_of_vector_elem_via_member: `\n    var a : vec3<f32>();\n    let p = &a.x;`,\n  address_of_vector_elem_via_index: `\n    var a : vec3<f32>();\n    let p = &a[0];`,\n  address_of_matrix_elem: `\n    var a : mat2x3<f32>();\n    let p = &a[0][0];`,\n  deref_non_pointer: `\n    var a = 1;\n    let p = *a;\n  `\n};\ng.test('invalid').\ndesc('Test invalid cases of unary address-of and dereference').\nparams((u) => u.combine('case', keysOf(kInvalidCases))).\nfn((t) => {\n  const wgsl = `\n      @group(0) @binding(0) var s : sampler;\n      @group(0) @binding(1) var t : texture_2d<f32>;\n      fn func() {}\n      fn main() {\n        ${kInvalidCases[t.params.case]}\n      }\n    `;\n  t.expectCompileResult(false, wgsl);\n});"],"mappings":"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","ignoreList":[]}