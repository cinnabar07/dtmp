{"version":3,"file":"logical_negation.spec.js","names":["description","makeTestGroup","keysOf","objectsToRecord","kAllScalarsAndVectors","scalarTypeOf","Type","ShaderValidationTest","g","kScalarAndVectorTypes","test","desc","params","u","combine","beginSubcases","beforeAllSubcases","t","type","f16","selectDeviceOrSkipTestCase","fn","elementTy","hasF16","code","create","wgsl","expectCompileResult","bool","kInvalidTypes","mat2x2f","expr","control","e","array","ptr","atomic","texture","sampler","struct","kTests","not_bool_literal","src","pass","not_bool_expr","not_not_bool_literal","not_not_bool_expr","not_int_literal","not_int_expr","stmt"],"sources":["../../../../../../src/webgpu/shader/validation/expression/unary/logical_negation.spec.ts"],"sourcesContent":["/**\n* AUTO-GENERATED - DO NOT EDIT. Source: https://github.com/gpuweb/cts\n**/export const description = `\nValidation tests for logical negation expressions.\n`;import { makeTestGroup } from '../../../../../common/framework/test_group.js';\nimport { keysOf, objectsToRecord } from '../../../../../common/util/data_tables.js';\nimport { kAllScalarsAndVectors, scalarTypeOf, Type } from '../../../../util/conversion.js';\nimport { ShaderValidationTest } from '../../shader_validation_test.js';\n\nexport const g = makeTestGroup(ShaderValidationTest);\n\n// A list of scalar and vector types.\nconst kScalarAndVectorTypes = objectsToRecord(kAllScalarsAndVectors);\n\ng.test('scalar_vector').\ndesc(\n  `\n  Validates that scalar and vector logical negation expressions are only accepted for bool types.\n  `\n).\nparams((u) => u.combine('type', keysOf(kScalarAndVectorTypes)).beginSubcases()).\nbeforeAllSubcases((t) => {\n  if (scalarTypeOf(kScalarAndVectorTypes[t.params.type]) === Type.f16) {\n    t.selectDeviceOrSkipTestCase('shader-f16');\n  }\n}).\nfn((t) => {\n  const type = kScalarAndVectorTypes[t.params.type];\n  const elementTy = scalarTypeOf(type);\n  const hasF16 = elementTy === Type.f16;\n  const code = `\n${hasF16 ? 'enable f16;' : ''}\nconst rhs = ${type.create(0).wgsl()};\nconst foo = !rhs;\n`;\n\n  t.expectCompileResult(elementTy === Type.bool, code);\n});\n\n\n\n\n\n\n\nconst kInvalidTypes = {\n  mat2x2f: {\n    expr: 'm',\n    control: (e) => `bool(${e}[0][0])`\n  },\n\n  array: {\n    expr: 'arr',\n    control: (e) => `${e}[0]`\n  },\n\n  ptr: {\n    expr: '(&b)',\n    control: (e) => `*${e}`\n  },\n\n  atomic: {\n    expr: 'a',\n    control: (e) => `bool(atomicLoad(&${e}))`\n  },\n\n  texture: {\n    expr: 't',\n    control: (e) => `bool(textureLoad(${e}, vec2(), 0).x)`\n  },\n\n  sampler: {\n    expr: 's',\n    control: (e) => `bool(textureSampleLevel(t, ${e}, vec2(), 0).x)`\n  },\n\n  struct: {\n    expr: 'str',\n    control: (e) => `${e}.b`\n  }\n};\n\ng.test('invalid_types').\ndesc(\n  `\n  Validates that logical negation expressions are never accepted for non-scalar and non-vector types.\n  `\n).\nparams((u) =>\nu.combine('type', keysOf(kInvalidTypes)).combine('control', [true, false]).beginSubcases()\n).\nfn((t) => {\n  const type = kInvalidTypes[t.params.type];\n  const expr = t.params.control ? type.control(type.expr) : type.expr;\n  const code = `\n@group(0) @binding(0) var t : texture_2d<f32>;\n@group(0) @binding(1) var s : sampler;\n@group(0) @binding(2) var<storage, read_write> a : atomic<i32>;\n\nstruct S { b : bool }\n\nvar<private> b : bool;\nvar<private> m : mat2x2f;\nvar<private> arr : array<bool, 4>;\nvar<private> str : S;\n\n@compute @workgroup_size(1)\nfn main() {\n  let foo = !${expr};\n}\n`;\n\n  t.expectCompileResult(t.params.control, code);\n});\n\nconst kTests = {\n  not_bool_literal: {\n    src: 'let a = !true;',\n    pass: true\n  },\n  not_bool_expr: {\n    src: `let a = !(1 == 2);`,\n    pass: true\n  },\n  not_not_bool_literal: {\n    src: 'let a = !!true;',\n    pass: true\n  },\n  not_not_bool_expr: {\n    src: `let a = !!(1 == 2);`,\n    pass: true\n  },\n  not_int_literal: {\n    src: `let a = !42;`,\n    pass: false\n  },\n  not_int_expr: {\n    src: `let a = !(40 + 2);`,\n    pass: false\n  }\n};\n\ng.test('parse').\ndesc('Test that unary operators are parsed correctly').\nparams((u) => u.combine('stmt', keysOf(kTests))).\nfn((t) => {\n  const code = `\n@vertex\nfn vtx() -> @builtin(position) vec4f {\n  ${kTests[t.params.stmt].src}\n  return vec4f(1);\n}\n    `;\n  t.expectCompileResult(kTests[t.params.stmt].pass, code);\n});"],"mappings":"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","ignoreList":[]}