{"version":3,"file":"early_evaluation.spec.js","names":["description","makeTestGroup","keysOf","ShaderValidationTest","g","kCompositeCases","const_scalar","code","stage","valid","const_vector","const_let_vector","const_let_vector_comp","const_let_array_comp","const_let_struct_comp","const_let_matrix","const_let_matrix_vec","const_let_matrix_comp","override_scalar","override_vector","override_let_vector","override_let_vector_comp","override_let_array_comp","override_let_struct_comp","override_let_matrix","override_let_matrix_vec","override_let_matrix_comp","test","desc","params","u","combine","fn","t","case","wgsl","expectCompileResult","constants","expectPipelineResult","expectedResult","reference"],"sources":["../../../../../src/webgpu/shader/validation/expression/early_evaluation.spec.ts"],"sourcesContent":["/**\n* AUTO-GENERATED - DO NOT EDIT. Source: https://github.com/gpuweb/cts\n**/export const description = `\nTests specific validation for early evaluation expressions\n`;import { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { keysOf } from '../../../../common/util/data_tables.js';\nimport { ShaderValidationTest } from '../shader_validation_test.js';\n\nexport const g = makeTestGroup(ShaderValidationTest);\n\n\n\n\n\n\n\nconst kCompositeCases = {\n  const_scalar: {\n    code: `let tmp = const_1e30 * const_1e30;`,\n    stage: 'constant',\n    valid: false\n  },\n  const_vector: {\n    code: `let tmp = vec4(const_1e30) * vec4(const_1e30);`,\n    stage: 'constant',\n    valid: false\n  },\n  const_let_vector: {\n    code: `let tmp = vec4(const_1e30) * vec4(vec3(const_1e30), let_1e30);`,\n    stage: 'constant',\n    valid: true\n  },\n  const_let_vector_comp: {\n    code: `let tmp = vec2(const_1e30)[0] * vec2(const_1e30, let_1e30)[0];`,\n    stage: 'constant',\n    valid: true\n  },\n  const_let_array_comp: {\n    code: `let tmp = array(const_1e30, const_1e30)[0] * array(const_1e30, let_1e30)[0];`,\n    stage: 'constant',\n    valid: true\n  },\n  const_let_struct_comp: {\n    code: `let tmp = S(const_1e30, const_1e30).x * S(const_1e30, let_1e30).x;`,\n    stage: 'constant',\n    valid: true\n  },\n  const_let_matrix: {\n    code: `let tmp = mat2x2(vec2(const_1e30), vec2(const_1e30)) * mat2x2(vec2(const_1e30), vec2(let_1e30));`,\n    stage: 'constant',\n    valid: true\n  },\n  const_let_matrix_vec: {\n    code: `let tmp = mat2x2(vec2(const_1e30), vec2(const_1e30))[0] * mat2x2(vec2(const_1e30), vec2(let_1e30))[0];`,\n    stage: 'constant',\n    valid: true\n  },\n  const_let_matrix_comp: {\n    code: `let tmp = mat2x2(vec2(const_1e30), vec2(const_1e30))[0].x * mat2x2(vec2(const_1e30), vec2(let_1e30))[0].x;`,\n    stage: 'constant',\n    valid: true\n  },\n  override_scalar: {\n    code: `let tmp = override_1e30 * override_1e30;`,\n    stage: 'override',\n    valid: false\n  },\n  override_vector: {\n    code: `let tmp = vec4(override_1e30) * vec4(override_1e30);`,\n    stage: 'override',\n    valid: false\n  },\n  override_let_vector: {\n    code: `let tmp = vec4(override_1e30) * vec4(vec3(override_1e30), let_1e30);`,\n    stage: 'override',\n    valid: true\n  },\n  override_let_vector_comp: {\n    code: `let tmp = vec2(override_1e30)[0] * vec2(override_1e30, let_1e30)[0];`,\n    stage: 'override',\n    valid: true\n  },\n  override_let_array_comp: {\n    code: `let tmp = array(override_1e30, override_1e30)[0] * array(override_1e30, let_1e30)[0];`,\n    stage: 'override',\n    valid: true\n  },\n  override_let_struct_comp: {\n    code: `let tmp = S(override_1e30, override_1e30).x * S(override_1e30, let_1e30).x;`,\n    stage: 'override',\n    valid: true\n  },\n  override_let_matrix: {\n    code: `let tmp = mat2x2(vec2(override_1e30), vec2(override_1e30)) * mat2x2(vec2(override_1e30), vec2(let_1e30));`,\n    stage: 'override',\n    valid: true\n  },\n  override_let_matrix_vec: {\n    code: `let tmp = mat2x2(vec2(override_1e30), vec2(override_1e30))[0] * mat2x2(vec2(override_1e30), vec2(let_1e30))[0];`,\n    stage: 'override',\n    valid: true\n  },\n  override_let_matrix_comp: {\n    code: `let tmp = mat2x2(vec2(override_1e30), vec2(override_1e30))[0].x * mat2x2(vec2(override_1e30), vec2(let_1e30))[0].x;`,\n    stage: 'override',\n    valid: true\n  }\n};\n\ng.test('composites').\ndesc('Validates that composites are either wholly evaluated or not at all').\nparams((u) => u.combine('case', keysOf(kCompositeCases))).\nfn((t) => {\n  const { code, stage, valid } = kCompositeCases[t.params.case];\n  const wgsl = `\nstruct S {\n  x : f32,\n  y : f32,\n}\nconst const_1e30 = f32(1e30);\noverride override_1e30 : f32;\nfn foo() -> u32 {\n  let let_1e30 = f32(1e30);\n  ${code}\n  return 0;\n}`;\n\n  if (stage === 'constant') {\n    t.expectCompileResult(valid, wgsl);\n  } else {\n    const constants = {};\n    constants['override_1e30'] = 1e30;\n    t.expectPipelineResult({\n      expectedResult: valid,\n      code: wgsl,\n      constants,\n      reference: ['override_1e30', 'foo()']\n    });\n  }\n});"],"mappings":";;IAAA;AACA;AACA,GAAG,OAAO,MAAMA,WAAW,GAAG;AAC9B;AACA,CAAC,CAAC,SAASC,aAAa,QAAQ,4CAA4C,CAC5E,SAASC,MAAM,QAAQ,wCAAwC,CAC/D,SAASC,oBAAoB,QAAQ,8BAA8B;;AAEnE,OAAO,MAAMC,CAAC,GAAGH,aAAa,CAACE,oBAAoB,CAAC;;;;;;;;AAQpD,MAAME,eAAe,GAAG;EACtBC,YAAY,EAAE;IACZC,IAAI,EAAE,oCAAoC;IAC1CC,KAAK,EAAE,UAAU;IACjBC,KAAK,EAAE;EACT,CAAC;EACDC,YAAY,EAAE;IACZH,IAAI,EAAE,gDAAgD;IACtDC,KAAK,EAAE,UAAU;IACjBC,KAAK,EAAE;EACT,CAAC;EACDE,gBAAgB,EAAE;IAChBJ,IAAI,EAAE,gEAAgE;IACtEC,KAAK,EAAE,UAAU;IACjBC,KAAK,EAAE;EACT,CAAC;EACDG,qBAAqB,EAAE;IACrBL,IAAI,EAAE,gEAAgE;IACtEC,KAAK,EAAE,UAAU;IACjBC,KAAK,EAAE;EACT,CAAC;EACDI,oBAAoB,EAAE;IACpBN,IAAI,EAAE,8EAA8E;IACpFC,KAAK,EAAE,UAAU;IACjBC,KAAK,EAAE;EACT,CAAC;EACDK,qBAAqB,EAAE;IACrBP,IAAI,EAAE,oEAAoE;IAC1EC,KAAK,EAAE,UAAU;IACjBC,KAAK,EAAE;EACT,CAAC;EACDM,gBAAgB,EAAE;IAChBR,IAAI,EAAE,kGAAkG;IACxGC,KAAK,EAAE,UAAU;IACjBC,KAAK,EAAE;EACT,CAAC;EACDO,oBAAoB,EAAE;IACpBT,IAAI,EAAE,wGAAwG;IAC9GC,KAAK,EAAE,UAAU;IACjBC,KAAK,EAAE;EACT,CAAC;EACDQ,qBAAqB,EAAE;IACrBV,IAAI,EAAE,4GAA4G;IAClHC,KAAK,EAAE,UAAU;IACjBC,KAAK,EAAE;EACT,CAAC;EACDS,eAAe,EAAE;IACfX,IAAI,EAAE,0CAA0C;IAChDC,KAAK,EAAE,UAAU;IACjBC,KAAK,EAAE;EACT,CAAC;EACDU,eAAe,EAAE;IACfZ,IAAI,EAAE,sDAAsD;IAC5DC,KAAK,EAAE,UAAU;IACjBC,KAAK,EAAE;EACT,CAAC;EACDW,mBAAmB,EAAE;IACnBb,IAAI,EAAE,sEAAsE;IAC5EC,KAAK,EAAE,UAAU;IACjBC,KAAK,EAAE;EACT,CAAC;EACDY,wBAAwB,EAAE;IACxBd,IAAI,EAAE,sEAAsE;IAC5EC,KAAK,EAAE,UAAU;IACjBC,KAAK,EAAE;EACT,CAAC;EACDa,uBAAuB,EAAE;IACvBf,IAAI,EAAE,uFAAuF;IAC7FC,KAAK,EAAE,UAAU;IACjBC,KAAK,EAAE;EACT,CAAC;EACDc,wBAAwB,EAAE;IACxBhB,IAAI,EAAE,6EAA6E;IACnFC,KAAK,EAAE,UAAU;IACjBC,KAAK,EAAE;EACT,CAAC;EACDe,mBAAmB,EAAE;IACnBjB,IAAI,EAAE,2GAA2G;IACjHC,KAAK,EAAE,UAAU;IACjBC,KAAK,EAAE;EACT,CAAC;EACDgB,uBAAuB,EAAE;IACvBlB,IAAI,EAAE,iHAAiH;IACvHC,KAAK,EAAE,UAAU;IACjBC,KAAK,EAAE;EACT,CAAC;EACDiB,wBAAwB,EAAE;IACxBnB,IAAI,EAAE,qHAAqH;IAC3HC,KAAK,EAAE,UAAU;IACjBC,KAAK,EAAE;EACT;AACF,CAAC;;AAEDL,CAAC,CAACuB,IAAI,CAAC,YAAY,CAAC;AACpBC,IAAI,CAAC,qEAAqE,CAAC;AAC3EC,MAAM,CAAC,CAACC,CAAC,KAAKA,CAAC,CAACC,OAAO,CAAC,MAAM,EAAE7B,MAAM,CAACG,eAAe,CAAC,CAAC,CAAC;AACzD2B,EAAE,CAAC,CAACC,CAAC,KAAK;EACR,MAAM,EAAE1B,IAAI,EAAEC,KAAK,EAAEC,KAAK,CAAC,CAAC,GAAGJ,eAAe,CAAC4B,CAAC,CAACJ,MAAM,CAACK,IAAI,CAAC;EAC7D,MAAMC,IAAI,GAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI5B,IAAI;AACR;AACA,EAAE;;EAEA,IAAIC,KAAK,KAAK,UAAU,EAAE;IACxByB,CAAC,CAACG,mBAAmB,CAAC3B,KAAK,EAAE0B,IAAI,CAAC;EACpC,CAAC,MAAM;IACL,MAAME,SAAS,GAAG,CAAC,CAAC;IACpBA,SAAS,CAAC,eAAe,CAAC,GAAG,IAAI;IACjCJ,CAAC,CAACK,oBAAoB,CAAC;MACrBC,cAAc,EAAE9B,KAAK;MACrBF,IAAI,EAAE4B,IAAI;MACVE,SAAS;MACTG,SAAS,EAAE,CAAC,eAAe,EAAE,OAAO;IACtC,CAAC,CAAC;EACJ;AACF,CAAC,CAAC","ignoreList":[]}