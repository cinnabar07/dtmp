{"version":3,"file":"const_assert.spec.js","names":["description","makeTestGroup","keysOf","ShaderValidationTest","g","buildStaticAssert","expr","scope","stmt","kConditionCases","any_false","val","any_true","binary_op_eq_const_false","binary_op_eq_const_true","const_eq_literal_float_false","const_eq_literal_float_true","const_eq_literal_int_false","const_eq_literal_int_true","literal_false","literal_not_false","literal_not_true","literal_true","min_max_false","min_max_true","variable_false","variable_not_false","variable_not_true","variable_true","kConditionConstants","test","desc","params","u","combine","beginSubcases","fn","t","case","expectCompileResult","lhs","rhs","staticAssert","stage"],"sources":["../../../../../src/webgpu/shader/validation/const_assert/const_assert.spec.ts"],"sourcesContent":["/**\n* AUTO-GENERATED - DO NOT EDIT. Source: https://github.com/gpuweb/cts\n**/export const description = `Validation tests for const_assert`;import { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { keysOf } from '../../../../common/util/data_tables.js';\nimport { ShaderValidationTest } from '../shader_validation_test.js';\n\nexport const g = makeTestGroup(ShaderValidationTest);\n\n/**\n * Builds a const_assert() statement.\n * @param expr the constant expression\n * @param scope module-scope or function-scope constant expression\n * @returns the WGSL code\n */\nfunction buildStaticAssert(expr, scope) {\n  const stmt = `const_assert (${expr});`;\n  return scope === 'module' ? stmt : `fn f() { ${stmt} }`;\n}\n\n\n\n\n\n\n\n\n\n\nconst kConditionCases = {\n  any_false: { expr: `any(vec3(false, false, false))`, val: false },\n  any_true: { expr: `any(vec3(false, true, false))`, val: true },\n  binary_op_eq_const_false: { expr: `one + 5 == two`, val: false },\n  binary_op_eq_const_true: { expr: `one + 1 == two`, val: true },\n  const_eq_literal_float_false: { expr: `one == 0.0`, val: false },\n  const_eq_literal_float_true: { expr: `one == 1.0`, val: true },\n  const_eq_literal_int_false: { expr: `one == 10`, val: false },\n  const_eq_literal_int_true: { expr: `one == 1`, val: true },\n  literal_false: { expr: `false`, val: false },\n  literal_not_false: { expr: `!false`, val: true },\n  literal_not_true: { expr: `!true`, val: false },\n  literal_true: { expr: `true`, val: true },\n  min_max_false: { expr: `min(three, max(two, one)) == 3`, val: false },\n  min_max_true: { expr: `min(three, max(two, one)) == 2`, val: true },\n  variable_false: { expr: `is_false`, val: false },\n  variable_not_false: { expr: `!is_false`, val: true },\n  variable_not_true: { expr: `!is_true`, val: false },\n  variable_true: { expr: `is_true`, val: true }\n};\n\nconst kConditionConstants = `\nconst one = 1;\nconst two = 2;\nconst three = 3;\nconst is_true = true;\nconst is_false = false;\n`;\n\ng.test('constant_expression_no_assert').\ndesc(`Test that const_assert does not assert on a true conditional expression`).\nparams((u) =>\nu.\ncombine('scope', ['module', 'function']).\nbeginSubcases().\ncombine('case', keysOf(kConditionCases))\n).\nfn((t) => {\n  const expr = kConditionCases[t.params.case].expr;\n  const val = kConditionCases[t.params.case].val;\n  t.expectCompileResult(\n    true,\n    kConditionConstants + buildStaticAssert(val ? expr : `!(${expr})`, t.params.scope)\n  );\n});\n\ng.test('constant_expression_assert').\ndesc(`Test that const_assert does assert on a false conditional expression`).\nparams((u) =>\nu.\ncombine('scope', ['module', 'function']).\nbeginSubcases().\ncombine('case', keysOf(kConditionCases))\n).\nfn((t) => {\n  const expr = kConditionCases[t.params.case].expr;\n  const val = kConditionCases[t.params.case].val;\n  t.expectCompileResult(\n    false,\n    kConditionConstants + buildStaticAssert(val ? `!(${expr})` : expr, t.params.scope)\n  );\n});\n\ng.test('constant_expression_logical_or_no_assert').\ndesc(\n  `Test that const_assert does not assert on a condition expression that contains a logical-or which evaluates to true`\n).\nparams((u) =>\nu.\ncombine('scope', ['module', 'function']).\nbeginSubcases().\ncombine('lhs', keysOf(kConditionCases)).\ncombine('rhs', keysOf(kConditionCases))\n).\nfn((t) => {\n  const expr = `(${kConditionCases[t.params.lhs].expr}) || (${\n  kConditionCases[t.params.rhs].expr})`;\n\n  const val = kConditionCases[t.params.lhs].val || kConditionCases[t.params.rhs].val;\n  t.expectCompileResult(\n    true,\n    kConditionConstants + buildStaticAssert(val ? expr : `!(${expr})`, t.params.scope)\n  );\n});\n\ng.test('constant_expression_logical_or_assert').\ndesc(\n  `Test that const_assert does assert on a condition expression that contains a logical-or which evaluates to false`\n).\nparams((u) =>\nu.\ncombine('scope', ['module', 'function']).\nbeginSubcases().\ncombine('lhs', keysOf(kConditionCases)).\ncombine('rhs', keysOf(kConditionCases))\n).\nfn((t) => {\n  const expr = `(${kConditionCases[t.params.lhs].expr}) || (${\n  kConditionCases[t.params.rhs].expr})`;\n\n  const val = kConditionCases[t.params.lhs].val || kConditionCases[t.params.rhs].val;\n  t.expectCompileResult(\n    false,\n    kConditionConstants + buildStaticAssert(val ? `!(${expr})` : expr, t.params.scope)\n  );\n});\n\ng.test('constant_expression_logical_and_no_assert').\ndesc(\n  `Test that const_assert does not assert on a condition expression that contains a logical-and which evaluates to true`\n).\nparams((u) =>\nu.\ncombine('scope', ['module', 'function']).\nbeginSubcases().\ncombine('lhs', keysOf(kConditionCases)).\ncombine('rhs', keysOf(kConditionCases))\n).\nfn((t) => {\n  const expr = `(${kConditionCases[t.params.lhs].expr}) && (${\n  kConditionCases[t.params.rhs].expr})`;\n\n  const val = kConditionCases[t.params.lhs].val && kConditionCases[t.params.rhs].val;\n  t.expectCompileResult(\n    true,\n    kConditionConstants + buildStaticAssert(val ? expr : `!(${expr})`, t.params.scope)\n  );\n});\n\ng.test('constant_expression_logical_and_assert').\ndesc(\n  `Test that const_assert does assert on a condition expression that contains a logical-and which evaluates to false`\n).\nparams((u) =>\nu.\ncombine('scope', ['module', 'function']).\nbeginSubcases().\ncombine('lhs', keysOf(kConditionCases)).\ncombine('rhs', keysOf(kConditionCases))\n).\nfn((t) => {\n  const expr = `(${kConditionCases[t.params.lhs].expr}) && (${\n  kConditionCases[t.params.rhs].expr})`;\n\n  const val = kConditionCases[t.params.lhs].val && kConditionCases[t.params.rhs].val;\n  t.expectCompileResult(\n    false,\n    kConditionConstants + buildStaticAssert(val ? `!(${expr})` : expr, t.params.scope)\n  );\n});\n\ng.test('evaluation_stage').\ndesc(`Test that the const_assert expression must be a constant expression.`).\nparams((u) =>\nu.\ncombine('scope', ['module', 'function']).\ncombine('stage', ['constant', 'override', 'runtime']).\nbeginSubcases()\n).\nfn((t) => {\n  const staticAssert = buildStaticAssert('value', t.params.scope);\n  switch (t.params.stage) {\n    case 'constant':\n      t.expectCompileResult(true, `const value = true;\\n${staticAssert}`);\n      break;\n    case 'override':\n      t.expectCompileResult(false, `override value = true;\\n${staticAssert}`);\n      break;\n    case 'runtime':\n      t.expectCompileResult(false, `var<private> value = true;\\n${staticAssert}`);\n      break;\n  }\n});"],"mappings":"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","ignoreList":[]}