{"version":3,"file":"alias_analysis.spec.js","names":["description","makeTestGroup","keysOf","ShaderValidationTest","g","kUses","no_access","is_write","gen","ref","assign","compound_assign_lhs","compound_assign_rhs","increment","binary_lhs","binary_rhs","unary_minus","bitcast","convert","builtin_arg","index_access","let_init","var_init","return","switch_cond","shouldPass","aliased","uses","some","u","includes","kWritableAddressSpaces","ptr","addressSpace","type","declareModuleScopeVar","name","binding","maybeDeclareModuleScopeVar","maybeDeclareFunctionScopeVar","requiresUnrestrictedPointerParameters","test","desc","params","combine","beginSubcases","fn","t","address_space","skipIfLanguageFeatureNotSupported","code","a_use","b_use","expectCompileResult","index","member","ptr_i32","ptr_S","deref","ptr_vec","kAtomicBuiltins","isWrite","builtin","callAtomicBuiltin","ptr_atomic_i32","builtin_a","builtin_b","shouldFail","emitUse","use"],"sources":["../../../../../src/webgpu/shader/validation/functions/alias_analysis.spec.ts"],"sourcesContent":["/**\n* AUTO-GENERATED - DO NOT EDIT. Source: https://github.com/gpuweb/cts\n**/export const description = `Validation tests for function alias analysis`;import { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { keysOf } from '../../../../common/util/data_tables.js';\nimport { ShaderValidationTest } from '../shader_validation_test.js';\n\nexport const g = makeTestGroup(ShaderValidationTest);\n\n\n\n\n\n\nconst kUses = {\n  no_access: { is_write: false, gen: (ref) => `{ let p = &*&${ref}; }` },\n  assign: { is_write: true, gen: (ref) => `${ref} = 42;` },\n  compound_assign_lhs: { is_write: true, gen: (ref) => `${ref} += 1;` },\n  compound_assign_rhs: { is_write: false, gen: (ref) => `{ var tmp : i32; tmp += ${ref}; }` },\n  increment: { is_write: true, gen: (ref) => `${ref}++;` },\n  binary_lhs: { is_write: false, gen: (ref) => `_ = ${ref} + 1;` },\n  binary_rhs: { is_write: false, gen: (ref) => `_ = 1 + ${ref};` },\n  unary_minus: { is_write: false, gen: (ref) => `_ = -${ref};` },\n  bitcast: { is_write: false, gen: (ref) => `_ = bitcast<f32>(${ref});` },\n  convert: { is_write: false, gen: (ref) => `_ = f32(${ref});` },\n  builtin_arg: { is_write: false, gen: (ref) => `_ = abs(${ref});` },\n  index_access: { is_write: false, gen: (ref) => `{ var arr : array<i32, 4>; _ = arr[${ref}]; }` },\n  let_init: { is_write: false, gen: (ref) => `{ let tmp = ${ref}; }` },\n  var_init: { is_write: false, gen: (ref) => `{ var tmp = ${ref}; }` },\n  return: { is_write: false, gen: (ref) => `{ return ${ref}; }` },\n  switch_cond: { is_write: false, gen: (ref) => `switch(${ref}) { default { break; } }` }\n};\n\n\n\nfunction shouldPass(aliased, ...uses) {\n  // Expect fail if the pointers are aliased and at least one of the accesses is a write.\n  // If either of the accesses is a \"no access\" then expect pass.\n  return !aliased || !uses.some((u) => kUses[u].is_write) || uses.includes('no_access');\n}\n\n\n\nconst kWritableAddressSpaces = ['private', 'function', 'storage', 'workgroup'];\n\nfunction ptr(addressSpace, type) {\n  switch (addressSpace) {\n    case 'function':\n      return `ptr<function, ${type}>`;\n    case 'private':\n      return `ptr<private, ${type}>`;\n    case 'storage':\n      return `ptr<storage, ${type}, read_write>`;\n    case 'uniform':\n      return `ptr<uniform, ${type}>`;\n    case 'workgroup':\n      return `ptr<workgroup, ${type}>`;\n  }\n}\n\nfunction declareModuleScopeVar(\nname,\naddressSpace,\ntype)\n{\n  const binding = name === 'x' ? 0 : 1;\n  switch (addressSpace) {\n    case 'private':\n      return `var<private> ${name} : ${type};`;\n    case 'storage':\n      return `@binding(${binding}) @group(0) var<storage, read_write> ${name} : ${type};`;\n    case 'uniform':\n      return `@binding(${binding}) @group(0) var<uniform> ${name} : ${type};`;\n    case 'workgroup':\n      return `var<workgroup> ${name} : ${type};`;\n  }\n}\n\nfunction maybeDeclareModuleScopeVar(name, addressSpace, type) {\n  if (addressSpace === 'function') {\n    return '';\n  }\n  return declareModuleScopeVar(name, addressSpace, type);\n}\n\nfunction maybeDeclareFunctionScopeVar(name, addressSpace, type) {\n  switch (addressSpace) {\n    case 'function':\n      return `var ${name} : ${type};`;\n    default:\n      return ``;\n  }\n}\n\n/**\n * @returns true if a pointer of the given address space requires the\n * 'unrestricted_pointer_parameters' language feature.\n */\nfunction requiresUnrestrictedPointerParameters(addressSpace) {\n  return addressSpace !== 'function' && addressSpace !== 'private';\n}\n\ng.test('two_pointers').\ndesc(`Test aliasing of two pointers passed to a function.`).\nparams((u) =>\nu.\ncombine('address_space', kWritableAddressSpaces).\ncombine('aliased', [true, false]).\nbeginSubcases().\ncombine('a_use', keysOf(kUses)).\ncombine('b_use', keysOf(kUses))\n).\nfn((t) => {\n  if (requiresUnrestrictedPointerParameters(t.params.address_space)) {\n    t.skipIfLanguageFeatureNotSupported('unrestricted_pointer_parameters');\n  }\n\n  const code = `\n${maybeDeclareModuleScopeVar('x', t.params.address_space, 'i32')}\n${maybeDeclareModuleScopeVar('y', t.params.address_space, 'i32')}\n\nfn callee(pa : ${ptr(t.params.address_space, 'i32')},\n          pb : ${ptr(t.params.address_space, 'i32')}) -> i32 {\n  ${kUses[t.params.a_use].gen(`*pa`)}\n  ${kUses[t.params.b_use].gen(`*pb`)}\n  return 0;\n}\n\nfn caller() {\n  ${maybeDeclareFunctionScopeVar('x', t.params.address_space, 'i32')}\n  ${maybeDeclareFunctionScopeVar('y', t.params.address_space, 'i32')}\n  callee(&x, ${t.params.aliased ? `&x` : `&y`});\n}\n`;\n  t.expectCompileResult(shouldPass(t.params.aliased, t.params.a_use, t.params.b_use), code);\n});\n\ng.test('two_pointers_to_array_elements').\ndesc(`Test aliasing of two array element pointers passed to a function.`).\nparams((u) =>\nu.\ncombine('address_space', kWritableAddressSpaces).\ncombine('index', [0, 1]).\ncombine('aliased', [true, false]).\nbeginSubcases().\ncombine('a_use', keysOf(kUses)).\ncombine('b_use', keysOf(kUses))\n).\nfn((t) => {\n  t.skipIfLanguageFeatureNotSupported('unrestricted_pointer_parameters');\n\n  const code = `\n${maybeDeclareModuleScopeVar('x', t.params.address_space, 'array<i32, 4>')}\n${maybeDeclareModuleScopeVar('y', t.params.address_space, 'array<i32, 4>')}\n\nfn callee(pa : ${ptr(t.params.address_space, 'i32')},\n          pb : ${ptr(t.params.address_space, 'i32')}) -> i32 {\n  ${kUses[t.params.a_use].gen(`*pa`)}\n  ${kUses[t.params.b_use].gen(`*pb`)}\n  return 0;\n}\n\nfn caller() {\n  ${maybeDeclareFunctionScopeVar('x', t.params.address_space, 'array<i32, 4>')}\n  ${maybeDeclareFunctionScopeVar('y', t.params.address_space, 'array<i32, 4>')}\n  callee(&x[${t.params.index}], ${t.params.aliased ? `&x[0]` : `&y[0]`});\n}\n`;\n  t.expectCompileResult(shouldPass(t.params.aliased, t.params.a_use, t.params.b_use), code);\n});\n\ng.test('two_pointers_to_array_elements_indirect').\ndesc(\n  `Test aliasing of two array pointers passed to a function, which indexes those arrays and then\npasses the element pointers to another function.`\n).\nparams((u) =>\nu.\ncombine('address_space', kWritableAddressSpaces).\ncombine('index', [0, 1]).\ncombine('aliased', [true, false]).\nbeginSubcases().\ncombine('a_use', keysOf(kUses)).\ncombine('b_use', keysOf(kUses))\n).\nfn((t) => {\n  t.skipIfLanguageFeatureNotSupported('unrestricted_pointer_parameters');\n\n  const code = `\n${maybeDeclareModuleScopeVar('x', t.params.address_space, 'array<i32, 4>')}\n${maybeDeclareModuleScopeVar('y', t.params.address_space, 'array<i32, 4>')}\n\nfn callee(pa : ${ptr(t.params.address_space, 'i32')},\n          pb : ${ptr(t.params.address_space, 'i32')}) -> i32 {\n  ${kUses[t.params.a_use].gen(`*pa`)}\n  ${kUses[t.params.b_use].gen(`*pb`)}\n  return 0;\n}\n\nfn index(pa : ${ptr(t.params.address_space, 'array<i32, 4>')},\n         pb : ${ptr(t.params.address_space, 'array<i32, 4>')}) -> i32 {\n  return callee(&(*pa)[${t.params.index}], &(*pb)[0]);\n}\n\nfn caller() {\n  ${maybeDeclareFunctionScopeVar('x', t.params.address_space, 'array<i32, 4>')}\n  ${maybeDeclareFunctionScopeVar('y', t.params.address_space, 'array<i32, 4>')}\n  index(&x, ${t.params.aliased ? `&x` : `&y`});\n}\n`;\n  t.expectCompileResult(shouldPass(t.params.aliased, t.params.a_use, t.params.b_use), code);\n});\n\ng.test('two_pointers_to_struct_members').\ndesc(`Test aliasing of two struct member pointers passed to a function.`).\nparams((u) =>\nu.\ncombine('address_space', kWritableAddressSpaces).\ncombine('member', ['a', 'b']).\ncombine('aliased', [true, false]).\nbeginSubcases().\ncombine('a_use', keysOf(kUses)).\ncombine('b_use', keysOf(kUses))\n).\nfn((t) => {\n  t.skipIfLanguageFeatureNotSupported('unrestricted_pointer_parameters');\n\n  const code = `\nstruct S {\n  a : i32,\n  b : i32,\n}\n\n${maybeDeclareModuleScopeVar('x', t.params.address_space, 'S')}\n${maybeDeclareModuleScopeVar('y', t.params.address_space, 'S')}\n\nfn callee(pa : ${ptr(t.params.address_space, 'i32')},\n          pb : ${ptr(t.params.address_space, 'i32')}) -> i32 {\n  ${kUses[t.params.a_use].gen(`*pa`)}\n  ${kUses[t.params.b_use].gen(`*pb`)}\n  return 0;\n}\n\nfn caller() {\n  ${maybeDeclareFunctionScopeVar('x', t.params.address_space, 'S')}\n  ${maybeDeclareFunctionScopeVar('y', t.params.address_space, 'S')}\n  callee(&x.${t.params.member}, ${t.params.aliased ? `&x.a` : `&y.a`});\n}\n`;\n  t.expectCompileResult(shouldPass(t.params.aliased, t.params.a_use, t.params.b_use), code);\n});\n\ng.test('two_pointers_to_struct_members_indirect').\ndesc(\n  `Test aliasing of two structure pointers passed to a function, which accesses members of those\nstructures and then passes the member pointers to another function.`\n).\nparams((u) =>\nu.\ncombine('address_space', kWritableAddressSpaces).\ncombine('member', ['a', 'b']).\ncombine('aliased', [true, false]).\nbeginSubcases().\ncombine('a_use', keysOf(kUses)).\ncombine('b_use', keysOf(kUses))\n).\nfn((t) => {\n  t.skipIfLanguageFeatureNotSupported('unrestricted_pointer_parameters');\n\n  const code = `\nstruct S {\n  a : i32,\n  b : i32,\n}\n\n${maybeDeclareModuleScopeVar('x', t.params.address_space, 'S')}\n${maybeDeclareModuleScopeVar('y', t.params.address_space, 'S')}\n\nfn callee(pa : ${ptr(t.params.address_space, 'i32')},\n          pb : ${ptr(t.params.address_space, 'i32')}) -> i32 {\n  ${kUses[t.params.a_use].gen(`*pa`)}\n  ${kUses[t.params.b_use].gen(`*pb`)}\n  return 0;\n}\n\nfn access(pa : ${ptr(t.params.address_space, 'S')},\n          pb : ${ptr(t.params.address_space, 'S')}) -> i32 {\n  return callee(&(*pa).${t.params.member}, &(*pb).a);\n}\n\nfn caller() {\n  ${maybeDeclareFunctionScopeVar('x', t.params.address_space, 'S')}\n  ${maybeDeclareFunctionScopeVar('y', t.params.address_space, 'S')}\n  access(&x, ${t.params.aliased ? `&x` : `&y`});\n}\n`;\n  t.expectCompileResult(shouldPass(t.params.aliased, t.params.a_use, t.params.b_use), code);\n});\n\ng.test('one_pointer_one_module_scope').\ndesc(`Test aliasing of a pointer with a direct access to a module-scope variable.`).\nparams((u) =>\nu.\ncombine('address_space', ['private', 'storage', 'workgroup']).\ncombine('aliased', [true, false]).\nbeginSubcases().\ncombine('a_use', keysOf(kUses)).\ncombine('b_use', keysOf(kUses))\n).\nfn((t) => {\n  if (requiresUnrestrictedPointerParameters(t.params.address_space)) {\n    t.skipIfLanguageFeatureNotSupported('unrestricted_pointer_parameters');\n  }\n\n  const code = `\n${declareModuleScopeVar('x', t.params.address_space, 'i32')}\n${declareModuleScopeVar('y', t.params.address_space, 'i32')}\n\nfn callee(pb : ${ptr(t.params.address_space, 'i32')}) -> i32 {\n  ${kUses[t.params.a_use].gen(`x`)}\n  ${kUses[t.params.b_use].gen(`*pb`)}\n  return 0;\n}\n\nfn caller() {\n  callee(${t.params.aliased ? `&x` : `&y`});\n}\n`;\n  t.expectCompileResult(shouldPass(t.params.aliased, t.params.a_use, t.params.b_use), code);\n});\n\ng.test('subcalls').\ndesc(`Test aliasing of two pointers passed to a function, and then passed to other functions.`).\nparams((u) =>\nu.\ncombine('address_space', ['private', 'storage', 'workgroup']).\ncombine('aliased', [true, false]).\nbeginSubcases().\ncombine('a_use', ['no_access', 'assign', 'binary_lhs']).\ncombine('b_use', ['no_access', 'assign', 'binary_lhs'])\n).\nfn((t) => {\n  if (requiresUnrestrictedPointerParameters(t.params.address_space)) {\n    t.skipIfLanguageFeatureNotSupported('unrestricted_pointer_parameters');\n  }\n  const ptr_i32 = ptr(t.params.address_space, 'i32');\n  const code = `\n${declareModuleScopeVar('x', t.params.address_space, 'i32')}\n${declareModuleScopeVar('y', t.params.address_space, 'i32')}\n\nfn subcall_no_access(p : ${ptr_i32}) {\n  let pp = &*p;\n}\n\nfn subcall_binary_lhs(p : ${ptr_i32}) -> i32 {\n  return *p + 1;\n}\n\nfn subcall_assign(p : ${ptr_i32}) {\n  *p = 42;\n}\n\nfn callee(pa : ${ptr_i32}, pb : ${ptr_i32}) -> i32 {\n  let new_pa = &*pa;\n  let new_pb = &*pb;\n  subcall_${t.params.a_use}(new_pa);\n  subcall_${t.params.b_use}(new_pb);\n  return 0;\n}\n\nfn caller() {\n  callee(&x, ${t.params.aliased ? `&x` : `&y`});\n}\n`;\n  t.expectCompileResult(shouldPass(t.params.aliased, t.params.a_use, t.params.b_use), code);\n});\n\ng.test('member_accessors').\ndesc(`Test aliasing of two pointers passed to a function and used with member accessors.`).\nparams((u) =>\nu.\ncombine('address_space', ['private', 'storage', 'workgroup']).\ncombine('aliased', [true, false]).\nbeginSubcases().\ncombine('a_use', ['no_access', 'assign', 'binary_lhs']).\ncombine('b_use', ['no_access', 'assign', 'binary_lhs'])\n).\nfn((t) => {\n  if (requiresUnrestrictedPointerParameters(t.params.address_space)) {\n    t.skipIfLanguageFeatureNotSupported('unrestricted_pointer_parameters');\n  }\n\n  const ptr_S = ptr(t.params.address_space, 'S');\n  const code = `\nstruct S { a : i32 }\n\n${declareModuleScopeVar('x', t.params.address_space, 'S')}\n${declareModuleScopeVar('y', t.params.address_space, 'S')}\n\nfn callee(pa : ${ptr_S}, pb : ${ptr_S}) -> i32 {\n  ${kUses[t.params.a_use].gen(`(*pa).a`)}\n  ${kUses[t.params.b_use].gen(`(*pb).a`)}\n  return 0;\n}\n\nfn caller() {\n  callee(&x, ${t.params.aliased ? `&x` : `&y`});\n}\n`;\n  t.expectCompileResult(shouldPass(t.params.aliased, t.params.a_use, t.params.b_use), code);\n});\n\ng.test('swizzles').\ndesc(`Test aliasing of two pointers passed to a function and used with swizzles.`).\nparams((u) =>\nu.\ncombine('address_space', ['private', 'storage', 'workgroup']).\ncombine('aliased', [true, false]).\nbeginSubcases().\ncombine('a_use', ['no_access', 'compound_assign_lhs']).\ncombine('deref', [true, false])\n).\nfn((t) => {\n  if (requiresUnrestrictedPointerParameters(t.params.address_space)) {\n    t.skipIfLanguageFeatureNotSupported('unrestricted_pointer_parameters');\n  }\n  if (t.params.deref === false) {\n    t.skipIfLanguageFeatureNotSupported('pointer_composite_access');\n  }\n\n  const ptr_vec = ptr(t.params.address_space, 'vec4i');\n  const code = `\n${declareModuleScopeVar('x', t.params.address_space, 'vec4i')}\n${declareModuleScopeVar('y', t.params.address_space, 'vec4i')}\n\nfn callee(pa : ${ptr_vec}, pb : ${ptr_vec}) -> i32 {\n  ${kUses[t.params.a_use].gen(`(*pa)`)}\n  let value = ${t.params.deref ? `(*pb)` : `pb`}.wzyx;\n  return 0;\n}\n\nfn caller() {\n  callee(&x, ${t.params.aliased ? `&x` : `&y`});\n}\n`;\n  t.expectCompileResult(shouldPass(t.params.aliased, t.params.a_use, 'let_init'), code);\n});\n\ng.test('same_pointer_read_and_write').\ndesc(`Test that we can read from and write to the same pointer.`).\nparams((u) =>\nu.combine('address_space', ['private', 'storage', 'workgroup']).beginSubcases()\n).\nfn((t) => {\n  if (requiresUnrestrictedPointerParameters(t.params.address_space)) {\n    t.skipIfLanguageFeatureNotSupported('unrestricted_pointer_parameters');\n  }\n\n  const code = `\n${declareModuleScopeVar('v', t.params.address_space, 'i32')}\n\nfn callee(p : ${ptr(t.params.address_space, 'i32')}) {\n  *p = *p + 1;\n}\n\nfn caller() {\n  callee(&v);\n}\n`;\n  t.expectCompileResult(true, code);\n});\n\ng.test('aliasing_inside_function').\ndesc(`Test that we can alias pointers inside a function.`).\nparams((u) =>\nu.combine('address_space', ['private', 'storage', 'workgroup']).beginSubcases()\n).\nfn((t) => {\n  const code = `\n${declareModuleScopeVar('v', t.params.address_space, 'i32')}\n\nfn foo() {\n  var v : i32;\n  let p1 = &v;\n  let p2 = &v;\n  *p1 = 42;\n  *p2 = 42;\n}\n`;\n  t.expectCompileResult(true, code);\n});\n\nconst kAtomicBuiltins = [\n'atomicLoad',\n'atomicStore',\n'atomicAdd',\n'atomicSub',\n'atomicMax',\n'atomicMin',\n'atomicAnd',\n'atomicOr',\n'atomicXor',\n'atomicExchange',\n'atomicCompareExchangeWeak'];\n\n\n\n\nfunction isWrite(builtin) {\n  switch (builtin) {\n    case 'atomicLoad':\n      return false;\n    case 'atomicAdd':\n    case 'atomicSub':\n    case 'atomicMax':\n    case 'atomicMin':\n    case 'atomicAnd':\n    case 'atomicOr':\n    case 'atomicXor':\n    case 'atomicExchange':\n    case 'atomicCompareExchangeWeak':\n    case 'atomicStore':\n      return true;\n  }\n}\n\nfunction callAtomicBuiltin(builtin, ptr) {\n  switch (builtin) {\n    case 'atomicLoad':\n      return `i += ${builtin}(${ptr})`;\n    case 'atomicStore':\n      return `${builtin}(${ptr}, 42)`;\n    case 'atomicAdd':\n    case 'atomicSub':\n    case 'atomicMax':\n    case 'atomicMin':\n    case 'atomicAnd':\n    case 'atomicOr':\n    case 'atomicXor':\n    case 'atomicExchange':\n      return `i += ${builtin}(${ptr}, 42)`;\n    case 'atomicCompareExchangeWeak':\n      return `${builtin}(${ptr}, 10, 42)`;\n  }\n}\n\ng.test('two_atomic_pointers').\ndesc(`Test aliasing of two atomic pointers passed to a function.`).\nparams((u) =>\nu.\ncombine('builtin_a', kAtomicBuiltins).\ncombine('builtin_b', ['atomicLoad', 'atomicStore']).\ncombine('address_space', ['storage', 'workgroup']).\ncombine('aliased', [true, false]).\nbeginSubcases()\n).\nfn((t) => {\n  t.skipIfLanguageFeatureNotSupported('unrestricted_pointer_parameters');\n\n  const ptr_atomic_i32 = ptr(t.params.address_space, 'atomic<i32>');\n  const code = `\n${declareModuleScopeVar('x', t.params.address_space, 'atomic<i32>')}\n${declareModuleScopeVar('y', t.params.address_space, 'atomic<i32>')}\n\nfn callee(pa : ${ptr_atomic_i32}, pb : ${ptr_atomic_i32}) {\n  var i : i32;\n  ${callAtomicBuiltin(t.params.builtin_a, 'pa')};\n  ${callAtomicBuiltin(t.params.builtin_b, 'pb')};\n}\n\nfn caller() {\n  callee(&x, &${t.params.aliased ? 'x' : 'y'});\n}\n`;\n  const shouldFail =\n  t.params.aliased && (isWrite(t.params.builtin_a) || isWrite(t.params.builtin_b));\n  t.expectCompileResult(!shouldFail, code);\n});\n\ng.test('two_atomic_pointers_to_array_elements').\ndesc(`Test aliasing of two atomic array element pointers passed to a function.`).\nparams((u) =>\nu.\ncombine('builtin_a', kAtomicBuiltins).\ncombine('builtin_b', ['atomicLoad', 'atomicStore']).\ncombine('address_space', ['storage', 'workgroup']).\ncombine('index', [0, 1]).\ncombine('aliased', [true, false]).\nbeginSubcases()\n).\nfn((t) => {\n  t.skipIfLanguageFeatureNotSupported('unrestricted_pointer_parameters');\n\n  const ptr_atomic_i32 = ptr(t.params.address_space, 'atomic<i32>');\n  const code = `\n${declareModuleScopeVar('x', t.params.address_space, 'array<atomic<i32>, 32>')}\n${declareModuleScopeVar('y', t.params.address_space, 'array<atomic<i32>, 32>')}\n\nfn callee(pa : ${ptr_atomic_i32}, pb : ${ptr_atomic_i32}) {\n  var i : i32;\n  ${callAtomicBuiltin(t.params.builtin_a, 'pa')};\n  ${callAtomicBuiltin(t.params.builtin_b, 'pb')};\n}\n\nfn caller() {\n  callee(&x[${t.params.index}], &${t.params.aliased ? 'x' : 'y'}[0]);\n}\n`;\n  const shouldFail =\n  t.params.aliased && (isWrite(t.params.builtin_a) || isWrite(t.params.builtin_b));\n  t.expectCompileResult(!shouldFail, code);\n});\n\ng.test('two_atomic_pointers_to_struct_members').\ndesc(`Test aliasing of two struct member atomic pointers passed to a function.`).\nparams((u) =>\nu.\ncombine('builtin_a', kAtomicBuiltins).\ncombine('builtin_b', ['atomicLoad', 'atomicStore']).\ncombine('address_space', ['storage', 'workgroup']).\ncombine('member', ['a', 'b']).\ncombine('aliased', [true, false]).\nbeginSubcases()\n).\nfn((t) => {\n  t.skipIfLanguageFeatureNotSupported('unrestricted_pointer_parameters');\n\n  const ptr_atomic_i32 = ptr(t.params.address_space, 'atomic<i32>');\n  const code = `\nstruct S {\n  a : atomic<i32>,\n  b : atomic<i32>,\n}\n\n${declareModuleScopeVar('x', t.params.address_space, 'S')}\n${declareModuleScopeVar('y', t.params.address_space, 'S')}\n\nfn callee(pa : ${ptr_atomic_i32}, pb : ${ptr_atomic_i32}) {\n  var i : i32;\n  ${callAtomicBuiltin(t.params.builtin_a, 'pa')};\n  ${callAtomicBuiltin(t.params.builtin_b, 'pb')};\n}\n\nfn caller() {\n  callee(&x.${t.params.member}, &${t.params.aliased ? 'x' : 'y'}.a);\n}\n`;\n  const shouldFail =\n  t.params.aliased && (isWrite(t.params.builtin_a) || isWrite(t.params.builtin_b));\n  t.expectCompileResult(!shouldFail, code);\n});\n\ng.test('one_atomic_pointer_one_module_scope').\ndesc(`Test aliasing of an atomic pointer with a direct access to a module-scope variable.`).\nparams((u) =>\nu.\ncombine('builtin_a', kAtomicBuiltins).\ncombine('builtin_b', ['atomicLoad', 'atomicStore']).\ncombine('address_space', ['storage', 'workgroup']).\ncombine('aliased', [true, false]).\nbeginSubcases()\n).\nfn((t) => {\n  t.skipIfLanguageFeatureNotSupported('unrestricted_pointer_parameters');\n\n  const ptr_atomic_i32 = ptr(t.params.address_space, 'atomic<i32>');\n  const code = `\n${declareModuleScopeVar('x', t.params.address_space, 'atomic<i32>')}\n${declareModuleScopeVar('y', t.params.address_space, 'atomic<i32>')}\n\nfn callee(p : ${ptr_atomic_i32}) {\n  var i : i32;\n  ${callAtomicBuiltin(t.params.builtin_a, 'p')};\n  ${callAtomicBuiltin(t.params.builtin_b, t.params.aliased ? '&x' : '&y')};\n}\n\nfn caller() {\n  callee(&x);\n}\n`;\n  const shouldFail =\n  t.params.aliased && (isWrite(t.params.builtin_a) || isWrite(t.params.builtin_b));\n  t.expectCompileResult(!shouldFail, code);\n});\n\ng.test('workgroup_uniform_load').\ndesc(`Test aliasing via workgroupUniformLoad.`).\nparams((u) =>\nu.\ncombine('use', ['load', 'store', 'workgroupUniformLoad']).\ncombine('aliased', [true, false]).\nbeginSubcases()\n).\nfn((t) => {\n  t.skipIfLanguageFeatureNotSupported('unrestricted_pointer_parameters');\n\n  function emitUse() {\n    switch (t.params.use) {\n      case 'load':\n        return `v = *pa`;\n      case 'store':\n        return `*pa = 1`;\n      case 'workgroupUniformLoad':\n        return `v = workgroupUniformLoad(pa)`;\n    }\n  }\n\n  const code = `\nvar<workgroup> x : i32;\nvar<workgroup> y : i32;\n\nfn callee(pa : ptr<workgroup, i32>, pb : ptr<workgroup, i32>) -> i32 {\n  var v : i32;\n  ${emitUse()};\n  return v + workgroupUniformLoad(pb);\n}\n\nfn caller() {\n  callee(&x, &${t.params.aliased ? 'x' : 'y'});\n}\n`;\n  const shouldFail = t.params.aliased && t.params.use === 'store';\n  t.expectCompileResult(!shouldFail, code);\n});"],"mappings":"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","ignoreList":[]}