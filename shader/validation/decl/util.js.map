{"version":3,"file":"util.js","names":["kAccessModeInfo","kAddressSpaceInfo","kShaderStages","declareEntryPoint","arg","name","undefined","stage","body","declareVarX","addressSpace","accessMode","parts","binding","push","template_parts","length","join","explicitSpaceExpander","p","info","spell","accessModeExpander","explicitAccess","spellAccessMode","accessModes","getVarDeclShader","additionalBody","decl","explicitSpace","scope","pointerType","space","modePart","ptrStoreType","effectiveAccessMode","supportsRead","mode","includes","read","supportsWrite","write"],"sources":["../../../../../src/webgpu/shader/validation/decl/util.ts"],"sourcesContent":["/**\n* AUTO-GENERATED - DO NOT EDIT. Source: https://github.com/gpuweb/cts\n**/import {\n\n  kAccessModeInfo,\n  kAddressSpaceInfo } from\n'../../types.js';\n\n/** An enumerator of shader stages */\n\n\n/** The list of all shader stages */\nexport const kShaderStages = ['vertex', 'fragment', 'compute'];\n\n/**\n * declareEntrypoint emits the WGSL to declare an entry point with the name, stage and body.\n * The generated function will have an appropriate return type and return statement, so that `body`\n * does not have to change between stage.\n * @param arg - arg specifies the\n * optional entry point function name, the shader stage, and the body of the\n * function, excluding any automatically generated return statements.\n * @returns the WGSL string for the entry point\n */\nexport function declareEntryPoint(arg)\n\n\n\n{\n  if (arg.name === undefined) {\n    arg.name = 'main';\n  }\n  switch (arg.stage) {\n    case 'vertex':\n      return `@vertex\nfn ${arg.name}() -> @builtin(position) vec4f {\n  ${arg.body}\n  return vec4f();\n}`;\n    case 'fragment':\n      return `@fragment\nfn ${arg.name}() {\n  ${arg.body}\n}`;\n    case 'compute':\n      return `@compute @workgroup_size(1)\nfn ${arg.name}() {\n  ${arg.body}\n}`;\n  }\n}\n\n/**\n * @returns a WGSL var declaration with given parameters for variable 'x' and\n * store type i32.\n */\nexport function declareVarX(addressSpace, accessMode) {\n  const parts = [];\n  if (addressSpace && kAddressSpaceInfo[addressSpace].binding) parts.push('@group(0) @binding(0) ');\n  parts.push('var');\n\n  const template_parts = [];\n  if (addressSpace) template_parts.push(addressSpace);\n  if (accessMode) template_parts.push(accessMode);\n  if (template_parts.length > 0) parts.push(`<${template_parts.join(',')}>`);\n\n  parts.push(' x: i32;');\n  return parts.join('');\n}\n\n/**\n * @returns a list of booleans indicating valid cases of specifying the address\n * space.\n */\nexport function explicitSpaceExpander(p) {\n  const info = kAddressSpaceInfo[p.addressSpace];\n  return info.spell === 'must' ? [true] : [true, false];\n}\n\n/**\n * @returns a list of usable access modes under given experiment conditions, or undefined\n * if none are allowed.\n */\nexport function accessModeExpander(p)\n\n\n{\n  const info = kAddressSpaceInfo[p.addressSpace];\n  return p.explicitAccess && info.spellAccessMode !== 'never' ? info.accessModes : [''];\n}\n\n/**\n * @returns a WGSL program with a single variable declaration, with the\n * given parameterization\n */\nexport function getVarDeclShader(\np,\n\n\n\n\n\n\nadditionalBody)\n{\n  const info = kAddressSpaceInfo[p.addressSpace];\n  const decl = declareVarX(\n    p.explicitSpace ? p.addressSpace : '',\n    p.explicitAccess ? p.accessMode : ''\n  );\n\n  additionalBody = additionalBody ?? '';\n\n  switch (info.scope) {\n    case 'module':\n      return decl + '\\n' + declareEntryPoint({ stage: p.stage, body: additionalBody });\n\n    case 'function':\n      return declareEntryPoint({ stage: p.stage, body: decl + '\\n' + additionalBody });\n  }\n}\n\n/**\n * @returns the WGSL spelling of a pointer type corresponding to a variable\n * declared with the given parameters.\n */\nexport function pointerType(p)\n\n\n\n\n{\n  const space = p.explicitSpace ? p.addressSpace : 'function';\n  const modePart = p.accessMode ? ',' + p.accessMode : '';\n  return `ptr<${space},${p.ptrStoreType}${modePart}>`;\n}\n\n/** @returns the effective access mode for the given experiment.  */\nexport function effectiveAccessMode(\ninfo,\naccessMode)\n{\n  return accessMode || info.accessModes[0]; // default is first.\n}\n\n/** @returns whether the setup allows reads */\nexport function supportsRead(p)\n\n\n{\n  const info = kAddressSpaceInfo[p.addressSpace];\n  const mode = effectiveAccessMode(info, p.accessMode);\n  return info.accessModes.includes(mode) && kAccessModeInfo[mode].read;\n}\n\n/** @returns whether the setup allows writes */\nexport function supportsWrite(p)\n\n\n{\n  const info = kAddressSpaceInfo[p.addressSpace];\n  const mode = effectiveAccessMode(info, p.accessMode);\n  return info.accessModes.includes(mode) && kAccessModeInfo[mode].write;\n}"],"mappings":"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","ignoreList":[]}