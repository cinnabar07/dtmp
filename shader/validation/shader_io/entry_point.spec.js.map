{"version":3,"file":"entry_point.spec.js","names":["description","makeTestGroup","ShaderValidationTest","g","test","desc","params","u","combine","beginSubcases","fn","t","vertex_attr","target_stage","fragment_attr","compute_attr","code","expectCompileResult"],"sources":["../../../../../src/webgpu/shader/validation/shader_io/entry_point.spec.ts"],"sourcesContent":["/**\n* AUTO-GENERATED - DO NOT EDIT. Source: https://github.com/gpuweb/cts\n**/export const description = `Validation tests for attributes and entry point requirements`;import { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { ShaderValidationTest } from '../shader_validation_test.js';\n\nexport const g = makeTestGroup(ShaderValidationTest);\n\ng.test('missing_attribute_on_param').\ndesc(`Test that an entry point without an IO attribute on one of its parameters is rejected.`).\nparams((u) =>\nu.combine('target_stage', ['', 'vertex', 'fragment', 'compute']).beginSubcases()\n).\nfn((t) => {\n  const vertex_attr = t.params.target_stage === 'vertex' ? '' : '@location(1)';\n  const fragment_attr = t.params.target_stage === 'fragment' ? '' : '@location(1)';\n  const compute_attr = t.params.target_stage === 'compute' ? '' : '@builtin(workgroup_id)';\n  const code = `\n@vertex\nfn vert_main(@location(0) a : f32,\n             ${vertex_attr}  b : f32,\n@             location(2) c : f32) -> @builtin(position) vec4<f32> {\n  return vec4<f32>();\n}\n\n@fragment\nfn frag_main(@location(0)  a : f32,\n             ${fragment_attr} b : f32,\n@             location(2)  c : f32) {\n}\n\n@compute @workgroup_size(1)\nfn comp_main(@builtin(global_invocation_id) a : vec3<u32>,\n             ${compute_attr}                   b : vec3<u32>,\n             @builtin(local_invocation_id)  c : vec3<u32>) {\n}\n`;\n  t.expectCompileResult(t.params.target_stage === '', code);\n});\n\ng.test('missing_attribute_on_param_struct').\ndesc(\n  `Test that an entry point struct parameter without an IO attribute on one of its members is rejected.`\n).\nparams((u) =>\nu.combine('target_stage', ['', 'vertex', 'fragment', 'compute']).beginSubcases()\n).\nfn((t) => {\n  const vertex_attr = t.params.target_stage === 'vertex' ? '' : '@location(1)';\n  const fragment_attr = t.params.target_stage === 'fragment' ? '' : '@location(1)';\n  const compute_attr = t.params.target_stage === 'compute' ? '' : '@builtin(workgroup_id)';\n  const code = `\nstruct VertexInputs {\n  @location(0) a : f32,\n  ${vertex_attr}  b : f32,\n@  location(2) c : f32,\n};\nstruct FragmentInputs {\n  @location(0)  a : f32,\n  ${fragment_attr} b : f32,\n@  location(2)  c : f32,\n};\nstruct ComputeInputs {\n  @builtin(global_invocation_id) a : vec3<u32>,\n  ${compute_attr}                   b : vec3<u32>,\n  @builtin(local_invocation_id)  c : vec3<u32>,\n};\n\n@vertex\nfn vert_main(inputs : VertexInputs) -> @builtin(position) vec4<f32> {\n  return vec4<f32>();\n}\n\n@fragment\nfn frag_main(inputs : FragmentInputs) {\n}\n\n@compute @workgroup_size(1)\nfn comp_main(inputs : ComputeInputs) {\n}\n`;\n  t.expectCompileResult(t.params.target_stage === '', code);\n});\n\ng.test('missing_attribute_on_return_type').\ndesc(`Test that an entry point without an IO attribute on its return type is rejected.`).\nparams((u) => u.combine('target_stage', ['', 'vertex', 'fragment']).beginSubcases()).\nfn((t) => {\n  const vertex_attr = t.params.target_stage === 'vertex' ? '' : '@builtin(position)';\n  const fragment_attr = t.params.target_stage === 'fragment' ? '' : '@location(0)';\n  const code = `\n@vertex\nfn vert_main() -> ${vertex_attr} vec4<f32> {\n  return vec4<f32>();\n}\n\n@fragment\nfn frag_main() -> ${fragment_attr} vec4<f32> {\n  return vec4<f32>();\n}\n`;\n  t.expectCompileResult(t.params.target_stage === '', code);\n});\n\ng.test('missing_attribute_on_return_type_struct').\ndesc(\n  `Test that an entry point struct return type without an IO attribute on one of its members is rejected.`\n).\nparams((u) => u.combine('target_stage', ['', 'vertex', 'fragment']).beginSubcases()).\nfn((t) => {\n  const vertex_attr = t.params.target_stage === 'vertex' ? '' : '@location(1)';\n  const fragment_attr = t.params.target_stage === 'fragment' ? '' : '@location(1)';\n  const code = `\nstruct VertexOutputs {\n  @location(0)       a : f32,\n  ${vertex_attr}        b : f32,\n  @builtin(position) c : vec4<f32>,\n};\nstruct FragmentOutputs {\n  @location(0)  a : f32,\n  ${fragment_attr} b : f32,\n@  location(2)  c : f32,\n};\n\n@vertex\nfn vert_main() -> VertexOutputs {\n  return VertexOutputs();\n}\n\n@fragment\nfn frag_main() -> FragmentOutputs {\n  return FragmentOutputs();\n}\n`;\n  t.expectCompileResult(t.params.target_stage === '', code);\n});\n\ng.test('no_entry_point_provided').\ndesc(`Tests that a shader without an entry point is accepted`).\nfn((t) => {\n  t.expectCompileResult(true, 'fn main() {}');\n});"],"mappings":"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","ignoreList":[]}