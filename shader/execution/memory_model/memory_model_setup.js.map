{"version":3,"file":"memory_model_setup.js","names":["checkElementsPassPredicate","align","PRNG","kAccessValueTypes","kWidth","numMemLocations","numReadOutputs","numStressParams","barrierParamIndex","memStressIndex","memStressIterationsIndex","memStressPatternIndex","preStressIndex","preStressIterationsIndex","preStressPatternIndex","permuteFirstIndex","permuteSecondIndex","testingWorkgroupsIndex","memStrideIndex","memLocationOffsetIndex","bytesPerWord","shaderPreamble","accessValueType","constants","MemoryModelTester","constructor","t","params","testShader","resultShader","useTexture","prng","test","workgroupXSize","Math","min","workgroupSize","device","limits","maxComputeWorkgroupSizeX","maxWorkgroups","scratchMemorySize","testingThreads","testingWorkgroups","testLocationsSize","memStride","testLocationsBuffer","deviceBuf","createBufferTracked","label","size","usage","GPUBufferUsage","COPY_DST","STORAGE","srcBuf","COPY_SRC","readResultsSize","readResultsBuffer","testResultsSize","numBehaviors","testResultsBuffer","shuffledWorkgroupsSize","shuffledWorkgroupsBuffer","MAP_WRITE","numTexels","width","height","textureSize","textureLocations","deviceTex","createTextureTracked","format","dimension","GPUTextureUsage","STORAGE_BINDING","textures","testLocations","falseSharingAvoidanceQuantum","barrierSize","scratchpadSize","scratchMemoryLocationsSize","comboSize","comboBuffer","barrierBuffer","offset","scratchpadBuffer","scratchMemoryLocationsBuffer","stressParamsSize","stressParamsBuffer","UNIFORM","buffers","readResults","testResults","shuffledWorkgroups","barrier","scratchpad","scratchMemoryLocations","stressParams","testLayout","createBindGroupLayout","entries","binding","visibility","GPUShaderStage","COMPUTE","buffer","type","layouts","textureLayout","storageTexture","access","viewDimension","texLocations","textureBindGroup","createBindGroup","resource","createView","layout","testPipeline","createComputePipeline","createPipelineLayout","bindGroupLayouts","compute","module","createShaderModule","code","entryPoint","testBindGroup","resultLayout","resultPipeline","resultBindGroup","run","iterations","weakIndex","i","numWorkgroups","getRandomInRange","setShuffledWorkgroups","setScratchLocations","setStressParams","encoder","globalThis","_TRAMPOLINE_","createCommandEncoder","copyBufferToBuffer","copyBufferToTexture","testPass","beginComputePass","setPipeline","setBindGroup","dispatchWorkgroups","end","resultPass","queue","submit","finish","expectGPUBufferValuesPassCheck","checkWeakIndex","Uint32Array","typedLength","checkResult","resultPrinter","a","predicatePrinter","leftHeader","getValueForCell","v","texture","bytesPerRow","rowsPerImage","getRandomInt","max","randomU32","shuffleArray","length","toSwap","temp","mapAsync","GPUMapMode","WRITE","getMappedRange","shuffledWorkgroupsArray","shufflePct","x","unmap","scratchLocationsArrayBuffer","scratchLocationsArray","scratchNumRegions","stressLineSize","scratchRegions","Array","keys","stressTargetLines","region","locInRegion","stressStrategyBalancePct","j","workgroupsPerLocation","stressParamsArrayBuffer","stressParamsArray","barrierPct","memStressPct","memStressIterations","memStressStoreFirst","memStressStoreFirstPct","memStressStoreSecond","memStressStoreSecondPct","memStressPattern","preStressPct","preStressIterations","preStressStoreFirst","preStressStoreFirstPct","preStressStoreSecond","preStressStoreSecondPct","preStressPattern","permuteFirst","permuteSecond","aliasedMemory","shaderMemStructures","fourBehaviorTestResultStructure","twoBehaviorTestResultStructure","commonTestShaderBindings","atomicTestShaderBindings","join","nonAtomicTestShaderBindings","textureBindings","resultShaderBindings","atomicWorkgroupMemory","nonAtomicWorkgroupMemory","memoryLocationFunctions","textureFunctions","testShaderFunctions","shaderEntryPoint","testShaderCommonHeader","testShaderCommonCalculations","interWorkgroupTestShaderCode","intraWorkgroupTestShaderCode","storageIntraWorkgroupTestShaderCode","testShaderCommonFooter","resultShaderCommonCalculations","interWorkgroupResultShaderCode","intraWorkgroupResultShaderCode","resultShaderCommonFooter","storageMemoryAtomicTestShaderCode","storageMemoryNonAtomicTestShaderCode","textureMemoryNonAtomicTestShaderCode","workgroupMemoryAtomicTestShaderCode","workgroupMemoryNonAtomicTestShaderCode","resultShaderCommonCode","MemoryType","TestType","ResultType","buildTestShader","testCode","memoryType","testType","memoryTypeCode","isGlobalSpace","AtomicStorageClass","NonAtomicStorageClass","AtomicWorkgroupClass","NonAtomicWorkgroupClass","NonAtomicTextureClass","testTypeCode","InterWorkgroup","IntraWorkgroup","buildResultShader","resultCode","resultType","resultStructure","TwoBehavior","FourBehavior"],"sources":["../../../../../src/webgpu/shader/execution/memory_model/memory_model_setup.ts"],"sourcesContent":["/**\n* AUTO-GENERATED - DO NOT EDIT. Source: https://github.com/gpuweb/cts\n**/import { checkElementsPassPredicate } from '../../../util/check_contents.js';import { align } from '../../../util/math.js';\nimport { PRNG } from '../../../util/prng.js';\n\n/* All buffer sizes are counted in units of 4-byte words. */\n\n/**\n * The value type loaded and stored from memory.\n * This is what the WGSL spec calls 'store type' for the locations being accessed.\n * The GPU buffers are sized assuming this type is at most 4 bytes.\n *\n * 'u32' is the default case; it can be atomically loaded and stored.\n * 'f16' is interesting because it is not 32-bits, and can't be the store type\n * for atomic accesses.\n */\n\nexport const kAccessValueTypes = ['f16', 'u32'];\n\n/** The width used for textures (default compat limit in WebGPU). */\nconst kWidth = 4096;\n\n/* Parameter values are set heuristically, typically by a time-intensive search. */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/** The number of memory locations accessed by a test. Currently, only tests with up to 2 memory locations are supported. */\nconst numMemLocations = 2;\n\n/** The number of read outputs per test that need to be analyzed in the result aggregation shader. Currently, only tests with up to 2 read outputs are supported. */\nconst numReadOutputs = 2;\n\n/** Represents a device buffer and a utility buffer for resetting memory and copying parameters. */\n\n\n\n\n\n\n\n\n\n/** Represents a device texture and a utility buffer for resetting memory and copying parameters. */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/** Specifies the buffers used during a memory model test. */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/** The number of stress params to add to the stress params buffer. */\nconst numStressParams = 12;\nconst barrierParamIndex = 0;\nconst memStressIndex = 1;\nconst memStressIterationsIndex = 2;\nconst memStressPatternIndex = 3;\nconst preStressIndex = 4;\nconst preStressIterationsIndex = 5;\nconst preStressPatternIndex = 6;\nconst permuteFirstIndex = 7;\nconst permuteSecondIndex = 8;\nconst testingWorkgroupsIndex = 9;\nconst memStrideIndex = 10;\nconst memLocationOffsetIndex = 11;\n\n/**\n * All memory used in these consists of a four byte word, so this value is used to correctly set the byte size of buffers that\n * are read to/written from during tests and for storing test results.\n */\nconst bytesPerWord = 4;\n\n/**\n * Returns the shader preamble based on the access value type:\n *  - enable directives, if necessary\n *  - the type alias for AccessValueType\n */\nfunction shaderPreamble(accessValueType, constants) {\n  if (accessValueType === 'f16') {\n    return `enable f16;\\nalias AccessValueTy = f16;\\n${constants}\\n`;\n  }\n  return `alias AccessValueTy = ${accessValueType};\\n${constants}\\n`;\n}\n\n/**\n * Implements setup code necessary to run a memory model test. A test consists of two parts:\n *  1.) A test shader that runs a specified memory model litmus test and attempts to reveal a weak (disallowed) behavior.\n *      At a high level, a test shader consists of a set of testing workgroups where every invocation executes the litmus test\n *      on a set of test locations, and a set of stressing workgroups where every invocation accesses a specified memory location\n *      in a random pattern.\n *\n *      The main buffer variables are:\n *\n *        `test_locations`: invocations access entries in this array, trying to\n *          evoke weak behaviours.\n *\n *          This is array<AccessValueTy> or array<atomic<u32>>.\n *          AccessValueTy is either f16 or u32.\n *          Note that atomic<u32> is only used when AccessValueTy is u32.\n *\n *        `results`: holds the observed values, which is where we can see\n *          whether a weak behaviour was observed.\n *\n *          This is an array<atomic<u32>>.\n *\n *      The others are used to parameterize and stress the main activity.\n *\n *  2.) A result shader that takes the output of the test shader, which consists of the memory locations accessed during the test\n *      and the results of any reads made during the test, and aggregate the results based on the possible behaviors of the test.\n *\n *      The first two buffer variables are the same buffers as for the test shader:\n *\n *        `test_locations` is the same as `test_locations` from the test shader,\n *        but is mapped as array<AccessValueTy>.\n *\n *        `read_results` is the same buffer as `results` from the test shader.\n *\n *      The other variables are used to accumulate a summary that counts the weak behaviours stimulated and recorded by the\n *      test shader.\n */\nexport class MemoryModelTester {\n\n\n\n\n\n\n\n\n\n\n\n\n  /** Sets up a memory model test by initializing buffers and pipeline layouts. */\n  constructor(\n  t,\n  params,\n  testShader,\n  resultShader,\n  accessValueType = 'u32',\n  useTexture = false)\n  {\n    this.prng = new PRNG(1);\n    this.test = t;\n    this.params = params;\n    this.useTexture = useTexture;\n\n    const workgroupXSize = Math.min(params.workgroupSize, t.device.limits.maxComputeWorkgroupSizeX);\n    const constants = `\n      const kNumBarriers = 1u;  // MAINTENANCE_TODO: make barrier not an array\n      const kMaxWorkgroups = ${params.maxWorkgroups}u;\n      const kScratchMemorySize = ${params.scratchMemorySize}u;\n      const kWorkgroupXSize = ${workgroupXSize}u;\n    `;\n    testShader = shaderPreamble(accessValueType, constants) + testShader;\n    resultShader = shaderPreamble(accessValueType, constants) + resultShader;\n\n    // set up buffers\n    const testingThreads = workgroupXSize * this.params.testingWorkgroups;\n    const testLocationsSize =\n    testingThreads * numMemLocations * this.params.memStride * bytesPerWord;\n    const testLocationsBuffer = {\n      deviceBuf: this.test.createBufferTracked({\n        label: 'testLocationsBuffer',\n        size: testLocationsSize,\n        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE\n      }),\n      srcBuf: this.test.createBufferTracked({\n        label: 'testLocationsSrcBuf',\n        size: testLocationsSize,\n        usage: GPUBufferUsage.COPY_SRC\n      }),\n      size: testLocationsSize\n    };\n\n    const readResultsSize = testingThreads * numReadOutputs * bytesPerWord;\n    const readResultsBuffer = {\n      deviceBuf: this.test.createBufferTracked({\n        label: 'readResultsBuffer',\n        size: readResultsSize,\n        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE\n      }),\n      srcBuf: this.test.createBufferTracked({\n        label: 'readResultsSrcBuf',\n        size: readResultsSize,\n        usage: GPUBufferUsage.COPY_SRC\n      }),\n      size: readResultsSize\n    };\n\n    const testResultsSize = this.params.numBehaviors * bytesPerWord;\n    const testResultsBuffer = {\n      deviceBuf: this.test.createBufferTracked({\n        label: 'testResultsBuffer',\n        size: testResultsSize,\n        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC\n      }),\n      srcBuf: this.test.createBufferTracked({\n        label: 'testResultsSrcBuffer',\n        size: testResultsSize,\n        usage: GPUBufferUsage.COPY_SRC\n      }),\n      size: testResultsSize\n    };\n\n    const shuffledWorkgroupsSize = this.params.maxWorkgroups * bytesPerWord;\n    const shuffledWorkgroupsBuffer = {\n      deviceBuf: this.test.createBufferTracked({\n        size: shuffledWorkgroupsSize,\n        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE\n      }),\n      srcBuf: this.test.createBufferTracked({\n        size: shuffledWorkgroupsSize,\n        usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.MAP_WRITE\n      }),\n      size: shuffledWorkgroupsSize\n    };\n\n    if (this.useTexture) {\n      const numTexels = testLocationsSize / bytesPerWord;\n      const width = kWidth;\n      const height = numTexels / width;\n      const textureSize = { width, height };\n      const textureLocations = {\n        deviceTex: this.test.createTextureTracked({\n          format: 'r32uint',\n          dimension: '2d',\n          size: textureSize,\n          usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.STORAGE_BINDING\n        }),\n        srcBuf: testLocationsBuffer.srcBuf,\n        size: testLocationsSize\n      };\n      this.textures = {\n        testLocations: textureLocations\n      };\n    }\n\n    // Combine 3 arrays into 1 buffer as we need to keep the number of storage buffers to 4 for compat.\n    const falseSharingAvoidanceQuantum = 4096;\n    const barrierSize = align(bytesPerWord, falseSharingAvoidanceQuantum);\n    const scratchpadSize = align(\n      this.params.scratchMemorySize * bytesPerWord,\n      falseSharingAvoidanceQuantum\n    );\n    const scratchMemoryLocationsSize = align(\n      this.params.maxWorkgroups * bytesPerWord,\n      falseSharingAvoidanceQuantum\n    );\n    const comboSize = barrierSize + scratchpadSize + scratchMemoryLocationsSize;\n\n    const comboBuffer = this.test.createBufferTracked({\n      label: 'comboBuffer',\n      size: comboSize,\n      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE\n    });\n\n    const barrierBuffer = {\n      deviceBuf: comboBuffer,\n      srcBuf: this.test.createBufferTracked({\n        label: 'barrierSrcBuf',\n        size: barrierSize,\n        usage: GPUBufferUsage.COPY_SRC\n      }),\n      size: barrierSize,\n      offset: 0\n    };\n\n    const scratchpadBuffer = {\n      deviceBuf: comboBuffer,\n      srcBuf: this.test.createBufferTracked({\n        label: 'scratchpadSrcBuf',\n        size: scratchpadSize,\n        usage: GPUBufferUsage.COPY_SRC\n      }),\n      size: scratchpadSize,\n      offset: barrierSize\n    };\n\n    const scratchMemoryLocationsBuffer = {\n      deviceBuf: comboBuffer,\n      srcBuf: this.test.createBufferTracked({\n        label: 'scratchMemoryLocationsSrcBuf',\n        size: scratchMemoryLocationsSize,\n        usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.MAP_WRITE\n      }),\n      size: scratchMemoryLocationsSize,\n      offset: barrierSize + scratchpadSize\n    };\n\n    const stressParamsSize = numStressParams * bytesPerWord;\n    const stressParamsBuffer = {\n      deviceBuf: this.test.createBufferTracked({\n        label: 'stressParamsBuffer',\n        size: stressParamsSize,\n        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM\n      }),\n      srcBuf: this.test.createBufferTracked({\n        label: 'stressParamsSrcBuf',\n        size: stressParamsSize,\n        usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.MAP_WRITE\n      }),\n      size: stressParamsSize\n    };\n\n    this.buffers = {\n      testLocations: testLocationsBuffer,\n      readResults: readResultsBuffer,\n      testResults: testResultsBuffer,\n      shuffledWorkgroups: shuffledWorkgroupsBuffer,\n      barrier: barrierBuffer,\n      scratchpad: scratchpadBuffer,\n      scratchMemoryLocations: scratchMemoryLocationsBuffer,\n      stressParams: stressParamsBuffer\n    };\n\n    // set up pipeline layouts\n    const testLayout = this.test.device.createBindGroupLayout({\n      label: 'testLayout',\n      entries: [\n      { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },\n      { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },\n      { binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },\n      { binding: 3, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },\n      { binding: 4, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'uniform' } }]\n\n    });\n\n    let layouts = [testLayout];\n    if (this.useTexture) {\n      const textureLayout = this.test.device.createBindGroupLayout({\n        label: 'textureLayout',\n        entries: [\n        {\n          binding: 0,\n          visibility: GPUShaderStage.COMPUTE,\n          storageTexture: {\n            access: 'read-write',\n            format: 'r32uint',\n            viewDimension: '2d'\n          }\n        }]\n\n      });\n      layouts = [testLayout, textureLayout];\n\n      const texLocations = this.textures.testLocations.deviceTex;\n      this.textureBindGroup = this.test.device.createBindGroup({\n        label: 'textureBindGroup',\n        entries: [\n        {\n          binding: 0,\n          resource: texLocations.createView()\n        }],\n\n        layout: textureLayout\n      });\n    }\n    this.testPipeline = this.test.device.createComputePipeline({\n      label: 'testPipeline',\n      layout: this.test.device.createPipelineLayout({\n        bindGroupLayouts: layouts\n      }),\n      compute: {\n        module: this.test.device.createShaderModule({\n          code: testShader\n        }),\n        entryPoint: 'main'\n      }\n    });\n    this.testBindGroup = this.test.device.createBindGroup({\n      label: 'testBindGroup',\n      entries: [\n      { binding: 0, resource: { buffer: this.buffers.testLocations.deviceBuf } },\n      { binding: 1, resource: { buffer: this.buffers.readResults.deviceBuf } },\n      { binding: 2, resource: { buffer: this.buffers.shuffledWorkgroups.deviceBuf } },\n      { binding: 3, resource: { buffer: comboBuffer } },\n      { binding: 4, resource: { buffer: this.buffers.stressParams.deviceBuf } }],\n\n      layout: testLayout\n    });\n\n    const resultLayout = this.test.device.createBindGroupLayout({\n      label: 'resultLayout',\n      entries: [\n      { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },\n      { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },\n      { binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },\n      { binding: 3, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'uniform' } }]\n\n    });\n    this.resultPipeline = this.test.device.createComputePipeline({\n      label: 'resultPipeline',\n      layout: this.test.device.createPipelineLayout({\n        bindGroupLayouts: [resultLayout]\n      }),\n      compute: {\n        module: this.test.device.createShaderModule({\n          code: resultShader\n        }),\n        entryPoint: 'main'\n      }\n    });\n    this.resultBindGroup = this.test.device.createBindGroup({\n      label: 'resultBindGroup',\n      entries: [\n      { binding: 0, resource: { buffer: this.buffers.testLocations.deviceBuf } },\n      { binding: 1, resource: { buffer: this.buffers.readResults.deviceBuf } },\n      { binding: 2, resource: { buffer: this.buffers.testResults.deviceBuf } },\n      { binding: 3, resource: { buffer: this.buffers.stressParams.deviceBuf } }],\n\n      layout: resultLayout\n    });\n  }\n\n  /**\n   * Run the test for the specified number of iterations. Checks the testResults buffer on the weakIndex; if\n   * this value is not 0 then the test has failed. The number of iterations is chosen per test so that the\n   * full set of tests meets some time budget while still being reasonably effective at uncovering issues.\n   * Currently, we aim for each test to complete in under one second.\n   */\n  async run(iterations, weakIndex) {\n    for (let i = 0; i < iterations; i++) {\n      const numWorkgroups = this.getRandomInRange(\n        this.params.testingWorkgroups,\n        this.params.maxWorkgroups\n      );\n      await this.setShuffledWorkgroups(numWorkgroups);\n      await this.setScratchLocations(numWorkgroups);\n      await this.setStressParams();\n      const encoder = globalThis._TRAMPOLINE_(\"createCommandEncoder\", this.test.device, this.test.device.createCommandEncoder, [], () => this.test.device.createCommandEncoder());\n      this.copyBufferToBuffer(encoder, this.buffers.testLocations);\n      this.copyBufferToBuffer(encoder, this.buffers.readResults);\n      this.copyBufferToBuffer(encoder, this.buffers.testResults);\n      this.copyBufferToBuffer(encoder, this.buffers.barrier);\n      this.copyBufferToBuffer(encoder, this.buffers.shuffledWorkgroups);\n      this.copyBufferToBuffer(encoder, this.buffers.scratchpad);\n      this.copyBufferToBuffer(encoder, this.buffers.scratchMemoryLocations);\n      this.copyBufferToBuffer(encoder, this.buffers.stressParams);\n      if (this.useTexture) {\n        this.copyBufferToTexture(encoder, this.textures.testLocations);\n      }\n\n      const testPass = encoder.beginComputePass();\n      testPass.setPipeline(this.testPipeline);\n      testPass.setBindGroup(0, this.testBindGroup);\n      if (this.useTexture) {\n        testPass.setBindGroup(1, this.textureBindGroup);\n      }\n      testPass.dispatchWorkgroups(numWorkgroups);\n      testPass.end();\n\n      const resultPass = encoder.beginComputePass();\n      resultPass.setPipeline(this.resultPipeline);\n      resultPass.setBindGroup(0, this.resultBindGroup);\n      resultPass.dispatchWorkgroups(this.params.testingWorkgroups);\n      resultPass.end();\n\n      globalThis._TRAMPOLINE_(\"submit\", this.test.device, this.test.device.queue.submit, [[encoder.finish()]], () => this.test.device.queue.submit([encoder.finish()]));\n      this.test.expectGPUBufferValuesPassCheck(\n        this.buffers.testResults.deviceBuf,\n        this.checkWeakIndex(weakIndex),\n        {\n          type: Uint32Array,\n          typedLength: this.params.numBehaviors\n        }\n      );\n    }\n  }\n\n  /** Returns a function that checks whether the test passes, given a weak index and the test results buffer. */\n  checkWeakIndex(weakIndex) {\n    const checkResult = this.checkResult(weakIndex);\n    const resultPrinter = this.resultPrinter(weakIndex);\n    return function (a) {\n      return checkElementsPassPredicate(a, checkResult, {\n        predicatePrinter: [{ leftHeader: 'expected ==', getValueForCell: resultPrinter }]\n      });\n    };\n  }\n\n  /**\n   * Returns a function that checks whether the specified weak index's value is not equal to 0.\n   * If the weak index's value is not 0, it means the test has observed a behavior disallowed by the memory model and\n   * is considered a test failure.\n   */\n  checkResult(weakIndex) {\n    return function (i, v) {\n      if (i === weakIndex && v > 0) {\n        return false;\n      }\n      return true;\n    };\n  }\n\n  /** Returns a printer function that visualizes the results of checking the test results. */\n  resultPrinter(weakIndex) {\n    return function (i) {\n      if (i === weakIndex) {\n        return 0;\n      } else {\n        return 'any value';\n      }\n    };\n  }\n\n  /** Utility method that simplifies copying source buffers to device buffers. */\n  copyBufferToBuffer(\n  encoder,\n  buffer)\n  {\n    encoder.copyBufferToBuffer(\n      buffer.srcBuf,\n      0,\n      buffer.deviceBuf,\n      buffer.offset || 0,\n      buffer.size\n    );\n  }\n\n  /** Utility method that simplifies copying source buffers to device textures. */\n  copyBufferToTexture(encoder, texture) {\n    const bytesPerWord = 4; // always uses r32uint format.\n    const numTexels = texture.size / bytesPerWord;\n    const size = { width: kWidth, height: numTexels / kWidth };\n    encoder.copyBufferToTexture(\n      {\n        buffer: texture.srcBuf,\n        offset: 0,\n        bytesPerRow: kWidth * bytesPerWord,\n        rowsPerImage: size.height\n      },\n      { texture: texture.deviceTex },\n      size\n    );\n  }\n\n  /** Returns a random integer in the range [0, max). */\n  getRandomInt(max) {\n    return this.prng.randomU32() % max;\n  }\n\n  /** Returns a random number in the range [min, max). */\n  getRandomInRange(min, max) {\n    if (min === max) {\n      return min;\n    } else {\n      const offset = this.getRandomInt(max - min);\n      return min + offset;\n    }\n  }\n\n  /** Returns a permuted array using a simple Fisher-Yates shuffle algorithm. */\n  shuffleArray(a) {\n    for (let i = a.length - 1; i >= 0; i--) {\n      const toSwap = this.getRandomInt(i + 1);\n      const temp = a[toSwap];\n      a[toSwap] = a[i];\n      a[i] = temp;\n    }\n  }\n\n  /**\n   * Shuffles the order of workgroup ids, so that threads operating on the same memory location are not always in\n   * consecutive workgroups.\n   */\n  async setShuffledWorkgroups(numWorkgroups) {\n    await globalThis._TRAMPOLINE_(\"mapAsync\", this.buffers.shuffledWorkgroups.srcBuf, this.buffers.shuffledWorkgroups.srcBuf.mapAsync, [GPUMapMode.WRITE], () => this.buffers.shuffledWorkgroups.srcBuf.mapAsync(GPUMapMode.WRITE));\n    const shuffledWorkgroupsBuffer = this.buffers.shuffledWorkgroups.srcBuf.getMappedRange();\n    const shuffledWorkgroupsArray = new Uint32Array(shuffledWorkgroupsBuffer);\n    for (let i = 0; i < numWorkgroups; i++) {\n      shuffledWorkgroupsArray[i] = i;\n    }\n    if (this.getRandomInt(100) < this.params.shufflePct) {\n      for (let i = numWorkgroups - 1; i > 0; i--) {\n        const x = this.getRandomInt(i + 1);\n        const temp = shuffledWorkgroupsArray[i];\n        shuffledWorkgroupsArray[i] = shuffledWorkgroupsArray[x];\n        shuffledWorkgroupsArray[x] = temp;\n      }\n    }\n    this.buffers.shuffledWorkgroups.srcBuf.unmap();\n  }\n\n  /** Sets the memory locations that stressing workgroups will access. Uses either a chunking or round robin assignment strategy. */\n  async setScratchLocations(numWorkgroups) {\n    await globalThis._TRAMPOLINE_(\"mapAsync\", this.buffers.scratchMemoryLocations.srcBuf, this.buffers.scratchMemoryLocations.srcBuf.mapAsync, [GPUMapMode.WRITE], () => this.buffers.scratchMemoryLocations.srcBuf.mapAsync(GPUMapMode.WRITE));\n    const scratchLocationsArrayBuffer = this.buffers.scratchMemoryLocations.srcBuf.getMappedRange();\n    const scratchLocationsArray = new Uint32Array(scratchLocationsArrayBuffer);\n    const scratchNumRegions = this.params.scratchMemorySize / this.params.stressLineSize;\n    const scratchRegions = [...Array(scratchNumRegions).keys()];\n    this.shuffleArray(scratchRegions);\n    for (let i = 0; i < this.params.stressTargetLines; i++) {\n      const region = scratchRegions[i];\n      const locInRegion = this.getRandomInt(this.params.stressLineSize);\n      if (this.getRandomInt(100) < this.params.stressStrategyBalancePct) {\n        // In the round-robin case, the current scratch location is striped across all workgroups.\n        for (let j = i; j < numWorkgroups; j += this.params.stressTargetLines) {\n          scratchLocationsArray[j] = region * this.params.stressLineSize + locInRegion;\n        }\n      } else {\n        // In the chunking case, the current scratch location is assigned to a block of workgroups. The final scratch\n        // location may be assigned to more workgroups, if the number of scratch locations does not cleanly divide the\n        // number of workgroups.\n        const workgroupsPerLocation = numWorkgroups / this.params.stressTargetLines;\n        for (let j = 0; j < workgroupsPerLocation; j++) {\n          scratchLocationsArray[i * workgroupsPerLocation + j] =\n          region * this.params.stressLineSize + locInRegion;\n        }\n        if (\n        i === this.params.stressTargetLines - 1 &&\n        numWorkgroups % this.params.stressTargetLines !== 0)\n        {\n          for (let j = 0; j < numWorkgroups % this.params.stressTargetLines; j++) {\n            scratchLocationsArray[numWorkgroups - j - 1] =\n            region * this.params.stressLineSize + locInRegion;\n          }\n        }\n      }\n    }\n    this.buffers.scratchMemoryLocations.srcBuf.unmap();\n  }\n\n  /** Sets the parameters that are used by the shader to calculate memory locations and perform stress. */\n  async setStressParams() {\n    await globalThis._TRAMPOLINE_(\"mapAsync\", this.buffers.stressParams.srcBuf, this.buffers.stressParams.srcBuf.mapAsync, [GPUMapMode.WRITE], () => this.buffers.stressParams.srcBuf.mapAsync(GPUMapMode.WRITE));\n    const stressParamsArrayBuffer = this.buffers.stressParams.srcBuf.getMappedRange();\n    const stressParamsArray = new Uint32Array(stressParamsArrayBuffer);\n    if (this.getRandomInt(100) < this.params.barrierPct) {\n      stressParamsArray[barrierParamIndex] = 1;\n    } else {\n      stressParamsArray[barrierParamIndex] = 0;\n    }\n    if (this.getRandomInt(100) < this.params.memStressPct) {\n      stressParamsArray[memStressIndex] = 1;\n    } else {\n      stressParamsArray[memStressIndex] = 0;\n    }\n    stressParamsArray[memStressIterationsIndex] = this.params.memStressIterations;\n    const memStressStoreFirst = this.getRandomInt(100) < this.params.memStressStoreFirstPct;\n    const memStressStoreSecond = this.getRandomInt(100) < this.params.memStressStoreSecondPct;\n    let memStressPattern;\n    if (memStressStoreFirst && memStressStoreSecond) {\n      memStressPattern = 0;\n    } else if (memStressStoreFirst && !memStressStoreSecond) {\n      memStressPattern = 1;\n    } else if (!memStressStoreFirst && memStressStoreSecond) {\n      memStressPattern = 2;\n    } else {\n      memStressPattern = 3;\n    }\n    stressParamsArray[memStressPatternIndex] = memStressPattern;\n    if (this.getRandomInt(100) < this.params.preStressPct) {\n      stressParamsArray[preStressIndex] = 1;\n    } else {\n      stressParamsArray[preStressIndex] = 0;\n    }\n    stressParamsArray[preStressIterationsIndex] = this.params.preStressIterations;\n    const preStressStoreFirst = this.getRandomInt(100) < this.params.preStressStoreFirstPct;\n    const preStressStoreSecond = this.getRandomInt(100) < this.params.preStressStoreSecondPct;\n    let preStressPattern;\n    if (preStressStoreFirst && preStressStoreSecond) {\n      preStressPattern = 0;\n    } else if (preStressStoreFirst && !preStressStoreSecond) {\n      preStressPattern = 1;\n    } else if (!preStressStoreFirst && preStressStoreSecond) {\n      preStressPattern = 2;\n    } else {\n      preStressPattern = 3;\n    }\n    stressParamsArray[preStressPatternIndex] = preStressPattern;\n    stressParamsArray[permuteFirstIndex] = this.params.permuteFirst;\n    stressParamsArray[permuteSecondIndex] = this.params.permuteSecond;\n    stressParamsArray[testingWorkgroupsIndex] = this.params.testingWorkgroups;\n    stressParamsArray[memStrideIndex] = this.params.memStride;\n    if (this.params.aliasedMemory) {\n      stressParamsArray[memLocationOffsetIndex] = 0;\n    } else {\n      stressParamsArray[memLocationOffsetIndex] = this.params.memStride;\n    }\n    this.buffers.stressParams.srcBuf.unmap();\n  }\n}\n\n/** Defines common data structures used in memory model test shaders. */\nconst shaderMemStructures = `\n  struct Memory {\n    value: array<AccessValueTy>\n  };\n\n  struct AtomicMemory {\n    value: array<atomic<u32>>\n  };\n\n  struct IndexMemory {\n    value: array<u32>,\n  };\n\n  struct AtomicMemoryBarrier {\n    value: array<atomic<u32>, kNumBarriers>\n  };\n\n  struct IndexMemoryScratchpad {\n    value: array<u32, kMaxWorkgroups>,\n  };\n\n  struct IndexMemoryScratchLocations {\n    value: array<u32, kScratchMemorySize>,\n  };\n\n  struct ReadResult {\n    r0: atomic<u32>,\n    r1: atomic<u32>,\n  };\n\n  struct ReadResults {\n    value: array<ReadResult>,\n  };\n\n  // These arrays are combine into 1 buffer because compat mode only supports 4 storage buffers by default.\n  struct CombinedData {\n    barrier: AtomicMemoryBarrier,\n    scratchpad: IndexMemoryScratchpad,\n    scratch_locations: IndexMemoryScratchLocations,\n  };\n\n  struct StressParamsMemory {\n    do_barrier: u32,\n    mem_stress: u32,\n    mem_stress_iterations: u32,\n    mem_stress_pattern: u32,\n    pre_stress: u32,\n    pre_stress_iterations: u32,\n    pre_stress_pattern: u32,\n    permute_first: u32,\n    permute_second: u32,\n    testing_workgroups: u32,\n    mem_stride: u32,\n    location_offset: u32,\n  };\n`;\n\n/**\n * Structure to hold the counts of occurrences of the possible behaviors of a two-thread, four-instruction test.\n * \"seq0\" means the first invocation's instructions are observed to have occurred before the second invocation's instructions.\n * \"seq1\" means the second invocation's instructions are observed to have occurred before the first invocation's instructions.\n * \"interleaved\" means there was an observation of some interleaving of instructions between the two invocations.\n * \"weak\" means there was an observation of some ordering of instructions that is inconsistent with the WebGPU memory model.\n */\nconst fourBehaviorTestResultStructure = `\n  struct TestResults {\n    seq0: atomic<u32>,\n    seq1: atomic<u32>,\n    interleaved: atomic<u32>,\n    weak: atomic<u32>,\n  };\n`;\n\n/**\n * Defines the possible behaviors of a two instruction test. Used to test the behavior of non-atomic memory with barriers and\n * one-thread coherence tests.\n * \"seq\" means that the expected, sequential behavior occurred.\n * \"weak\" means that an unexpected, inconsistent behavior occurred.\n */\nconst twoBehaviorTestResultStructure = `\n  struct TestResults {\n    seq: atomic<u32>,\n    weak: atomic<u32>,\n  };\n`;\n\n/** Common bindings used in the test shader phase of a test. */\nconst commonTestShaderBindings = `\n  @group(0) @binding(1) var<storage, read_write> results : ReadResults;\n  @group(0) @binding(2) var<storage, read> shuffled_workgroups : IndexMemory;\n  @group(0) @binding(3) var<storage, read_write> combo : CombinedData;\n  @group(0) @binding(4) var<uniform> stress_params : StressParamsMemory;\n`;\n\n/** The combined bindings for a test on atomic memory. */\nconst atomicTestShaderBindings = [\n`\n  @group(0) @binding(0) var<storage, read_write> test_locations : AtomicMemory;\n`,\ncommonTestShaderBindings].\njoin('\\n');\n\n/** The combined bindings for a test on non-atomic memory. */\nconst nonAtomicTestShaderBindings = [\n`\n  @group(0) @binding(0) var<storage, read_write> test_locations : Memory;\n`,\ncommonTestShaderBindings].\njoin('\\n');\n\n/** The extra binding for texture non-atomic texture tests. */\nconst textureBindings = `\n@group(1) @binding(0) var texture_locations : texture_storage_2d<r32uint, read_write>;\n`;\n\n/** Bindings used in the result aggregation phase of the test. */\nconst resultShaderBindings = `\n  @group(0) @binding(0) var<storage, read_write> test_locations : Memory;\n  @group(0) @binding(1) var<storage, read_write> read_results : ReadResults;\n  @group(0) @binding(2) var<storage, read_write> test_results : TestResults;\n  @group(0) @binding(3) var<uniform> stress_params : StressParamsMemory;\n`;\n\n/**\n * For tests that operate on workgroup memory, include this definition. 3584 memory locations is\n * large enough to accommodate the maximum memory size needed per workgroup for testing, which is\n * 256 invocations per workgroup x 2 memory locations x 7 (memStride, or max stride between successive memory locations).\n * Should change to a pipeline overridable constant when possible.\n */\nconst atomicWorkgroupMemory = `\n  var<workgroup> wg_test_locations: array<atomic<u32>, 3584>;\n`;\n\n/**\n * For tests that operate on non-atomic workgroup memory, include this definition. 3584 memory locations\n * is large enough to accommodate the maximum memory size needed per workgroup for testing.\n */\nconst nonAtomicWorkgroupMemory = `\n  var<workgroup> wg_test_locations: array<AccessValueTy, 3584>;\n`;\n\n/**\n * Functions used to calculate memory locations for each invocation, for both testing and result aggregation.\n * The permute function ensures a random permutation based on multiplying and modding by coprime numbers. The stripe\n * workgroup function ensures that invocations coordinating on a test are spread out across different workgroups.\n */\nconst memoryLocationFunctions = `\n  fn permute_id(id: u32, factor: u32, mask: u32) -> u32 {\n    return (id * factor) % mask;\n  }\n\n  fn stripe_workgroup(workgroup_id: u32, local_id: u32) -> u32 {\n    return (workgroup_id + 1u + local_id % (stress_params.testing_workgroups - 1u)) % stress_params.testing_workgroups;\n  }\n`;\n\n/**\n * Function to convert an index into an equivalent 2D coordinate for the texture.\n */\nconst textureFunctions = `\n  const kWidth = ${kWidth};\n  fn indexToCoord(idx : u32) -> vec2u {\n    return vec2u(idx % kWidth, idx / kWidth);\n  }\n`;\n\n/** Functions that help add stress to the test. */\nconst testShaderFunctions = `\n  //Force the invocations in the workgroup to wait for each other, but without the general memory ordering\n  // effects of a control barrier. The barrier spins until either all invocations have incremented the atomic\n  // variable or 1024 loops have occurred. 1024 was chosen because it gives more time for invocations to enter\n  // the barrier but does not overly reduce testing throughput.\n  fn spin(limit: u32) {\n    var i : u32 = 0u;\n    var bar_val : u32 = atomicAdd(&combo.barrier.value[0], 1u);\n    loop {\n      if (i == 1024u || bar_val >= limit) {\n        break;\n      }\n      bar_val = atomicAdd(&combo.barrier.value[0], 0u);\n      i = i + 1u;\n    }\n  }\n\n  // Perform iterations of stress, depending on the specified pattern. Pattern 0 is store-store, pattern 1 is store-load,\n  // pattern 2 is load-store, and pattern 3 is load-load. The extra if condition (if tmpX > 100000u), is used to avoid\n  // the compiler optimizing out unused loads, where 100,000 is larger than the maximum number of stress iterations used\n  // in any test.\n  fn do_stress(iterations: u32, pattern: u32, workgroup_id: u32) {\n    let addr = combo.scratch_locations.value[workgroup_id];\n    switch(pattern) {\n      case 0u: {\n        for(var i: u32 = 0u; i < iterations; i = i + 1u) {\n          combo.scratchpad.value[addr] = i;\n          combo.scratchpad.value[addr] = i + 1u;\n        }\n      }\n      case 1u: {\n        for(var i: u32 = 0u; i < iterations; i = i + 1u) {\n          combo.scratchpad.value[addr] = i;\n          let tmp1: u32 = combo.scratchpad.value[addr];\n          if (tmp1 > 100000u) {\n            combo.scratchpad.value[addr] = i;\n            break;\n          }\n        }\n      }\n      case 2u: {\n        for(var i: u32 = 0u; i < iterations; i = i + 1u) {\n          let tmp1: u32 = combo.scratchpad.value[addr];\n          if (tmp1 > 100000u) {\n            combo.scratchpad.value[addr] = i;\n            break;\n          }\n          combo.scratchpad.value[addr] = i;\n        }\n      }\n      case 3u: {\n        for(var i: u32 = 0u; i < iterations; i = i + 1u) {\n          let tmp1: u32 = combo.scratchpad.value[addr];\n          if (tmp1 > 100000u) {\n            combo.scratchpad.value[addr] = i;\n            break;\n          }\n          let tmp2: u32 = combo.scratchpad.value[addr];\n          if (tmp2 > 100000u) {\n            combo.scratchpad.value[addr] = i;\n            break;\n          }\n        }\n      }\n      default: {\n      }\n    }\n  }\n`;\n\n/**\n * Entry point to both test and result shaders. One-dimensional workgroup size is hardcoded to 256, until\n * pipeline overridable constants are supported.\n */\nconst shaderEntryPoint = `\n  // Change to pipeline overridable constant when possible.\n  const workgroupXSize = kWorkgroupXSize;\n  @compute @workgroup_size(workgroupXSize) fn main(\n    @builtin(local_invocation_id) local_invocation_id : vec3<u32>,\n    @builtin(workgroup_id) workgroup_id : vec3<u32>) {\n`;\n\n/** All test shaders first calculate the shuffled workgroup. */\nconst testShaderCommonHeader = `\n    let shuffled_workgroup = shuffled_workgroups.value[workgroup_id[0]];\n    if (shuffled_workgroup < stress_params.testing_workgroups) {\n`;\n\n/**\n * All test shaders must calculate addresses for memory locations used in the test. Not all these addresses are\n * used in every test, but no test uses more than these addresses.\n */\nconst testShaderCommonCalculations = `\n  let x_0 = id_0 * stress_params.mem_stride * 2u;\n  let y_0 = permute_id(id_0, stress_params.permute_second, total_ids) * stress_params.mem_stride * 2u + stress_params.location_offset;\n  let x_1 = id_1 * stress_params.mem_stride * 2u;\n  let y_1 = permute_id(id_1, stress_params.permute_second, total_ids) * stress_params.mem_stride * 2u + stress_params.location_offset;\n  if (stress_params.pre_stress == 1u) {\n    do_stress(stress_params.pre_stress_iterations, stress_params.pre_stress_pattern, shuffled_workgroup);\n  }\n`;\n\n/**\n * An inter-workgroup test calculates two sets of memory locations that are guaranteed to be in separate workgroups.\n * If the bounded spin-loop barrier is called, it attempts to wait for all invocations in all workgroups.\n */\nconst interWorkgroupTestShaderCode = [\n`\n  let total_ids = workgroupXSize * stress_params.testing_workgroups;\n  let id_0 = shuffled_workgroup * workgroupXSize + local_invocation_id[0];\n  let new_workgroup = stripe_workgroup(shuffled_workgroup, local_invocation_id[0]);\n  let id_1 = new_workgroup * workgroupXSize + permute_id(local_invocation_id[0], stress_params.permute_first, workgroupXSize);\n`,\ntestShaderCommonCalculations,\n`\n  if (stress_params.do_barrier == 1u) {\n    spin(workgroupXSize * stress_params.testing_workgroups);\n  }\n`].\njoin('\\n');\n\n/**\n * An intra-workgroup test calculates two set of memory locations that are guaranteed to be in the same workgroup.\n * If the bounded spin-loop barrier is called, it attempts to wait for all invocations in the same workgroup.\n */\nconst intraWorkgroupTestShaderCode = [\n`\n  let total_ids = workgroupXSize;\n  let id_0 = local_invocation_id[0];\n  let id_1 = permute_id(local_invocation_id[0], stress_params.permute_first, workgroupXSize);\n`,\ntestShaderCommonCalculations,\n`\n  if (stress_params.do_barrier == 1u) {\n    spin(workgroupXSize);\n  }\n`].\njoin('\\n');\n\n/**\n * Tests that operate on storage memory and communicate with invocations in the same workgroup must offset their locations\n * relative to global memory.\n */\nconst storageIntraWorkgroupTestShaderCode = `\n  let total_ids = workgroupXSize;\n  let id_0 = local_invocation_id[0];\n  let id_1 = permute_id(local_invocation_id[0], stress_params.permute_first, workgroupXSize);\n  let x_0 = (shuffled_workgroup * workgroupXSize + id_0) * stress_params.mem_stride * 2u;\n  let y_0 = (shuffled_workgroup * workgroupXSize + permute_id(id_0, stress_params.permute_second, total_ids)) * stress_params.mem_stride * 2u + stress_params.location_offset;\n  let x_1 = (shuffled_workgroup * workgroupXSize + id_1) * stress_params.mem_stride * 2u;\n  let y_1 = (shuffled_workgroup * workgroupXSize + permute_id(id_1, stress_params.permute_second, total_ids)) * stress_params.mem_stride * 2u + stress_params.location_offset;\n  if (stress_params.pre_stress == 1u) {\n    do_stress(stress_params.pre_stress_iterations, stress_params.pre_stress_pattern, shuffled_workgroup);\n  }\n  if (stress_params.do_barrier == 1u) {\n    spin(workgroupXSize);\n  }\n`;\n\n/** All test shaders may perform stress with non-testing threads. */\nconst testShaderCommonFooter = `\n    } else if (stress_params.mem_stress == 1u) {\n      do_stress(stress_params.mem_stress_iterations, stress_params.mem_stress_pattern, shuffled_workgroup);\n    }\n  }\n`;\n\n/**\n * All result shaders must calculate memory locations used in the test. Not all these locations are\n * used in every result shader, but no result shader uses more than these locations.\n *\n * Each value read from test_locations is converted from AccessValueTy to u32\n * before storing it in the read result.  This assumes u32(AccessValueTy)\n * is either an identity function u32(u32) or a value-converting overload such\n * as u32(f16).\n */\nconst resultShaderCommonCalculations = `\n  let id_0 = workgroup_id[0] * workgroupXSize + local_invocation_id[0];\n  let x_0 = id_0 * stress_params.mem_stride * 2u;\n  let mem_x_0 = u32(test_locations.value[x_0]);\n  let r0 = atomicLoad(&read_results.value[id_0].r0);\n  let r1 = atomicLoad(&read_results.value[id_0].r1);\n`;\n\n/** Common result shader code for an inter-workgroup test. */\nconst interWorkgroupResultShaderCode = [\nresultShaderCommonCalculations,\n`\n  let total_ids = workgroupXSize * stress_params.testing_workgroups;\n  let y_0 = permute_id(id_0, stress_params.permute_second, total_ids) * stress_params.mem_stride * 2u + stress_params.location_offset;\n  let mem_y_0 = u32(test_locations.value[y_0]);\n`].\njoin('\\n');\n\n/** Common result shader code for an intra-workgroup test. */\nconst intraWorkgroupResultShaderCode = [\nresultShaderCommonCalculations,\n`\n  let total_ids = workgroupXSize;\n  let y_0 = (workgroup_id[0] * workgroupXSize + permute_id(local_invocation_id[0], stress_params.permute_second, total_ids)) * stress_params.mem_stride * 2u + stress_params.location_offset;\n  let mem_y_0 = u32(test_locations.value[y_0]);\n`].\njoin('\\n');\n\n/** Ending bracket for result shaders. */\nconst resultShaderCommonFooter = `\n}\n`;\n\n/** The common shader code for test shaders that perform atomic storage class memory litmus tests. */\nconst storageMemoryAtomicTestShaderCode = [\nshaderMemStructures,\natomicTestShaderBindings,\nmemoryLocationFunctions,\ntestShaderFunctions,\nshaderEntryPoint,\ntestShaderCommonHeader].\njoin('\\n');\n\n/** The common shader code for test shaders that perform non-atomic storage class memory litmus tests. */\nconst storageMemoryNonAtomicTestShaderCode = [\nshaderMemStructures,\nnonAtomicTestShaderBindings,\nmemoryLocationFunctions,\ntestShaderFunctions,\nshaderEntryPoint,\ntestShaderCommonHeader].\njoin('\\n');\n\n/** The common shader code for the test shaders that perform non-atomic texture memory litmus tests. */\nconst textureMemoryNonAtomicTestShaderCode = [\nshaderMemStructures,\nnonAtomicTestShaderBindings,\ntextureBindings,\nmemoryLocationFunctions,\ntextureFunctions,\ntestShaderFunctions,\nshaderEntryPoint,\ntestShaderCommonHeader].\njoin('\\n');\n\n/** The common shader code for test shaders that perform atomic workgroup class memory litmus tests. */\nconst workgroupMemoryAtomicTestShaderCode = [\nshaderMemStructures,\natomicTestShaderBindings,\natomicWorkgroupMemory,\nmemoryLocationFunctions,\ntestShaderFunctions,\nshaderEntryPoint,\ntestShaderCommonHeader].\njoin('\\n');\n\n/** The common shader code for test shaders that perform non-atomic workgroup class memory litmus tests. */\nconst workgroupMemoryNonAtomicTestShaderCode = [\nshaderMemStructures,\nnonAtomicTestShaderBindings,\nnonAtomicWorkgroupMemory,\nmemoryLocationFunctions,\ntestShaderFunctions,\nshaderEntryPoint,\ntestShaderCommonHeader].\njoin('\\n');\n\n/** The common shader code for all result shaders. */\nconst resultShaderCommonCode = [\nshaderMemStructures,\nresultShaderBindings,\nmemoryLocationFunctions,\nshaderEntryPoint].\njoin('\\n');\n\n/**\n * Defines the types of possible memory a test is operating on. Used as part of the process of building shader code from\n * its composite parts.\n */\nexport let MemoryType = /*#__PURE__*/function (MemoryType) {MemoryType[\"AtomicStorageClass\"] = \"atomic_storage\";MemoryType[\"NonAtomicStorageClass\"] = \"non_atomic_storage\";MemoryType[\"AtomicWorkgroupClass\"] = \"atomic_workgroup\";MemoryType[\"NonAtomicWorkgroupClass\"] = \"non_atomic_workgroup\";MemoryType[\"NonAtomicTextureClass\"] = \"non_atomic_texture\";return MemoryType;}({});\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Defines the relative positions of two invocations coordinating on a test. Used as part of the process of building shader\n * code from its composite parts.\n */\nexport let TestType = /*#__PURE__*/function (TestType) {TestType[\"InterWorkgroup\"] = \"inter_workgroup\";TestType[\"IntraWorkgroup\"] = \"intra_workgroup\";return TestType;}({});\n\n\n\n\n\n\n/** Defines the number of behaviors a test may have. */\nexport let ResultType = /*#__PURE__*/function (ResultType) {ResultType[ResultType[\"TwoBehavior\"] = 0] = \"TwoBehavior\";ResultType[ResultType[\"FourBehavior\"] = 1] = \"FourBehavior\";return ResultType;}({});\n\n\n\n\n/**\n * Given test code that performs the actual sequence of loads and stores, as well as a memory type and test type, returns\n * a complete test shader.\n */\nexport function buildTestShader(\ntestCode,\nmemoryType,\ntestType)\n{\n  let memoryTypeCode;\n  let isGlobalSpace = false;\n  switch (memoryType) {\n    case MemoryType.AtomicStorageClass:\n      memoryTypeCode = storageMemoryAtomicTestShaderCode;\n      isGlobalSpace = true;\n      break;\n    case MemoryType.NonAtomicStorageClass:\n      memoryTypeCode = storageMemoryNonAtomicTestShaderCode;\n      isGlobalSpace = true;\n      break;\n    case MemoryType.AtomicWorkgroupClass:\n      memoryTypeCode = workgroupMemoryAtomicTestShaderCode;\n      break;\n    case MemoryType.NonAtomicWorkgroupClass:\n      memoryTypeCode = workgroupMemoryNonAtomicTestShaderCode;\n      break;\n    case MemoryType.NonAtomicTextureClass:\n      memoryTypeCode = textureMemoryNonAtomicTestShaderCode;\n      isGlobalSpace = true;\n      break;\n  }\n  let testTypeCode;\n  switch (testType) {\n    case TestType.InterWorkgroup:\n      testTypeCode = interWorkgroupTestShaderCode;\n      break;\n    case TestType.IntraWorkgroup:\n      if (isGlobalSpace) {\n        testTypeCode = storageIntraWorkgroupTestShaderCode;\n      } else {\n        testTypeCode = intraWorkgroupTestShaderCode;\n      }\n  }\n  return [memoryTypeCode, testTypeCode, testCode, testShaderCommonFooter].join('\\n');\n}\n\n/**\n * Given result code that aggregates the possible behaviors of a test across all instances, as well as a test type and\n * number of behaviors, returns a complete result shader.\n */\nexport function buildResultShader(\nresultCode,\ntestType,\nresultType)\n{\n  let resultStructure;\n  switch (resultType) {\n    case ResultType.TwoBehavior:\n      resultStructure = twoBehaviorTestResultStructure;\n      break;\n    case ResultType.FourBehavior:\n      resultStructure = fourBehaviorTestResultStructure;\n  }\n  let testTypeCode;\n  switch (testType) {\n    case TestType.InterWorkgroup:\n      testTypeCode = interWorkgroupResultShaderCode;\n      break;\n    case TestType.IntraWorkgroup:\n      testTypeCode = intraWorkgroupResultShaderCode;\n  }\n  return [\n  resultStructure,\n  resultShaderCommonCode,\n  testTypeCode,\n  resultCode,\n  resultShaderCommonFooter].\n  join('\\n');\n}"],"mappings":"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M,IAAI,CAACJ,mBAAmB,IAAIE,oBAAoB,EAAE;MACvDE,gBAAgB,GAAG,CAAC;IACtB,CAAC,MAAM;MACLA,gBAAgB,GAAG,CAAC;IACtB;IACAf,iBAAiB,CAAC1L,qBAAqB,CAAC,GAAGyM,gBAAgB;IAC3Df,iBAAiB,CAACzL,iBAAiB,CAAC,GAAG,IAAI,CAACY,MAAM,CAAC6L,YAAY;IAC/DhB,iBAAiB,CAACxL,kBAAkB,CAAC,GAAG,IAAI,CAACW,MAAM,CAAC8L,aAAa;IACjEjB,iBAAiB,CAACvL,sBAAsB,CAAC,GAAG,IAAI,CAACU,MAAM,CAACgB,iBAAiB;IACzE6J,iBAAiB,CAACtL,cAAc,CAAC,GAAG,IAAI,CAACS,MAAM,CAACkB,SAAS;IACzD,IAAI,IAAI,CAAClB,MAAM,CAAC+L,aAAa,EAAE;MAC7BlB,iBAAiB,CAACrL,sBAAsB,CAAC,GAAG,CAAC;IAC/C,CAAC,MAAM;MACLqL,iBAAiB,CAACrL,sBAAsB,CAAC,GAAG,IAAI,CAACQ,MAAM,CAACkB,SAAS;IACnE;IACA,IAAI,CAAC8C,OAAO,CAACO,YAAY,CAAC3C,MAAM,CAACkI,KAAK,CAAC,CAAC;EAC1C;AACF;;AAEA;AACA,MAAMkC,mBAAmB,GAAG;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,+BAA+B,GAAG;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,8BAA8B,GAAG;AACvC;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,MAAMC,wBAAwB,GAAG;AACjC;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,MAAMC,wBAAwB,GAAG;AACjC;AACA;AACA,CAAC;AACDD,wBAAwB,CAAC;AACzBE,IAAI,CAAC,IAAI,CAAC;;AAEV;AACA,MAAMC,2BAA2B,GAAG;AACpC;AACA;AACA,CAAC;AACDH,wBAAwB,CAAC;AACzBE,IAAI,CAAC,IAAI,CAAC;;AAEV;AACA,MAAME,eAAe,GAAG;AACxB;AACA,CAAC;;AAED;AACA,MAAMC,oBAAoB,GAAG;AAC7B;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,qBAAqB,GAAG;AAC9B;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,MAAMC,wBAAwB,GAAG;AACjC;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,MAAMC,uBAAuB,GAAG;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,MAAMC,gBAAgB,GAAG;AACzB,mBAAmBnO,MAAM;AACzB;AACA;AACA;AACA,CAAC;;AAED;AACA,MAAMoO,mBAAmB,GAAG;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,MAAMC,gBAAgB,GAAG;AACzB;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,MAAMC,sBAAsB,GAAG;AAC/B;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,MAAMC,4BAA4B,GAAG;AACrC;AACA;AACA;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","ignoreList":[]}