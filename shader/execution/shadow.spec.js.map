{"version":3,"file":"shadow.spec.js","names":["description","makeTestGroup","iterRange","GPUTest","g","runShaderTest","t","wgsl","expected","pipeline","device","createComputePipeline","layout","compute","module","createShaderModule","code","entryPoint","outputBuffer","makeBufferWithContents","Uint32Array","length","_i","GPUBufferUsage","STORAGE","COPY_SRC","bindGroup","createBindGroup","getBindGroupLayout","entries","binding","resource","buffer","encoder","globalThis","_TRAMPOLINE_","createCommandEncoder","pass","beginComputePass","setPipeline","setBindGroup","dispatchWorkgroups","end","queue","submit","finish","expectGPUBufferValuesEqual","test","desc","fn"],"sources":["../../../../src/webgpu/shader/execution/shadow.spec.ts"],"sourcesContent":["/**\n* AUTO-GENERATED - DO NOT EDIT. Source: https://github.com/gpuweb/cts\n**/export const description = `\nExecution Tests for shadowing\n`;import { makeTestGroup } from '../../../common/framework/test_group.js';\nimport { iterRange } from '../../../common/util/util.js';\nimport { GPUTest } from '../../gpu_test.js';\n\nexport const g = makeTestGroup(GPUTest);\n\n/**\n * Run a shader and check that the buffer output matches expectations.\n *\n * @param t The test object\n * @param wgsl The shader source\n * @param expected The array of expected values after running the shader\n */\nfunction runShaderTest(t, wgsl, expected) {\n  const pipeline = t.device.createComputePipeline({\n    layout: 'auto',\n    compute: {\n      module: t.device.createShaderModule({ code: wgsl }),\n      entryPoint: 'main'\n    }\n  });\n\n  // Allocate a buffer and fill it with 0xdeadbeef words.\n  const outputBuffer = t.makeBufferWithContents(\n    new Uint32Array([...iterRange(expected.length, (_i) => 0xdeadbeef)]),\n    GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC\n  );\n  const bindGroup = t.device.createBindGroup({\n    layout: pipeline.getBindGroupLayout(0),\n    entries: [{ binding: 0, resource: { buffer: outputBuffer } }]\n  });\n\n  // Run the shader.\n  const encoder = globalThis._TRAMPOLINE_(\"createCommandEncoder\", t.device, t.device.createCommandEncoder, [], () => t.device.createCommandEncoder());\n  const pass = encoder.beginComputePass();\n  pass.setPipeline(pipeline);\n  pass.setBindGroup(0, bindGroup);\n  pass.dispatchWorkgroups(1);\n  pass.end();\n  globalThis._TRAMPOLINE_(\"submit\", t, t.queue.submit, [[encoder.finish()]], () => t.queue.submit([encoder.finish()]));\n\n  // Check that only the non-padding bytes were modified.\n  t.expectGPUBufferValuesEqual(outputBuffer, expected);\n}\n\ng.test('declaration').\ndesc(`Test that shadowing is handled correctly`).\nfn((t) => {\n  const wgsl = `\n      struct S {\n        my_var_start: u32,\n        my_var_block_shadow: u32,\n        my_var_unshadow: u32,\n        my_var_param_shadow: u32,\n        my_var_param_reshadow: u32,\n        my_var_after_func: u32,\n\n        my_const_start: u32,\n        my_const_block_shadow: u32,\n        my_const_unshadow: u32,\n        my_const_param_shadow: u32,\n        my_const_param_reshadow: u32,\n        my_const_after_func: u32,\n\n        my_let_block_shadow: u32,\n        my_let_param_reshadow: u32,\n        my_let_after_func: u32,\n\n        my_func_param_shadow: u32,\n        my_func_shadow: u32,\n      }\n      @group(0) @binding(0) var<storage, read_write> buffer : S;\n\n      var<private> my_var: u32  = 1;\n      const my_const: u32 = 100;\n\n      @compute @workgroup_size(1)\n      fn main() {\n        let my_let = 200u;\n\n        buffer.my_var_start = my_var;  // 1\n        buffer.my_const_start = my_const;  // 100\n\n        {\n            var my_var: u32 = 10;\n            const my_const: u32 = 110;\n\n            buffer.my_var_block_shadow = my_var;  // 10\n            buffer.my_const_block_shadow = my_const;  // 110\n\n            let my_let = 210u;\n            buffer.my_let_block_shadow = my_let;  // 210\n        }\n\n        buffer.my_var_unshadow = my_var;  // 1\n        buffer.my_const_unshadow = my_const;  // 100\n\n        my_func(20, 120, my_let, 300);\n\n        buffer.my_var_after_func = my_var;  // 1\n        buffer.my_const_after_func = my_const;  // 100\n        buffer.my_let_after_func = my_let;  // 200;\n      };\n\n      // Note, defined after |main|\n      fn my_func(my_var: u32, my_const: u32, my_let: u32, my_func: u32) {\n        buffer.my_var_param_shadow = my_var;  // 20\n        buffer.my_const_param_shadow = my_const;  // 120\n\n        buffer.my_func_param_shadow = my_func; // 300\n\n        // Need block here because of scoping rules for parameters\n        {\n          var my_var = 30u;\n          const my_const = 130u;\n\n          buffer.my_var_param_reshadow = my_var; // 30\n          buffer.my_const_param_reshadow = my_const; // 130\n\n          let my_let = 220u;\n          buffer.my_let_param_reshadow = my_let; // 220\n\n          let my_func: u32 = 310;\n          buffer.my_func_shadow = my_func;  // 310\n        }\n      }\n    `;\n  runShaderTest(\n    t,\n    wgsl,\n    new Uint32Array([\n    // my_var\n    1, // my_var_start\n    10, // my_var_block_shadow\n    1, // my_var_unshadow\n    20, // my_var_param_shadow\n    30, // my_var_param_reshadow\n    1, // my_var_after_func\n    // my_const\n    100, // my_const_start\n    110, // my_const_block_shadow\n    100, // my_const_unshadow\n    120, // my_const_param_shadow\n    130, // my_const_param_reshadow\n    100, // my_const_after_func\n    // my_let\n    210, // my_let_block_shadow\n    220, // my_let_param_reshadow\n    200, // my_let_after_func\n    // my_func\n    300, // my_func_param_shadow\n    310 // my_func_shadow\n    ])\n  );\n});\n\ng.test('builtin').\ndesc(`Test that shadowing a builtin name is handled correctly`).\nfn((t) => {\n  const wgsl = `\n      struct S {\n        my_max_shadow: u32,\n        max_call: u32,\n      }\n      @group(0) @binding(0) var<storage, read_write> buffer : S;\n\n      @compute @workgroup_size(1)\n      fn main() {\n        let max = 400u;\n        buffer.my_max_shadow = max;\n\n        my_func();\n      };\n\n      fn my_func() {\n        buffer.max_call = max(310u, 410u);\n      }\n    `;\n  runShaderTest(\n    t,\n    wgsl,\n    new Uint32Array([\n    // my_max\n    400, // my_max_shadow\n    410 // max_call\n    ])\n  );\n});\n\ng.test('for_loop').\ndesc(`Test that shadowing is handled correctly with for loops`).\nfn((t) => {\n  const wgsl = `\n      struct S {\n        my_idx_before: u32,\n        my_idx_loop: array<u32, 2>,\n        my_idx_after: u32,\n      }\n      @group(0) @binding(0) var<storage, read_write> buffer : S;\n\n      @compute @workgroup_size(1)\n      fn main() {\n        var my_idx = 500u;\n        buffer.my_idx_before = my_idx; // 500;\n        for (var my_idx = 0u; my_idx < 2u; my_idx++) {\n          let pos = my_idx;\n          var my_idx = 501u + my_idx;\n          buffer.my_idx_loop[pos] = my_idx;  // 501, 502\n        }\n        buffer.my_idx_after = my_idx; // 500;\n      };\n    `;\n  runShaderTest(\n    t,\n    wgsl,\n    new Uint32Array([\n    500, // my_idx_before\n    501, // my_idx_loop[0]\n    502, // my_idx_loop[1]\n    500 // my_idx_after\n    ])\n  );\n});\n\ng.test('while').\ndesc(`Test that shadowing is handled correctly with while loops`).\nfn((t) => {\n  const wgsl = `\n      struct S {\n        my_idx_before: u32,\n        my_idx_loop: array<u32, 2>,\n        my_idx_after: u32,\n      }\n      @group(0) @binding(0) var<storage, read_write> buffer : S;\n\n      @compute @workgroup_size(1)\n      fn main() {\n        var my_idx = 0u;\n        buffer.my_idx_before = my_idx; // 0;\n\n        var counter = 0u;\n        while (counter < 2) {\n          var my_idx = 500u + counter;\n          buffer.my_idx_loop[counter] = my_idx;  // 500, 501\n\n          counter += 1;\n        }\n\n        buffer.my_idx_after = my_idx; // 1;\n      };\n    `;\n  runShaderTest(\n    t,\n    wgsl,\n    new Uint32Array([\n    0, // my_idx_before\n    500, // my_idx_loop[0]\n    501, // my_idx_loop[1]\n    0 // my_idx_after\n    ])\n  );\n});\n\ng.test('loop').\ndesc(`Test that shadowing is handled correctly with loops`).\nfn((t) => {\n  const wgsl = `\n      struct S {\n        my_idx_before: u32,\n        my_idx_loop: array<u32, 2>,\n        my_idx_continuing: array<u32, 2>,\n        my_idx_after: u32,\n      }\n      @group(0) @binding(0) var<storage, read_write> buffer : S;\n\n      @compute @workgroup_size(1)\n      fn main() {\n        var my_idx = 0u;\n        buffer.my_idx_before = my_idx; // 0;\n\n        var counter = 0u;\n        loop {\n          var my_idx = 500u + counter;\n          buffer.my_idx_loop[counter] = my_idx;  // 500, 501\n\n\n          continuing {\n            var my_idx = 600u + counter;\n            buffer.my_idx_continuing[counter] = my_idx; // 600, 601\n\n            counter += 1;\n            break if counter == 2;\n          }\n        }\n        buffer.my_idx_after = my_idx; // 1;\n      };\n    `;\n  runShaderTest(\n    t,\n    wgsl,\n    new Uint32Array([\n    0, // my_idx_before\n    500, // my_idx_loop[0]\n    501, // my_idx_loop[1]\n    600, // my_idx_continuing[0]\n    601, // my_idx_continuing[1]\n    0 // my_idx_after\n    ])\n  );\n});\n\ng.test('switch').\ndesc(`Test that shadowing is handled correctly with a switch`).\nfn((t) => {\n  const wgsl = `\n      struct S {\n        my_idx_before: u32,\n        my_idx_case: u32,\n        my_idx_default: u32,\n        my_idx_after: u32,\n      }\n      @group(0) @binding(0) var<storage, read_write> buffer : S;\n\n      @compute @workgroup_size(1)\n      fn main() {\n        var my_idx = 0u;\n        buffer.my_idx_before = my_idx; // 0;\n\n        for (var i = 0; i < 2; i++) {\n          switch (i) {\n            case 0: {\n              var my_idx = 10u;\n              buffer.my_idx_case = my_idx; // 10\n            }\n            default: {\n              var my_idx = 20u;\n              buffer.my_idx_default = my_idx; // 20\n            }\n          }\n        }\n\n        buffer.my_idx_after = my_idx; // 1;\n      };\n    `;\n  runShaderTest(\n    t,\n    wgsl,\n    new Uint32Array([\n    0, // my_idx_before\n    10, // my_idx_case\n    20, // my_idx_default\n    0 // my_idx_after\n    ])\n  );\n});\n\ng.test('if').\ndesc(`Test that shadowing is handled correctly with a switch`).\nfn((t) => {\n  const wgsl = `\n      struct S {\n        my_idx_before: u32,\n        my_idx_if: u32,\n        my_idx_elseif: u32,\n        my_idx_else: u32,\n        my_idx_after: u32,\n      }\n      @group(0) @binding(0) var<storage, read_write> buffer : S;\n\n      @compute @workgroup_size(1)\n      fn main() {\n        var my_idx = 0u;\n        buffer.my_idx_before = my_idx; // 0;\n\n        for (var i = 0; i < 3; i++) {\n          if i == 0 {\n            var my_idx = 10u;\n            buffer.my_idx_if = my_idx; // 10\n          } else if i == 1 {\n            var my_idx = 20u;\n            buffer.my_idx_elseif = my_idx; // 20\n          } else {\n            var my_idx = 30u;\n            buffer.my_idx_else = my_idx; // 30\n          }\n        }\n\n        buffer.my_idx_after = my_idx; // 1;\n      };\n    `;\n  runShaderTest(\n    t,\n    wgsl,\n    new Uint32Array([\n    0, // my_idx_before\n    10, // my_idx_if\n    20, // my_idx_elseif\n    30, // my_idx_else\n    0 // my_idx_after\n    ])\n  );\n});"],"mappings":"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A;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;EACHF,aAAa;IACXC,CAAC;IACDC,IAAI;IACJ,IAAIa,WAAW,CAAC;IAChB,CAAC,EAAE;IACH,GAAG,EAAE;IACL,GAAG,EAAE;IACL,CAAC,CAAC;IAAA,CACD;EACH,CAAC;AACH,CAAC,CAAC;;AAEFhB,CAAC,CAAC2C,IAAI,CAAC,MAAM,CAAC;AACdC,IAAI,CAAC,qDAAqD,CAAC;AAC3DC,EAAE,CAAC,CAAC3C,CAAC,KAAK;EACR,MAAMC,IAAI,GAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;EACHF,aAAa;IACXC,CAAC;IACDC,IAAI;IACJ,IAAIa,WAAW,CAAC;IAChB,CAAC,EAAE;IACH,GAAG,EAAE;IACL,GAAG,EAAE;IACL,GAAG,EAAE;IACL,GAAG,EAAE;IACL,CAAC,CAAC;IAAA,CACD;EACH,CAAC;AACH,CAAC,CAAC;;AAEFhB,CAAC,CAAC2C,IAAI,CAAC,QAAQ,CAAC;AAChBC,IAAI,CAAC,wDAAwD,CAAC;AAC9DC,EAAE,CAAC,CAAC3C,CAAC,KAAK;EACR,MAAMC,IAAI,GAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;EACHF,aAAa;IACXC,CAAC;IACDC,IAAI;IACJ,IAAIa,WAAW,CAAC;IAChB,CAAC,EAAE;IACH,EAAE,EAAE;IACJ,EAAE,EAAE;IACJ,CAAC,CAAC;IAAA,CACD;EACH,CAAC;AACH,CAAC,CAAC;;AAEFhB,CAAC,CAAC2C,IAAI,CAAC,IAAI,CAAC;AACZC,IAAI,CAAC,wDAAwD,CAAC;AAC9DC,EAAE,CAAC,CAAC3C,CAAC,KAAK;EACR,MAAMC,IAAI,GAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;EACHF,aAAa;IACXC,CAAC;IACDC,IAAI;IACJ,IAAIa,WAAW,CAAC;IAChB,CAAC,EAAE;IACH,EAAE,EAAE;IACJ,EAAE,EAAE;IACJ,EAAE,EAAE;IACJ,CAAC,CAAC;IAAA,CACD;EACH,CAAC;AACH,CAAC,CAAC","ignoreList":[]}