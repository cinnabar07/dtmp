{"version":3,"file":"case.js","names":["crc32","assert","abstractInt","i32","u32","VectorValue","cartesianProduct","quantizeToI32","quantizeToI64","quantizeToU32","notUndefined","value","undefined","selectNCases","dis","n","cases","Math","round","count","length","dis_crc32","filter","c","trunc","input","toString","makeScalarVectorBinaryToVectorCase","scalar","vector","op","quantize","scalarize","map","result","v","includes","expected","generateScalarVectorBinaryToVectorCases","scalars","vectors","flatMap","s","makeVectorScalarBinaryToVectorCase","generateVectorScalarBinaryToVectorCases","generateU32VectorBinaryToVectorCases","generateVectorU32BinaryToVectorCases","generateI32VectorBinaryToVectorCases","generateVectorI32BinaryToVectorCases","generateI64VectorBinaryToVectorCases","generateVectorI64BinaryToVectorCases","generateScalarBinaryToScalarCases","param0s","param1s","reduce","e","push","Array","generateBinaryToI32Cases","generateBinaryToU32Cases","generateBinaryToI64Cases","makeVectorVectorToScalarCase","param0","param1","param0_quantized","param1_quantized","generateVectorVectorToScalarCases","generateVectorVectorToI32Cases","generateVectorVectorToU32Cases","generateVectorVectorToI64Cases"],"sources":["../../../../../src/webgpu/shader/execution/expression/case.ts"],"sourcesContent":["/**\n* AUTO-GENERATED - DO NOT EDIT. Source: https://github.com/gpuweb/cts\n**/import { crc32 } from '../../../../common/util/crc32.js';import { assert } from '../../../../common/util/util.js';\nimport {\n  abstractInt,\n  i32,\n\n  u32,\n\n  VectorValue } from\n'../../../util/conversion.js';\nimport {\n  cartesianProduct,\n\n  quantizeToI32,\n  quantizeToI64,\n  quantizeToU32 } from\n'../../../util/math.js';\n\n\n\nfunction notUndefined(value) {\n  return value !== undefined;\n}\n\n/** Case is a single expression test case. */\n\n\n\n\n\n\n\n/**\n * Filters a given set of Cases down to a target number of cases by\n * randomly selecting which Cases to return.\n *\n * The selection algorithm is deterministic and stable for a case's\n * inputs.\n *\n * This means that if a specific case is selected is not affected by the\n * presence of other cases in the list, so in theory it is possible to create a\n * pathological set of cases such that all or not of the cases are selected\n * in spite of the target number.\n *\n * This is a trade-off from guaranteeing stability of the selected cases over\n * small changes, so the target number of cases is more of a suggestion. It is\n * still guaranteed that if you set n0 < n1, then the invocation with n0 will\n * return at most the number of cases that n1 does, it just isn't guaranteed to\n * be less.\n *\n * @param dis is a string provided for additional hashing information to avoid\n *            systemic bias in the selection process across different test\n *            suites. Specifically every Case with the same input values being\n *            included or skipped regardless of the operation that they are\n *            testing. This string should be something like the name of the case\n *            cache the values are for or the operation under test.\n * @param n number of cases targeted be returned. Expected to be a positive\n *          integer. If equal or greater than the number of cases, then all the\n *          cases are returned. 0 is not allowed, since it is likely a\n *          programming error, because if the caller intentionally wants 0\n *          items, they can just use [].\n * @param cases list of Cases to be selected from.\n */\nexport function selectNCases(dis, n, cases) {\n  assert(n > 0 && Math.round(n) === n, `n ${n} is expected to be a positive integer`);\n  const count = cases.length;\n  if (n >= count) {\n    return cases;\n  }\n  const dis_crc32 = crc32(dis);\n  return cases.filter(\n    (c) => Math.trunc(n / count * 0xffff_ffff) > (crc32(c.input.toString()) ^ dis_crc32) >>> 0\n  );\n}\n\n/**\n * A function that performs a binary operation on x and y, and returns the\n * expected result.\n */\n\n\n\n\n/**\n * A function that performs a vector-vector operation on x and y, and returns the\n * expected result.\n */\n\n\n\n\n/**\n * @returns a Case for the input params with op applied\n * @param scalar scalar param\n * @param vector vector param (2, 3, or 4 elements)\n * @param op the op to apply to scalar and vector\n * @param quantize function to quantize all values in vectors and scalars\n * @param scalarize function to convert numbers to Scalars\n */\nfunction makeScalarVectorBinaryToVectorCase(\nscalar,\nvector,\nop,\nquantize,\nscalarize)\n{\n  scalar = quantize(scalar);\n  vector = vector.map(quantize);\n  const result = vector.map((v) => op(scalar, v));\n  if (result.includes(undefined)) {\n    return undefined;\n  }\n  return {\n    input: [scalarize(scalar), new VectorValue(vector.map(scalarize))],\n    expected: new VectorValue(result.filter(notUndefined).map(scalarize))\n  };\n}\n\n/**\n * @returns array of Case for the input params with op applied\n * @param scalars array of scalar params\n * @param vectors array of vector params (2, 3, or 4 elements)\n * @param op the op to apply to each pair of scalar and vector\n * @param quantize function to quantize all values in vectors and scalars\n * @param scalarize function to convert numbers to Scalars\n */\nfunction generateScalarVectorBinaryToVectorCases(\nscalars,\nvectors,\nop,\nquantize,\nscalarize)\n{\n  return scalars.flatMap((s) => {\n    return vectors.\n    map((v) => {\n      return makeScalarVectorBinaryToVectorCase(s, v, op, quantize, scalarize);\n    }).\n    filter(notUndefined);\n  });\n}\n\n/**\n * @returns a Case for the input params with op applied\n * @param vector vector param (2, 3, or 4 elements)\n * @param scalar scalar param\n * @param op the op to apply to vector and scalar\n * @param quantize function to quantize all values in vectors and scalars\n * @param scalarize function to convert numbers to Scalars\n */\nfunction makeVectorScalarBinaryToVectorCase(\nvector,\nscalar,\nop,\nquantize,\nscalarize)\n{\n  vector = vector.map(quantize);\n  scalar = quantize(scalar);\n  const result = vector.map((v) => op(v, scalar));\n  if (result.includes(undefined)) {\n    return undefined;\n  }\n  return {\n    input: [new VectorValue(vector.map(scalarize)), scalarize(scalar)],\n    expected: new VectorValue(result.filter(notUndefined).map(scalarize))\n  };\n}\n\n/**\n * @returns array of Case for the input params with op applied\n * @param vectors array of vector params (2, 3, or 4 elements)\n * @param scalars array of scalar params\n * @param op the op to apply to each pair of vector and scalar\n * @param quantize function to quantize all values in vectors and scalars\n * @param scalarize function to convert numbers to Scalars\n */\nfunction generateVectorScalarBinaryToVectorCases(\nvectors,\nscalars,\nop,\nquantize,\nscalarize)\n{\n  return scalars.flatMap((s) => {\n    return vectors.\n    map((v) => {\n      return makeVectorScalarBinaryToVectorCase(v, s, op, quantize, scalarize);\n    }).\n    filter(notUndefined);\n  });\n}\n\n/**\n * @returns array of Case for the input params with op applied\n * @param scalars array of scalar params\n * @param vectors array of vector params (2, 3, or 4 elements)\n * @param op he op to apply to each pair of scalar and vector\n */\nexport function generateU32VectorBinaryToVectorCases(\nscalars,\nvectors,\nop)\n{\n  return generateScalarVectorBinaryToVectorCases(scalars, vectors, op, quantizeToU32, u32);\n}\n\n/**\n * @returns array of Case for the input params with op applied\n * @param vectors array of vector params (2, 3, or 4 elements)\n * @param scalars array of scalar params\n * @param op he op to apply to each pair of vector and scalar\n */\nexport function generateVectorU32BinaryToVectorCases(\nvectors,\nscalars,\nop)\n{\n  return generateVectorScalarBinaryToVectorCases(vectors, scalars, op, quantizeToU32, u32);\n}\n\n/**\n * @returns array of Case for the input params with op applied\n * @param scalars array of scalar params\n * @param vectors array of vector params (2, 3, or 4 elements)\n * @param op he op to apply to each pair of scalar and vector\n */\nexport function generateI32VectorBinaryToVectorCases(\nscalars,\nvectors,\nop)\n{\n  return generateScalarVectorBinaryToVectorCases(scalars, vectors, op, quantizeToI32, i32);\n}\n\n/**\n * @returns array of Case for the input params with op applied\n * @param vectors array of vector params (2, 3, or 4 elements)\n * @param scalars array of scalar params\n * @param op he op to apply to each pair of vector and scalar\n */\nexport function generateVectorI32BinaryToVectorCases(\nvectors,\nscalars,\nop)\n{\n  return generateVectorScalarBinaryToVectorCases(vectors, scalars, op, quantizeToI32, i32);\n}\n\n/**\n * @returns array of Case for the input params with op applied\n * @param scalars array of scalar params\n * @param vectors array of vector params (2, 3, or 4 elements)\n * @param op he op to apply to each pair of scalar and vector\n */\nexport function generateI64VectorBinaryToVectorCases(\nscalars,\nvectors,\nop)\n{\n  return generateScalarVectorBinaryToVectorCases(scalars, vectors, op, quantizeToI64, abstractInt);\n}\n\n/**\n * @returns array of Case for the input params with op applied\n * @param vectors array of vector params (2, 3, or 4 elements)\n * @param scalars array of scalar params\n * @param op he op to apply to each pair of vector and scalar\n */\nexport function generateVectorI64BinaryToVectorCases(\nvectors,\nscalars,\nop)\n{\n  return generateVectorScalarBinaryToVectorCases(vectors, scalars, op, quantizeToI64, abstractInt);\n}\n\n/**\n * @returns array of Case for the input params with op applied\n * @param param0s array of inputs to try for the first param\n * @param param1s array of inputs to try for the second param\n * @param op callback called on each pair of inputs to produce each case\n * @param quantize function to quantize all values\n * @param scalarize function to convert numbers to Scalars\n */\nfunction generateScalarBinaryToScalarCases(\nparam0s,\nparam1s,\nop,\nquantize,\nscalarize)\n{\n  param0s = param0s.map(quantize);\n  param1s = param1s.map(quantize);\n  return cartesianProduct(param0s, param1s).reduce((cases, e) => {\n    const expected = op(e[0], e[1]);\n    if (expected !== undefined) {\n      cases.push({ input: [scalarize(e[0]), scalarize(e[1])], expected: scalarize(expected) });\n    }\n    return cases;\n  }, new Array());\n}\n\n/**\n * @returns an array of Cases for operations over a range of inputs\n * @param param0s array of inputs to try for the first param\n * @param param1s array of inputs to try for the second param\n * @param op callback called on each pair of inputs to produce each case\n */\nexport function generateBinaryToI32Cases(\nparam0s,\nparam1s,\nop)\n{\n  return generateScalarBinaryToScalarCases(param0s, param1s, op, quantizeToI32, i32);\n}\n\n/**\n * @returns an array of Cases for operations over a range of inputs\n * @param param0s array of inputs to try for the first param\n * @param param1s array of inputs to try for the second param\n * @param op callback called on each pair of inputs to produce each case\n */\nexport function generateBinaryToU32Cases(\nparam0s,\nparam1s,\nop)\n{\n  return generateScalarBinaryToScalarCases(param0s, param1s, op, quantizeToU32, u32);\n}\n\n/**\n * @returns an array of Cases for operations over a range of inputs\n * @param param0s array of inputs to try for the first param\n * @param param1s array of inputs to try for the second param\n * @param op callback called on each pair of inputs to produce each case\n */\nexport function generateBinaryToI64Cases(\nparam0s,\nparam1s,\nop)\n{\n  return generateScalarBinaryToScalarCases(param0s, param1s, op, quantizeToI64, abstractInt);\n}\n\n/**\n * @returns a Case for the input params with op applied\n * @param param0 vector param (2, 3, or 4 elements) for the first param\n * @param param1 vector param (2, 3, or 4 elements) for the second param\n * @param op the op to apply to each pair of vectors\n * @param quantize function to quantize all values in vectors and scalars\n * @param scalarize function to convert numbers to Scalars\n */\nfunction makeVectorVectorToScalarCase(\nparam0,\nparam1,\nop,\nquantize,\nscalarize)\n{\n  const param0_quantized = param0.map(quantize);\n  const param1_quantized = param1.map(quantize);\n  const result = op(param0_quantized, param1_quantized);\n  if (result === undefined) return undefined;\n\n  return {\n    input: [\n    new VectorValue(param0_quantized.map(scalarize)),\n    new VectorValue(param1_quantized.map(scalarize))],\n\n    expected: scalarize(result)\n  };\n}\n\n/**\n * @returns array of Case for the input params with op applied\n * @param param0s array of vector params (2, 3, or 4 elements) for the first param\n * @param param1s array of vector params (2, 3, or 4 elements) for the second param\n * @param op the op to apply to each pair of vectors\n * @param quantize function to quantize all values in vectors and scalars\n * @param scalarize function to convert numbers to Scalars\n */\nfunction generateVectorVectorToScalarCases(\nparam0s,\nparam1s,\nop,\nquantize,\nscalarize)\n{\n  return param0s.flatMap((param0) => {\n    return param1s.\n    map((param1) => {\n      return makeVectorVectorToScalarCase(param0, param1, op, quantize, scalarize);\n    }).\n    filter(notUndefined);\n  });\n}\n\n/**\n * @returns array of Case for the input params with op applied\n * @param param0s array of vector params (2, 3, or 4 elements) for the first param\n * @param param1s array of vector params (2, 3, or 4 elements) for the second param\n * @param op the op to apply to each pair of vectors\n */\nexport function generateVectorVectorToI32Cases(\nparam0s,\nparam1s,\nop)\n{\n  return generateVectorVectorToScalarCases(param0s, param1s, op, quantizeToI32, i32);\n}\n\n/**\n * @returns array of Case for the input params with op applied\n * @param param0s array of vector params (2, 3, or 4 elements) for the first param\n * @param param1s array of vector params (2, 3, or 4 elements) for the second param\n * @param op the op to apply to each pair of vectors\n */\nexport function generateVectorVectorToU32Cases(\nparam0s,\nparam1s,\nop)\n{\n  return generateVectorVectorToScalarCases(param0s, param1s, op, quantizeToU32, u32);\n}\n\n/**\n * @returns array of Case for the input params with op applied\n * @param param0s array of vector params (2, 3, or 4 elements) for the first param\n * @param param1s array of vector params (2, 3, or 4 elements) for the second param\n * @param op the op to apply to each pair of vectors\n */\nexport function generateVectorVectorToI64Cases(\nparam0s,\nparam1s,\nop)\n{\n  return generateVectorVectorToScalarCases(param0s, param1s, op, quantizeToI64, abstractInt);\n}"],"mappings":"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","ignoreList":[]}