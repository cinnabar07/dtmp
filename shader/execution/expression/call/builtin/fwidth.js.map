{"version":3,"file":"fwidth.js","names":["anyOf","Type","toComparator","runFWidthTest","t","cases","builtin","non_uniform_discard","vectorize","vectorWidth","undefined","valueStride","wgslType","code","module","device","createShaderModule","pipeline","createRenderPipeline","layout","vertex","fragment","targets","format","writeMask","bufferSize","length","inputBuffer","createBufferTracked","size","usage","GPUBufferUsage","STORAGE","mappedAtCreation","outputBuffer","COPY_SRC","valuesData","Uint8Array","getMappedRange","i","v","index","inputs","input","x","copyTo","unmap","group","createBindGroup","entries","binding","resource","buffer","getBindGroupLayout","colorAttachment","createTextureTracked","width","height","GPUTextureUsage","RENDER_ATTACHMENT","encoder","globalThis","_TRAMPOLINE_","createCommandEncoder","pass","beginRenderPass","colorAttachments","view","createView","loadOp","storeOp","setPipeline","setBindGroup","quad","draw","end","queue","submit","finish","expectGPUBufferValuesPassCheck","outputData","c","result","f32","read","expected","endsWith","cmp","compare","matched","Error","join","type","typedLength"],"sources":["../../../../../../../src/webgpu/shader/execution/expression/call/builtin/fwidth.ts"],"sourcesContent":["/**\n* AUTO-GENERATED - DO NOT EDIT. Source: https://github.com/gpuweb/cts\n**/import { anyOf } from '../../../../../util/compare.js';import { Type } from '../../../../../util/conversion.js';\n\n\nimport { toComparator } from '../../expectation.js';\n\n/**\n * Run a test for a fwidth builtin function.\n * @param t the GPUTest\n * @param cases list of test cases to run\n * @param builtin the builtin function to test\n * @param non_uniform_discard if true, one of each pair of invocations will discard\n * @param vectorize if defined, the vector width to use (2, 3, or 4)\n */\nexport function runFWidthTest(\nt,\ncases,\nbuiltin,\nnon_uniform_discard,\nvectorize)\n{\n  ////////////////////////////////////////////////////////////////\n  // The four input values for a given case are distributed to across the invocations in a quad.\n  // We will populate a storage buffer with these input values laid out sequentially:\n  // [ case0_input0, case0_input1, case0_input2, case0_input3, ...]\n  //\n  // The render pipeline will be launched several times over a viewport size of (2, 2). Each draw\n  // call will execute a single quad (four fragment invocation), which will exercise one test case.\n  // Each of these draw calls will use a different instance index, which is forwarded to the\n  // fragment shader. Each invocation will determine its index into the storage buffer using its\n  // fragment position and the instance index for that draw call.\n  //\n  // Consider two draw calls that test 2 cases (c0, c1).\n  //\n  // The mapping from fragment position to case input is:\n  // Quad 0: | c0_i0 | c0_i1 |     Quad 1: | c1_i0 | c1_i1 |\n  //         | c0_i2 | c0_i3 |             | c1_i2 | c1_i3 |\n  //\n  ////////////////////////////////////////////////////////////////\n\n  // If the 'vectorize' config option was provided, pack the cases into vectors.\n  let vectorWidth = 1;\n  if (vectorize !== undefined) {\n    vectorWidth = vectorize;\n  }\n\n  // Determine the WGSL type to use in the shader, and the stride in bytes between values.\n  let valueStride = 4;\n  let wgslType = 'f32';\n  if (vectorize) {\n    wgslType = `vec${vectorize}f`;\n    valueStride = vectorize * 4;\n    if (vectorize === 3) {\n      valueStride = 16;\n    }\n  }\n\n  // Define a vertex shader that draws a triangle over the full viewport, and a fragment shader that\n  // calls the fwidth builtin with a value loaded from that fragment's index into the storage\n  // buffer (determined using the quad index and fragment position, as described above).\n  const code = `\nstruct CaseInfo {\n  @builtin(position) position: vec4f,\n  @location(0) @interpolate(flat, either) quad_idx: u32,\n}\n\n@vertex\nfn vert(@builtin(vertex_index) vertex_idx: u32,\n        @builtin(instance_index) instance_idx: u32) -> CaseInfo {\n  const kVertices = array(\n    vec2f(-2, -2),\n    vec2f( 2, -2),\n    vec2f( 0,  2),\n  );\n  return CaseInfo(vec4(kVertices[vertex_idx], 0, 1), instance_idx);\n}\n\n@group(0) @binding(0) var<storage, read> inputs : array<${wgslType}>;\n@group(0) @binding(1) var<storage, read_write> outputs : array<${wgslType}>;\n\n@fragment\nfn frag(info : CaseInfo) {\n  let inv_idx = u32(info.position.x) + u32(info.position.y)*2;\n  let index = info.quad_idx*4 + inv_idx;\n  let input = inputs[index];\n  ${non_uniform_discard ? 'if inv_idx == 0 { discard; }' : ''}\n  outputs[index] = ${builtin}(input);\n}\n`;\n\n  // Create the render pipeline.\n  const module = t.device.createShaderModule({ code });\n  const pipeline = t.device.createRenderPipeline({\n    layout: 'auto',\n    vertex: { module },\n    fragment: { module, targets: [{ format: 'rgba8unorm', writeMask: 0 }] }\n  });\n\n  // Create storage buffers to hold the inputs and outputs.\n  const bufferSize = cases.length * 4 * valueStride;\n  const inputBuffer = t.createBufferTracked({\n    size: bufferSize,\n    usage: GPUBufferUsage.STORAGE,\n    mappedAtCreation: true\n  });\n  const outputBuffer = t.createBufferTracked({\n    size: bufferSize,\n    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC\n  });\n\n  // Populate the input storage buffer with case input values.\n  const valuesData = new Uint8Array(inputBuffer.getMappedRange());\n  for (let i = 0; i < cases.length / vectorWidth; i++) {\n    for (let v = 0; v < vectorWidth; v++) {\n      const index = i * vectorWidth + v;\n      if (index >= cases.length) {\n        break;\n      }\n      const inputs = cases[index].input;\n      for (let x = 0; x < 4; x++) {\n        inputs[x].copyTo(valuesData, (i * 4 + x) * valueStride + v * 4);\n      }\n    }\n  }\n  inputBuffer.unmap();\n\n  // Create a bind group for the storage buffers.\n  const group = t.device.createBindGroup({\n    entries: [\n    { binding: 0, resource: { buffer: inputBuffer } },\n    { binding: 1, resource: { buffer: outputBuffer } }],\n\n    layout: pipeline.getBindGroupLayout(0)\n  });\n\n  // Create a texture to use as a color attachment.\n  // We only need this for launching the desired number of fragment invocations.\n  const colorAttachment = t.createTextureTracked({\n    size: { width: 2, height: 2 },\n    format: 'rgba8unorm',\n    usage: GPUTextureUsage.RENDER_ATTACHMENT\n  });\n\n  // Submit the render pass to the device.\n  const encoder = globalThis._TRAMPOLINE_(\"createCommandEncoder\", t.device, t.device.createCommandEncoder, [], () => t.device.createCommandEncoder());\n  const pass = encoder.beginRenderPass({\n    colorAttachments: [\n    {\n      view: colorAttachment.createView(),\n      loadOp: 'clear',\n      storeOp: 'discard'\n    }]\n\n  });\n  pass.setPipeline(pipeline);\n  pass.setBindGroup(0, group);\n  for (let quad = 0; quad < cases.length / vectorWidth; quad++) {\n    pass.draw(3, 1, undefined, quad);\n  }\n  pass.end();\n  globalThis._TRAMPOLINE_(\"submit\", t, t.queue.submit, [[encoder.finish()]], () => t.queue.submit([encoder.finish()]));\n\n  // Check the outputs match the expected results.\n  t.expectGPUBufferValuesPassCheck(\n    outputBuffer,\n    (outputData) => {\n      for (let i = 0; i < cases.length / vectorWidth; i++) {\n        for (let v = 0; v < vectorWidth; v++) {\n          const index = i * vectorWidth + v;\n          if (index >= cases.length) {\n            break;\n          }\n          const c = cases[index];\n\n          for (let x = 0; x < 4; x++) {\n            if (non_uniform_discard && x === 0) {\n              continue;\n            }\n\n            const index = (i * 4 + x) * valueStride + v * 4;\n            const result = Type.f32.read(outputData, index);\n\n            let expected = c.expected;\n            if (builtin.endsWith('Fine')) {\n              expected = toComparator(expected[x]);\n            } else {\n              expected = anyOf(...expected);\n            }\n\n            const cmp = expected.compare(result);\n            if (!cmp.matched) {\n              return new Error(`\n    inputs: (${c.input.join(', ')})\n  expected: ${cmp.expected}\n\n  returned: ${result}`);\n            }\n          }\n        }\n      }\n      return undefined;\n    },\n    {\n      type: Uint8Array,\n      typedLength: bufferSize\n    }\n  );\n}"],"mappings":"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","ignoreList":[]}