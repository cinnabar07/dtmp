{"version":3,"file":"atomicXor.spec.js","names":["description","makeTestGroup","keysOf","GPUTest","dispatchSizes","workgroupSizes","runStorageVariableTest","runWorkgroupVariableTest","kMapId","typedArrayCtor","g","test","specURL","desc","params","u","combine","fn","t","numInvocations","workgroupSize","dispatchSize","bufferNumElements","Math","max","initValue","scalarType","mapId","extra","wgsl","op","expected","fill","id","i","f","floor","wgNumElements","d","wg","subarray"],"sources":["../../../../../../../../src/webgpu/shader/execution/expression/call/builtin/atomics/atomicXor.spec.ts"],"sourcesContent":["/**\n* AUTO-GENERATED - DO NOT EDIT. Source: https://github.com/gpuweb/cts\n**/export const description = `\nAtomically read, xor and store value.\n\n* Load the original value pointed to by atomic_ptr.\n* Obtains a new value by xor'ing with the value v.\n* Store the new value using atomic_ptr.\n\nReturns the original value stored in the atomic object.\n`;import { makeTestGroup } from '../../../../../../../common/framework/test_group.js';\nimport { keysOf } from '../../../../../../../common/util/data_tables.js';\nimport { GPUTest } from '../../../../../../gpu_test.js';\n\nimport {\n  dispatchSizes,\n  workgroupSizes,\n  runStorageVariableTest,\n  runWorkgroupVariableTest,\n  kMapId,\n  typedArrayCtor } from\n'./harness.js';\n\nexport const g = makeTestGroup(GPUTest);\n\ng.test('xor_storage').\nspecURL('https://www.w3.org/TR/WGSL/#atomic-rmw').\ndesc(\n  `\nAS is storage or workgroup\nT is i32 or u32\n\nfn atomicXor(atomic_ptr: ptr<AS, atomic<T>, read_write>, v: T) -> T\n`\n).\nparams((u) =>\nu.\ncombine('workgroupSize', workgroupSizes).\ncombine('dispatchSize', dispatchSizes).\ncombine('mapId', keysOf(kMapId)).\ncombine('scalarType', ['u32', 'i32'])\n).\nfn((t) => {\n  const numInvocations = t.params.workgroupSize * t.params.dispatchSize;\n\n  // Allocate an output buffer with bitsize of max invocations plus 1 for validation\n  const bufferNumElements = Math.max(1, numInvocations / 32) + 1;\n\n  // Start with all bits set to some random value for each u32 in the buffer, then atomicXor each mapped global id bit.\n  // Note: Both WGSL and JS will shift left 1 by id modulo 32.\n  const initValue = 0b11000011010110100000111100111100;\n\n  const scalarType = t.params.scalarType;\n  const mapId = kMapId[t.params.mapId];\n  const extra = mapId.wgsl(numInvocations); // Defines map_id()\n  const op = `\n    let i = map_id(u32(id));\n      atomicXor(&output[i / 32], ${scalarType}(1) << i)\n    `;\n\n  const expected = new (typedArrayCtor(scalarType))(bufferNumElements).fill(initValue);\n  for (let id = 0; id < numInvocations; ++id) {\n    const i = mapId.f(id, numInvocations);\n    expected[Math.floor(i / 32)] ^= 1 << i;\n  }\n\n  runStorageVariableTest({\n    t,\n    workgroupSize: t.params.workgroupSize,\n    dispatchSize: t.params.dispatchSize,\n    bufferNumElements,\n    initValue,\n    op,\n    expected,\n    extra\n  });\n});\n\ng.test('xor_workgroup').\nspecURL('https://www.w3.org/TR/WGSL/#atomic-rmw').\ndesc(\n  `\nAS is storage or workgroup\nT is i32 or u32\n\nfn atomicXor(atomic_ptr: ptr<AS, atomic<T>, read_write>, v: T) -> T\n`\n).\nparams((u) =>\nu.\ncombine('workgroupSize', workgroupSizes).\ncombine('dispatchSize', dispatchSizes).\ncombine('mapId', keysOf(kMapId)).\ncombine('scalarType', ['u32', 'i32'])\n).\nfn((t) => {\n  const numInvocations = t.params.workgroupSize;\n\n  // Allocate workgroup array with bitsize of max invocations plus 1 for validation\n  const wgNumElements = Math.max(1, numInvocations / 32) + 1;\n\n  // Start with all bits set to some random value for each u32 in the buffer, then atomicXor each mapped global id bit.\n  // Note: Both WGSL and JS will shift left 1 by id modulo 32.\n  const initValue = 0b11000011010110100000111100111100;\n\n  const scalarType = t.params.scalarType;\n  const mapId = kMapId[t.params.mapId];\n  const extra = mapId.wgsl(numInvocations); // Defines map_id()\n  const op = `\n      let i = map_id(u32(id));\n      atomicXor(&wg[i / 32], ${scalarType}(1) << i)\n    `;\n\n  const expected = new (typedArrayCtor(scalarType))(wgNumElements * t.params.dispatchSize).fill(\n    initValue\n  );\n  for (let d = 0; d < t.params.dispatchSize; ++d) {\n    for (let id = 0; id < numInvocations; ++id) {\n      const wg = expected.subarray(d * wgNumElements);\n      const i = mapId.f(id, numInvocations);\n      wg[Math.floor(i / 32)] ^= 1 << i;\n    }\n  }\n\n  runWorkgroupVariableTest({\n    t,\n    workgroupSize: t.params.workgroupSize,\n    dispatchSize: t.params.dispatchSize,\n    wgNumElements,\n    initValue,\n    op,\n    expected,\n    extra\n  });\n});"],"mappings":"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","ignoreList":[]}