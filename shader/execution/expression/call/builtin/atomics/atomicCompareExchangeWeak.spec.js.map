{"version":3,"file":"atomicCompareExchangeWeak.spec.js","names":["description","makeTestGroup","keysOf","assert","GPUTest","dispatchSizes","workgroupSizes","typedArrayCtor","kMapId","onlyWorkgroupSizes","g","test","specURL","desc","params","u","combine","fn","t","numInvocations","workgroupSize","dispatchSize","bufferNumElements","scalarType","mapId","extra","wgsl","pipeline","device","createComputePipeline","layout","compute","module","createShaderModule","code","entryPoint","arrayType","inputBuffer","createBufferTracked","size","BYTES_PER_ELEMENT","usage","GPUBufferUsage","STORAGE","COPY_SRC","mappedAtCreation","data","getMappedRange","forEach","_","i","unmap","outputBuffer","exchangedBuffer","bindGroup","createBindGroup","getBindGroupLayout","entries","binding","resource","buffer","encoder","globalThis","_TRAMPOLINE_","createCommandEncoder","pass","beginComputePass","setPipeline","setBindGroup","dispatchWorkgroups","end","queue","submit","finish","outputExpected","expectGPUBufferValuesEqual","exchangedBufferResult","readGPUBufferRangeTyped","type","typedLength","inputExpected","f","wgNumElements","wgCopyBuffer","wgCopyBufferExpected","skipIf","limits","maxComputeWorkgroupSizeX","numWrites","pingPongValues","defaultValue","dataBuffer","oldValuesBuffer","fill","oldValuesBufferResult","w","offset","exchanged","subarray","oldValues","dumpValues","noExchanges","every","v","fail","filter","length","idx","findIndex","oldValue","oldValuesRest","includes"],"sources":["../../../../../../../../src/webgpu/shader/execution/expression/call/builtin/atomics/atomicCompareExchangeWeak.spec.ts"],"sourcesContent":["/**\n* AUTO-GENERATED - DO NOT EDIT. Source: https://github.com/gpuweb/cts\n**/export const description = `\nPerforms the following steps atomically:\n * Load the original value pointed to by atomic_ptr.\n * Compare the original value to the value v using an equality operation.\n * Store the value v only if the result of the equality comparison was true.\n\nReturns a two member structure, where the first member, old_value, is the original\nvalue of the atomic object and the second member, exchanged, is whether or not\nthe comparison succeeded.\n\nNote: the equality comparison may spuriously fail on some implementations.\nThat is, the second component of the result vector may be false even if the first\ncomponent of the result vector equals cmp.\n`;import { makeTestGroup } from '../../../../../../../common/framework/test_group.js';\nimport { keysOf } from '../../../../../../../common/util/data_tables.js';\nimport { assert } from '../../../../../../../common/util/util.js';\nimport { GPUTest } from '../../../../../../gpu_test.js';\n\nimport {\n  dispatchSizes,\n  workgroupSizes,\n  typedArrayCtor,\n  kMapId,\n  onlyWorkgroupSizes } from\n'./harness.js';\n\nexport const g = makeTestGroup(GPUTest);\n\ng.test('compare_exchange_weak_storage_basic').\nspecURL('https://www.w3.org/TR/WGSL/#atomic-rmw').\ndesc(\n  `\nAS is storage or workgroup\nT is i32 or u32\n\nfn atomicCompareExchangeWeak(atomic_ptr: ptr<AS, atomic<T>, read_write>, cmp: T, v: T) -> __atomic_compare_exchange_result<T>\n\nstruct __atomic_compare_exchange_result<T> {\n  old_value : T,    // old value stored in the atomic\n  exchanged : bool, // true if the exchange was done\n}\n`\n).\nparams((u) =>\nu.\ncombine('workgroupSize', workgroupSizes).\ncombine('dispatchSize', dispatchSizes).\ncombine('mapId', keysOf(kMapId)).\ncombine('scalarType', ['u32', 'i32'])\n).\nfn(async (t) => {\n  const numInvocations = t.params.workgroupSize * t.params.dispatchSize;\n  const bufferNumElements = numInvocations;\n  const scalarType = t.params.scalarType;\n  const mapId = kMapId[t.params.mapId];\n  const extra = mapId.wgsl(numInvocations, t.params.scalarType); // Defines map_id()\n\n  const wgsl =\n  `\n      @group(0) @binding(0)\n      var<storage, read_write> input : array<atomic<${scalarType}>>;\n\n      @group(0) @binding(1)\n      var<storage, read_write> output : array<${scalarType}>;\n\n      @group(0) @binding(2)\n      var<storage, read_write> exchanged : array<${scalarType}>;\n\n      @compute @workgroup_size(${t.params.workgroupSize})\n      fn main(\n          @builtin(global_invocation_id) global_invocation_id : vec3<u32>,\n          ) {\n        let id = ${scalarType}(global_invocation_id[0]);\n\n        // Exchange every third value\n        var comp = id + 1;\n        if (id % 3 == 0) {\n          comp = id;\n        }\n        let r = atomicCompareExchangeWeak(&input[id], comp, map_id(id * 2));\n\n        // Store results\n            output[id] = r.old_value;\n        if (r.exchanged) {\n          exchanged[id] = 1;\n        } else {\n          exchanged[id] = 0;\n        }\n      }\n    ` + extra;\n\n  const pipeline = t.device.createComputePipeline({\n    layout: 'auto',\n    compute: {\n      module: t.device.createShaderModule({ code: wgsl }),\n      entryPoint: 'main'\n    }\n  });\n\n  const arrayType = typedArrayCtor(scalarType);\n\n  // Create input buffer with values [0..n]\n  const inputBuffer = t.createBufferTracked({\n    size: bufferNumElements * arrayType.BYTES_PER_ELEMENT,\n    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n    mappedAtCreation: true\n  });\n  const data = new arrayType(inputBuffer.getMappedRange());\n  data.forEach((_, i) => data[i] = i);\n  inputBuffer.unmap();\n\n  const outputBuffer = t.createBufferTracked({\n    size: bufferNumElements * arrayType.BYTES_PER_ELEMENT,\n    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC\n  });\n\n  const exchangedBuffer = t.createBufferTracked({\n    size: bufferNumElements * arrayType.BYTES_PER_ELEMENT,\n    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC\n  });\n\n  const bindGroup = t.device.createBindGroup({\n    layout: pipeline.getBindGroupLayout(0),\n    entries: [\n    { binding: 0, resource: { buffer: inputBuffer } },\n    { binding: 1, resource: { buffer: outputBuffer } },\n    { binding: 2, resource: { buffer: exchangedBuffer } }]\n\n  });\n\n  // Run the shader.\n  const encoder = globalThis._TRAMPOLINE_(\"createCommandEncoder\", t.device, t.device.createCommandEncoder, [], () => t.device.createCommandEncoder());\n  const pass = encoder.beginComputePass();\n  pass.setPipeline(pipeline);\n  pass.setBindGroup(0, bindGroup);\n  pass.dispatchWorkgroups(t.params.dispatchSize);\n  pass.end();\n  globalThis._TRAMPOLINE_(\"submit\", t, t.queue.submit, [[encoder.finish()]], () => t.queue.submit([encoder.finish()]));\n\n  // Output buffer should be the same as the initial input buffer as it contains\n  // values returned from atomicCompareExchangeWeak\n  const outputExpected = new (typedArrayCtor(t.params.scalarType))(bufferNumElements);\n  outputExpected.forEach((_, i) => outputExpected[i] = i);\n  t.expectGPUBufferValuesEqual(outputBuffer, outputExpected);\n\n  // Read back exchanged buffer\n  const exchangedBufferResult = await t.readGPUBufferRangeTyped(exchangedBuffer, {\n    type: arrayType,\n    typedLength: exchangedBuffer.size / arrayType.BYTES_PER_ELEMENT\n  });\n\n  // The input buffer should have been modified to a computed value for every third value,\n  // unless the comparison spuriously failed.\n  const inputExpected = new (typedArrayCtor(t.params.scalarType))(bufferNumElements);\n  inputExpected.forEach((_, i) => {\n    if (i % 3 === 0 && exchangedBufferResult.data[i]) {\n      inputExpected[i] = mapId.f(i * 2, numInvocations);\n    } else {\n      inputExpected[i] = i; // No change\n    }\n  });\n  t.expectGPUBufferValuesEqual(inputBuffer, inputExpected);\n});\n\ng.test('compare_exchange_weak_workgroup_basic').\nspecURL('https://www.w3.org/TR/WGSL/#atomic-rmw').\ndesc(\n  `\nAS is storage or workgroup\nT is i32 or u32\n\nfn atomicCompareExchangeWeak(atomic_ptr: ptr<AS, atomic<T>, read_write>, cmp: T, v: T) -> __atomic_compare_exchange_result<T>\n\nstruct __atomic_compare_exchange_result<T> {\n  old_value : T,    // old value stored in the atomic\n  exchanged : bool, // true if the exchange was done\n}\n`\n).\nparams((u) =>\nu.\ncombine('workgroupSize', workgroupSizes).\ncombine('dispatchSize', dispatchSizes).\ncombine('mapId', keysOf(kMapId)).\ncombine('scalarType', ['u32', 'i32'])\n).\nfn(async (t) => {\n  const numInvocations = t.params.workgroupSize;\n  const wgNumElements = numInvocations;\n  const scalarType = t.params.scalarType;\n  const dispatchSize = t.params.dispatchSize;\n  const mapId = kMapId[t.params.mapId];\n  const extra = mapId.wgsl(numInvocations, t.params.scalarType); // Defines map_id()\n\n  const wgsl =\n  `\n      var<workgroup> wg: array<atomic<${scalarType}>, ${wgNumElements}>;\n\n      @group(0) @binding(0)\n      var<storage, read_write> output: array<${scalarType}, ${wgNumElements * dispatchSize}>;\n\n      @group(0) @binding(1)\n      var<storage, read_write> exchanged: array<${scalarType}, ${wgNumElements * dispatchSize}>;\n\n      // Result of each workgroup is written to output[workgroup_id.x]\n      @group(0) @binding(2)\n      var<storage, read_write> wg_copy: array<${scalarType}, ${wgNumElements * dispatchSize}>;\n\n      @compute @workgroup_size(${t.params.workgroupSize})\n      fn main(\n          @builtin(local_invocation_index) local_invocation_index: u32,\n          @builtin(workgroup_id) workgroup_id : vec3<u32>\n          ) {\n        let id = ${scalarType}(local_invocation_index);\n        let global_id = ${scalarType}(workgroup_id.x * ${wgNumElements} + local_invocation_index);\n\n        // Initialize wg[id] with this invocations global id\n        atomicStore(&wg[id], global_id);\n\n        // Exchange every third value\n        var comp = global_id + 1;\n        if (global_id % 3 == 0) {\n          comp = global_id;\n        }\n        let r = atomicCompareExchangeWeak(&wg[id], comp, map_id(global_id * 2));\n\n        // Store results\n        output[global_id] = r.old_value;\n        if (r.exchanged) {\n          exchanged[global_id] = 1;\n        } else {\n          exchanged[global_id] = 0;\n        }\n\n        // Copy new value into wg_copy\n        wg_copy[global_id] = atomicLoad(&wg[id]);\n      }\n      ` + extra;\n\n  const pipeline = t.device.createComputePipeline({\n    layout: 'auto',\n    compute: {\n      module: t.device.createShaderModule({ code: wgsl }),\n      entryPoint: 'main'\n    }\n  });\n\n  const arrayType = typedArrayCtor(scalarType);\n\n  const outputBuffer = t.createBufferTracked({\n    size: wgNumElements * dispatchSize * arrayType.BYTES_PER_ELEMENT,\n    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC\n  });\n\n  const wgCopyBuffer = t.createBufferTracked({\n    size: wgNumElements * dispatchSize * arrayType.BYTES_PER_ELEMENT,\n    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC\n  });\n\n  const exchangedBuffer = t.createBufferTracked({\n    size: wgNumElements * dispatchSize * arrayType.BYTES_PER_ELEMENT,\n    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC\n  });\n\n  const bindGroup = t.device.createBindGroup({\n    layout: pipeline.getBindGroupLayout(0),\n    entries: [\n    { binding: 0, resource: { buffer: outputBuffer } },\n    { binding: 1, resource: { buffer: exchangedBuffer } },\n    { binding: 2, resource: { buffer: wgCopyBuffer } }]\n\n  });\n\n  // Run the shader.\n  const encoder = globalThis._TRAMPOLINE_(\"createCommandEncoder\", t.device, t.device.createCommandEncoder, [], () => t.device.createCommandEncoder());\n  const pass = encoder.beginComputePass();\n  pass.setPipeline(pipeline);\n  pass.setBindGroup(0, bindGroup);\n  pass.dispatchWorkgroups(dispatchSize);\n  pass.end();\n  globalThis._TRAMPOLINE_(\"submit\", t, t.queue.submit, [[encoder.finish()]], () => t.queue.submit([encoder.finish()]));\n\n  // Output buffer should be the same as the initial wg buffer as it contains\n  // values returned from atomicCompareExchangeWeak\n  const outputExpected = new (typedArrayCtor(t.params.scalarType))(wgNumElements * dispatchSize);\n  outputExpected.forEach((_, i) => outputExpected[i] = i);\n  t.expectGPUBufferValuesEqual(outputBuffer, outputExpected);\n\n  // Read back exchanged buffer\n  const exchangedBufferResult = await t.readGPUBufferRangeTyped(exchangedBuffer, {\n    type: arrayType,\n    typedLength: exchangedBuffer.size / arrayType.BYTES_PER_ELEMENT\n  });\n\n  // And the wg copy buffer should have been modified to a computed value for every third value,\n  // unless the comparison spuriously failed.\n  const wgCopyBufferExpected = new (typedArrayCtor(t.params.scalarType))(\n    wgNumElements * dispatchSize\n  );\n  wgCopyBufferExpected.forEach((_, i) => {\n    if (i % 3 === 0 && exchangedBufferResult.data[i]) {\n      wgCopyBufferExpected[i] = mapId.f(i * 2, numInvocations);\n    } else {\n      wgCopyBufferExpected[i] = i; // No change\n    }\n  });\n  t.expectGPUBufferValuesEqual(wgCopyBuffer, wgCopyBufferExpected);\n});\n\ng.test('compare_exchange_weak_storage_advanced').\nspecURL('https://www.w3.org/TR/WGSL/#atomic-rmw').\ndesc(\n  `\nAS is storage or workgroup\nT is i32 or u32\n\nfn atomicCompareExchangeWeak(atomic_ptr: ptr<AS, atomic<T>, read_write>, cmp: T, v: T) -> __atomic_compare_exchange_result<T>\n\nstruct __atomic_compare_exchange_result<T> {\n  old_value : T,    // old value stored in the atomic\n  exchanged : bool, // true if the exchange was done\n}\n`\n).\nparams((u) =>\nu.\ncombine('workgroupSize', onlyWorkgroupSizes) //\n.combine('scalarType', ['u32', 'i32'])\n).\nfn(async (t) => {\n  const numInvocations = t.params.workgroupSize;\n  const scalarType = t.params.scalarType;\n\n  t.skipIf(\n    numInvocations > t.device.limits.maxComputeWorkgroupSizeX,\n    `${numInvocations} > maxComputeWorkgroupSizeX(${t.device.limits.maxComputeWorkgroupSizeX})`\n  );\n\n  // Number of times each workgroup attempts to exchange the same value to the same memory address\n  const numWrites = 4;\n\n  const bufferNumElements = numInvocations * numWrites;\n  const pingPongValues = [24, 68];\n\n  const wgsl = `\n      @group(0) @binding(0)\n      var<storage, read_write> data : atomic<${scalarType}>;\n\n      @group(0) @binding(1)\n      var<storage, read_write> old_values : array<${scalarType}>;\n\n      @group(0) @binding(2)\n      var<storage, read_write> exchanged : array<${scalarType}>;\n\n      fn ping_pong_value(i: u32) -> ${scalarType} {\n        if (i % 2 == 0) {\n          return ${pingPongValues[0]};\n        } else {\n          return ${pingPongValues[1]};\n        }\n      }\n\n      @compute @workgroup_size(${t.params.workgroupSize})\n      fn main(\n          @builtin(global_invocation_id) global_invocation_id : vec3<u32>,\n          ) {\n        let id = ${scalarType}(global_invocation_id[0]);\n\n        // Each invocation attempts to write an alternating (ping-pong) value, once per loop.\n        // The data value is initialized with the first of the two ping-pong values.\n        // Only one invocation per loop iteration should succeed. Note the workgroupBarrier() used\n        // to synchronize each invocation in the loop.\n        // The reason we alternate is in case atomicCompareExchangeWeak spurioulsy fails:\n        // If all invocations of one iteration spuriously fail, the very next iteration will also\n        // fail since the value will not have been exchanged; however, the subsequent one will succeed\n        // (assuming not all iterations spuriously fail yet again).\n\n        for (var i = 0u; i < ${numWrites}u; i++) {\n          let compare = ping_pong_value(i);\n          let next = ping_pong_value(i + 1);\n\n          let r = atomicCompareExchangeWeak(&data, compare, next);\n\n          let slot = i * ${numInvocations}u + u32(id);\n          old_values[slot] = r.old_value;\n          if (r.exchanged) {\n            exchanged[slot] = 1;\n          } else {\n            exchanged[slot] = 0;\n          }\n\n          workgroupBarrier();\n        }\n      }\n    `;\n\n  const pipeline = t.device.createComputePipeline({\n    layout: 'auto',\n    compute: {\n      module: t.device.createShaderModule({ code: wgsl }),\n      entryPoint: 'main'\n    }\n  });\n\n  const arrayType = typedArrayCtor(scalarType);\n  const defaultValue = 99999999;\n\n  // Create single-value data buffer initialized to the first ping-pong value\n  const dataBuffer = t.createBufferTracked({\n    size: 1 * arrayType.BYTES_PER_ELEMENT,\n    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n    mappedAtCreation: true\n  });\n  {\n    const data = new arrayType(dataBuffer.getMappedRange());\n    data[0] = pingPongValues[0];\n    dataBuffer.unmap();\n  }\n\n  const oldValuesBuffer = t.createBufferTracked({\n    size: bufferNumElements * arrayType.BYTES_PER_ELEMENT,\n    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n    mappedAtCreation: true\n  });\n  {\n    const data = new arrayType(oldValuesBuffer.getMappedRange());\n    data.fill(defaultValue);\n    oldValuesBuffer.unmap();\n  }\n\n  const exchangedBuffer = t.createBufferTracked({\n    size: bufferNumElements * arrayType.BYTES_PER_ELEMENT,\n    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n    mappedAtCreation: true\n  });\n  {\n    const data = new arrayType(exchangedBuffer.getMappedRange());\n    data.fill(defaultValue);\n    exchangedBuffer.unmap();\n  }\n\n  const bindGroup = t.device.createBindGroup({\n    layout: pipeline.getBindGroupLayout(0),\n    entries: [\n    { binding: 0, resource: { buffer: dataBuffer } },\n    { binding: 1, resource: { buffer: oldValuesBuffer } },\n    { binding: 2, resource: { buffer: exchangedBuffer } }]\n\n  });\n\n  // Run the shader.\n  const encoder = globalThis._TRAMPOLINE_(\"createCommandEncoder\", t.device, t.device.createCommandEncoder, [], () => t.device.createCommandEncoder());\n  const pass = encoder.beginComputePass();\n  pass.setPipeline(pipeline);\n  pass.setBindGroup(0, bindGroup);\n  pass.dispatchWorkgroups(1);\n  pass.end();\n  globalThis._TRAMPOLINE_(\"submit\", t, t.queue.submit, [[encoder.finish()]], () => t.queue.submit([encoder.finish()]));\n\n  // Read back buffers\n  const oldValuesBufferResult = (\n  await t.readGPUBufferRangeTyped(oldValuesBuffer, {\n    type: arrayType,\n    typedLength: oldValuesBuffer.size / arrayType.BYTES_PER_ELEMENT\n  })).\n  data;\n  const exchangedBufferResult = (\n  await t.readGPUBufferRangeTyped(exchangedBuffer, {\n    type: arrayType,\n    typedLength: exchangedBuffer.size / arrayType.BYTES_PER_ELEMENT\n  })).\n  data;\n\n  for (let w = 0; w < numWrites; ++w) {\n    const offset = w * numInvocations;\n    const exchanged = exchangedBufferResult.subarray(offset, offset + numInvocations);\n    const oldValues = oldValuesBufferResult.subarray(offset, offset + numInvocations);\n\n    const dumpValues = () => {\n      return `\n        For write: ${w}\n        exchanged: ${exchanged}\n        oldValues: ${oldValues}`;\n    };\n\n    // Only one of the invocations should have succeeded to exchange - or none if spurious failures occured\n    const noExchanges = exchanged.every((v) => v === 0);\n    if (noExchanges) {\n      // Spurious failure, all values in oldValues should be the default value\n      if (!oldValues.every((v) => v === defaultValue)) {\n        t.fail(\n          `Spurious failure detected, expected only default value of ${defaultValue} in oldValues buffer.${dumpValues()}`\n        );\n        return;\n      }\n    } else {\n      // Only one invocation should have exchanged its value\n      if (exchanged.filter((v) => v === 1).length !== 1) {\n        t.fail(`More than one invocation exchanged its value.${dumpValues()}`);\n        return;\n      }\n\n      // Get its index\n      const idx = exchanged.findIndex((v) => v === 1);\n      assert(idx !== -1);\n\n      // Its output should contain the old value after exchange\n      const oldValue = pingPongValues[w % 2];\n      if (oldValues[idx] !== oldValue) {\n        t.fail(\n          `oldValues[${idx}] expected to contain old value from exchange: ${oldValue}.${dumpValues()}'`\n        );\n        return;\n      }\n\n      // The rest of oldValues should either contain the old value or the newly exchanged value,\n      // depending on whether they executed atomicCompareExchangWeak before or after invocation 'idx'.\n      const oldValuesRest = oldValues.filter((_, i) => i !== idx);\n      if (!oldValuesRest.every((v) => pingPongValues.includes(v))) {\n        t.fail(\n          `Values in oldValues buffer should be one of '${pingPongValues}', except at index '${idx} where it is '${oldValue}'.${dumpValues()}`\n        );\n        return;\n      }\n    }\n  }\n});\n\ng.test('compare_exchange_weak_workgroup_advanced').\nspecURL('https://www.w3.org/TR/WGSL/#atomic-rmw').\ndesc(\n  `\nAS is storage or workgroup\nT is i32 or u32\n\nfn atomicCompareExchangeWeak(atomic_ptr: ptr<AS, atomic<T>, read_write>, cmp: T, v: T) -> __atomic_compare_exchange_result<T>\n\nstruct __atomic_compare_exchange_result<T> {\n  old_value : T,    // old value stored in the atomic\n  exchanged : bool, // true if the exchange was done\n}\n`\n).\nparams((u) =>\nu.\ncombine('workgroupSize', onlyWorkgroupSizes) //\n.combine('scalarType', ['u32', 'i32'])\n).\nfn(async (t) => {\n  const numInvocations = t.params.workgroupSize;\n  const scalarType = t.params.scalarType;\n\n  t.skipIf(\n    numInvocations > t.device.limits.maxComputeWorkgroupSizeX,\n    `${numInvocations} > maxComputeWorkgroupSizeX(${t.device.limits.maxComputeWorkgroupSizeX})`\n  );\n\n  // Number of times each workgroup attempts to exchange the same value to the same memory address\n  const numWrites = 4;\n\n  const bufferNumElements = numInvocations * numWrites;\n  const pingPongValues = [24, 68];\n\n  const wgsl = `\n      var<workgroup> wg: atomic<${scalarType}>;\n\n      @group(0) @binding(0)\n      var<storage, read_write> old_values : array<${scalarType}>;\n\n      @group(0) @binding(1)\n      var<storage, read_write> exchanged : array<${scalarType}>;\n\n      fn ping_pong_value(i: u32) -> ${scalarType} {\n        if (i % 2 == 0) {\n          return ${pingPongValues[0]};\n        } else {\n          return ${pingPongValues[1]};\n        }\n      }\n\n      @compute @workgroup_size(${t.params.workgroupSize})\n      fn main(\n        @builtin(local_invocation_index) local_invocation_index: u32,\n        @builtin(workgroup_id) workgroup_id : vec3<u32>\n        ) {\n          let id = ${scalarType}(local_invocation_index);\n\n        // Each invocation attempts to write an alternating (ping-pong) value, once per loop.\n        // The input value is initialized with the first of the two ping-pong values.\n        // Only one invocation per loop iteration should succeed. Note the workgroupBarrier() used\n        // to synchronize each invocation in the loop.\n        // The reason we alternate is in case atomicCompareExchangeWeak spurioulsy fails:\n        // If all invocations of one iteration spuriously fail, the very next iteration will also\n        // fail since the value will not have been exchanged; however, the subsequent one will succeed\n        // (assuming not all iterations spuriously fail yet again).\n\n        // Initialize wg\n        if (local_invocation_index == 0) {\n          atomicStore(&wg, ${pingPongValues[0]});\n        }\n        workgroupBarrier();\n\n        for (var i = 0u; i < ${numWrites}u; i++) {\n          let compare = ping_pong_value(i);\n          let next = ping_pong_value(i + 1);\n\n          let r = atomicCompareExchangeWeak(&wg, compare, next);\n\n          let slot = i * ${numInvocations}u + u32(id);\n          old_values[slot] = r.old_value;\n          if (r.exchanged) {\n            exchanged[slot] = 1;\n          } else {\n            exchanged[slot] = 0;\n          }\n\n          workgroupBarrier();\n        }\n      }\n    `;\n\n  const pipeline = t.device.createComputePipeline({\n    layout: 'auto',\n    compute: {\n      module: t.device.createShaderModule({ code: wgsl }),\n      entryPoint: 'main'\n    }\n  });\n\n  const arrayType = typedArrayCtor(scalarType);\n  const defaultValue = 99999999;\n\n  const oldValuesBuffer = t.createBufferTracked({\n    size: bufferNumElements * arrayType.BYTES_PER_ELEMENT,\n    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n    mappedAtCreation: true\n  });\n  {\n    const data = new arrayType(oldValuesBuffer.getMappedRange());\n    data.fill(defaultValue);\n    oldValuesBuffer.unmap();\n  }\n\n  const exchangedBuffer = t.createBufferTracked({\n    size: bufferNumElements * arrayType.BYTES_PER_ELEMENT,\n    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n    mappedAtCreation: true\n  });\n  {\n    const data = new arrayType(exchangedBuffer.getMappedRange());\n    data.fill(defaultValue);\n    exchangedBuffer.unmap();\n  }\n\n  const bindGroup = t.device.createBindGroup({\n    layout: pipeline.getBindGroupLayout(0),\n    entries: [\n    { binding: 0, resource: { buffer: oldValuesBuffer } },\n    { binding: 1, resource: { buffer: exchangedBuffer } }]\n\n  });\n\n  // Run the shader.\n  const encoder = globalThis._TRAMPOLINE_(\"createCommandEncoder\", t.device, t.device.createCommandEncoder, [], () => t.device.createCommandEncoder());\n  const pass = encoder.beginComputePass();\n  pass.setPipeline(pipeline);\n  pass.setBindGroup(0, bindGroup);\n  pass.dispatchWorkgroups(1);\n  pass.end();\n  globalThis._TRAMPOLINE_(\"submit\", t, t.queue.submit, [[encoder.finish()]], () => t.queue.submit([encoder.finish()]));\n\n  // Read back buffers\n  const oldValuesBufferResult = (\n  await t.readGPUBufferRangeTyped(oldValuesBuffer, {\n    type: arrayType,\n    typedLength: oldValuesBuffer.size / arrayType.BYTES_PER_ELEMENT\n  })).\n  data;\n  const exchangedBufferResult = (\n  await t.readGPUBufferRangeTyped(exchangedBuffer, {\n    type: arrayType,\n    typedLength: exchangedBuffer.size / arrayType.BYTES_PER_ELEMENT\n  })).\n  data;\n\n  for (let w = 0; w < numWrites; ++w) {\n    const offset = w * numInvocations;\n    const exchanged = exchangedBufferResult.subarray(offset, offset + numInvocations);\n    const oldValues = oldValuesBufferResult.subarray(offset, offset + numInvocations);\n\n    const dumpValues = () => {\n      return `\n        For write: ${w}\n        exchanged: ${exchanged}\n        oldValues: ${oldValues}`;\n    };\n\n    // Only one of the invocations should have succeeded to exchange - or none if spurious failures occured\n    const noExchanges = exchanged.every((v) => v === 0);\n    if (noExchanges) {\n      // Spurious failure, all values in oldValues should be the default value\n      if (!oldValues.every((v) => v === defaultValue)) {\n        t.fail(\n          `Spurious failure detected, expected only default value of ${defaultValue} in oldValues buffer.${dumpValues()}`\n        );\n        return;\n      }\n    } else {\n      // Only one invocation should have exchanged its value\n      if (exchanged.filter((v) => v === 1).length !== 1) {\n        t.fail(`More than one invocation exchanged its value.${dumpValues()}`);\n        return;\n      }\n\n      // Get its index\n      const idx = exchanged.findIndex((v) => v === 1);\n      assert(idx !== -1);\n\n      // Its output should contain the old value after exchange\n      const oldValue = pingPongValues[w % 2];\n      if (oldValues[idx] !== oldValue) {\n        t.fail(\n          `oldValues[${idx}] expected to contain old value from exchange: ${oldValue}.${dumpValues()}'`\n        );\n        return;\n      }\n\n      // The rest of oldValues should either contain the old value or the newly exchanged value,\n      // depending on whether they executed atomicCompareExchangWeak before or after invocation 'idx'.\n      const oldValuesRest = oldValues.filter((_, i) => i !== idx);\n      if (!oldValuesRest.every((v) => pingPongValues.includes(v))) {\n        t.fail(\n          `Values in oldValues buffer should be one of '${pingPongValues}', except at index '${idx} where it is '${oldValue}'.${dumpValues()}`\n        );\n        return;\n      }\n    }\n  }\n});"],"mappings":"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","ignoreList":[]}