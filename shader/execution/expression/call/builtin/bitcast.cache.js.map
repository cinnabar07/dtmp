{"version":3,"file":"bitcast.cache.js","names":["assert","alwaysPass","anyOf","kBit","kValue","VectorValue","f16","f32","i32","toVector","u32","abstractFloat","abstractInt","FP","FPInterval","cartesianProduct","fullI32Range","fullU32Range","isFiniteF16","isFiniteF32","isSubnormalNumberF16","isSubnormalNumberF32","linearRange","scalarF16Range","scalarF32Range","reinterpretF16AsU16","reinterpretF32AsI32","reinterpretF32AsU32","reinterpretI32AsF32","reinterpretI32AsU32","reinterpretU16AsF16","reinterpretU32AsF32","reinterpretU32AsI32","makeCaseCache","numNaNs","f32InfAndNaNInU32","positive","infinity","max","negative","f32InfAndNaNInF32","map","u","f32InfAndNaNInI32","f32ZerosInU32","zero","f32ZerosInF32","f32ZerosInI32","f32ZerosInterval","f32FiniteRange","f32RangeWithInfAndNaN","f16FiniteInF16","f16FiniteInU16","f16InfAndNaNInU16","v","Math","ceil","floor","f16InfAndNaNInF16","f16ZerosInU16","f16ZerosInterval","u16x2ToU32","u16x2","length","buffer","ArrayBuffer","view","DataView","setUint16","getUint32","u32ToU16x2","setUint32","getUint16","u16x2ToVec2F16","u16x4ToVec4F16","u16x4","canU32BitcastToFiniteVec2F16","u16","reduce","a","b","slidingSlice","input","len","result","i","sub","j","push","f16Vec2InfAndNaNInU32","f16Vec2InfAndNaNInI32","f16Vec2ZerosInU32","f16Vec2ZerosInI32","u32RangeForF16Vec2FiniteInfNaN","u32RangeForF16Vec2Finite","filter","i32RangeForF16Vec2FiniteInfNaN","i32RangeForF16Vec2Finite","f32RangeWithInfAndNaNForF16Vec2FiniteInfNaN","f32FiniteRangeForF16Vec2Finite","f16Vec2FiniteInU16x2","f16Vec2FiniteInfNanInU16x2","f16Vec2FiniteInU16x4","f16Vec2FiniteInfNanInU16x4","anyF32","anyI32","anyU32","f32UnboundedInterval","constants","unboundedInterval","f16UnboundedInterval","i32RangeForF32FiniteInfNaN","i32RangeForF32Finite","u32RangeForF32FiniteInfNaN","u32RangeForF32Finite","bitcastF32ToF32Comparator","f","acceptable","bitcastF32ToU32Comparator","bitcastF32ToI32Comparator","bitcastI32ToF32Comparator","includes","bitcastU32ToF32Comparator","generateF16ExpectationIntervals","bitcastedF16Value","exactInterval","toInterval","bitcastF16ToF16Comparator","bitcastU32ToVec2F16Comparator","bitcastedVec2F16InU16x2","expectedIntervalsCombination","bitcastI32ToVec2F16Comparator","bitcastF32ToVec2F16Comparator","bitcastVec2U32ToVec4F16Comparator","u32x2","bitcastedVec4F16InU16x4","flatMap","bitcastVec2I32ToVec4F16Comparator","i32x2","bitcastVec2F32ToVec4F16Comparator","f32x2","possibleBitsInU16FromFiniteF16InU16","f16InU16","h","possible32BitScalarIntervalsFromF16x2","f16x2InU16x2","type","reinterpretFromU32","expectationsForValue","unboundedExpectations","x","possibleExpectations","isUnbounded","possibleU16Bits","possibleBitsU16x2","bitcastVec2F16ToU32Comparator","vec2F16InU16x2","expectations","bitcastVec2F16ToI32Comparator","bitcastVec2F16ToF32Comparator","bitcastVec4F16ToVec2U32Comparator","vec4F16InU16x4","expectationsPerElement","slice","e","bitcastVec4F16ToVec2I32Comparator","bitcastVec4F16ToVec2F32Comparator","d","i32_to_i32","expected","u32_to_u32","f32_inf_nan_to_f32","f32_to_f32","f16_inf_nan_to_f16","f16_to_f16","i32_to_u32","i32_to_f32","ai_to_i32","BigInt","ai_to_u32","ai_to_f32","i32_to_f32_inf_nan","u32_to_i32","u32_to_f32","u32_to_f32_inf_nan","f32_inf_nan_to_i32","f32_to_i32","f32_inf_nan_to_u32","f32_to_u32","u32_to_vec2_f16_inf_nan","u32_to_vec2_f16","i32_to_vec2_f16_inf_nan","i32_to_vec2_f16","ai_to_vec2_f16","f32_inf_nan_to_vec2_f16_inf_nan","f32_to_vec2_f16","af_to_vec2_f16","vec2_i32_to_vec4_f16_inf_nan","vec2_i32_to_vec4_f16","vec2_ai_to_vec4_f16","n","vec2_u32_to_vec4_f16_inf_nan","vec2_u32_to_vec4_f16","vec2_f32_inf_nan_to_vec4_f16_inf_nan","vec2_f32_to_vec4_f16","vec2_af_to_vec4_f16","vec2_f16_to_u32","vec2_f16_inf_nan_to_u32","vec2_f16_to_i32","vec2_f16_inf_nan_to_i32","vec2_f16_to_f32_finite","vec2_f16_inf_nan_to_f32","vec4_f16_to_vec2_u32","vec4_f16_inf_nan_to_vec2_u32","vec4_f16_to_vec2_i32","vec4_f16_inf_nan_to_vec2_i32","vec4_f16_to_vec2_f32_finite","vec4_f16_inf_nan_to_vec2_f32"],"sources":["../../../../../../../src/webgpu/shader/execution/expression/call/builtin/bitcast.cache.ts"],"sourcesContent":["/**\n* AUTO-GENERATED - DO NOT EDIT. Source: https://github.com/gpuweb/cts\n**/import { assert } from '../../../../../../common/util/util.js';import { alwaysPass, anyOf } from '../../../../../util/compare.js';import { kBit, kValue } from '../../../../../util/constants.js';\nimport {\n\n  VectorValue,\n  f16,\n  f32,\n  i32,\n  toVector,\n  u32,\n  abstractFloat,\n  abstractInt } from\n'../../../../../util/conversion.js';\nimport { FP, FPInterval } from '../../../../../util/floating_point.js';\nimport {\n  cartesianProduct,\n  fullI32Range,\n  fullU32Range,\n  isFiniteF16,\n  isFiniteF32,\n  isSubnormalNumberF16,\n  isSubnormalNumberF32,\n  linearRange,\n  scalarF16Range,\n  scalarF32Range } from\n'../../../../../util/math.js';\nimport {\n  reinterpretF16AsU16,\n  reinterpretF32AsI32,\n  reinterpretF32AsU32,\n  reinterpretI32AsF32,\n  reinterpretI32AsU32,\n  reinterpretU16AsF16,\n  reinterpretU32AsF32,\n  reinterpretU32AsI32 } from\n'../../../../../util/reinterpret.js';\nimport { makeCaseCache } from '../../case_cache.js';\n\nconst numNaNs = 11;\nconst f32InfAndNaNInU32 = [\n// Cover NaNs evenly in integer space.\n// The positive NaN with the lowest integer representation is the integer\n// for infinity, plus one.\n// The positive NaN with the highest integer representation is i32.max (!)\n...linearRange(kBit.f32.positive.infinity + 1, kBit.i32.positive.max, numNaNs),\n// The negative NaN with the lowest integer representation is the integer\n// for negative infinity, plus one.\n// The negative NaN with the highest integer representation is u32.max (!)\n...linearRange(kBit.f32.negative.infinity + 1, kBit.u32.max, numNaNs),\nkBit.f32.positive.infinity,\nkBit.f32.negative.infinity];\n\nconst f32InfAndNaNInF32 = f32InfAndNaNInU32.map((u) => reinterpretU32AsF32(u));\nconst f32InfAndNaNInI32 = f32InfAndNaNInU32.map((u) => reinterpretU32AsI32(u));\n\nconst f32ZerosInU32 = [0, kBit.f32.negative.zero];\nconst f32ZerosInF32 = f32ZerosInU32.map((u) => reinterpretU32AsF32(u));\nconst f32ZerosInI32 = f32ZerosInU32.map((u) => reinterpretU32AsI32(u));\nconst f32ZerosInterval = new FPInterval('f32', -0.0, 0.0);\n\n// f32FiniteRange is a list of finite f32s. fullF32Range() already\n// has +0, we only need to add -0.\nconst f32FiniteRange = [...scalarF32Range(), kValue.f32.negative.zero];\nconst f32RangeWithInfAndNaN = [...f32FiniteRange, ...f32InfAndNaNInF32];\n\n// Type.f16 values, finite, Inf/NaN, and zeros. Represented in float and u16.\nconst f16FiniteInF16 = [...scalarF16Range(), kValue.f16.negative.zero];\nconst f16FiniteInU16 = f16FiniteInF16.map((u) => reinterpretF16AsU16(u));\n\nconst f16InfAndNaNInU16 = [\n// Cover NaNs evenly in integer space.\n// The positive NaN with the lowest integer representation is the integer\n// for infinity, plus one.\n// The positive NaN with the highest integer representation is u16 0x7fff i.e. 32767.\n...linearRange(kBit.f16.positive.infinity + 1, 32767, numNaNs).map((v) => Math.ceil(v)),\n// The negative NaN with the lowest integer representation is the integer\n// for negative infinity, plus one.\n// The negative NaN with the highest integer representation is u16 0xffff i.e. 65535\n...linearRange(kBit.f16.negative.infinity + 1, 65535, numNaNs).map((v) => Math.floor(v)),\nkBit.f16.positive.infinity,\nkBit.f16.negative.infinity];\n\nconst f16InfAndNaNInF16 = f16InfAndNaNInU16.map((u) => reinterpretU16AsF16(u));\n\nconst f16ZerosInU16 = [kBit.f16.negative.zero, 0];\n\n// f16 interval that match +/-0.0.\nconst f16ZerosInterval = new FPInterval('f16', -0.0, 0.0);\n\n/**\n * @returns an u32 whose lower and higher 16bits are the two elements of the\n * given array of two u16 respectively, in little-endian.\n */\nfunction u16x2ToU32(u16x2) {\n  assert(u16x2.length === 2);\n  // Create a DataView with 4 bytes buffer.\n  const buffer = new ArrayBuffer(4);\n  const view = new DataView(buffer);\n  // Enforce little-endian.\n  view.setUint16(0, u16x2[0], true);\n  view.setUint16(2, u16x2[1], true);\n  return view.getUint32(0, true);\n}\n\n/**\n * @returns an array of two u16, respectively the lower and higher 16bits of\n * given u32 in little-endian.\n */\nfunction u32ToU16x2(u32) {\n  // Create a DataView with 4 bytes buffer.\n  const buffer = new ArrayBuffer(4);\n  const view = new DataView(buffer);\n  // Enforce little-endian.\n  view.setUint32(0, u32, true);\n  return [view.getUint16(0, true), view.getUint16(2, true)];\n}\n\n/**\n * @returns a vec2<f16> from an array of two u16, each reinterpreted as f16.\n */\nfunction u16x2ToVec2F16(u16x2) {\n  assert(u16x2.length === 2);\n  return toVector(u16x2.map(reinterpretU16AsF16), f16);\n}\n\n/**\n * @returns a vec4<f16> from an array of four u16, each reinterpreted as f16.\n */\nfunction u16x4ToVec4F16(u16x4) {\n  assert(u16x4.length === 4);\n  return toVector(u16x4.map(reinterpretU16AsF16), f16);\n}\n\n/**\n * @returns true if and only if a given u32 can bitcast to a vec2<f16> with all elements\n * being finite f16 values.\n */\nfunction canU32BitcastToFiniteVec2F16(u32) {\n  return u32ToU16x2(u32).\n  map((u16) => isFiniteF16(reinterpretU16AsF16(u16))).\n  reduce((a, b) => a && b, true);\n}\n\n/**\n * @returns an array of N elements with the i-th element being an array of len elements\n * [a_i, a_((i+1)%N), ..., a_((i+len-1)%N)], for the input array of N element [a_1, ... a_N]\n * and the given len. For example, slidingSlice([1, 2, 3], 2) result in\n * [[1, 2], [2, 3], [3, 1]].\n * This helper function is used for generating vector cases from scalar values array.\n */\nfunction slidingSlice(input, len) {\n  const result = [];\n  for (let i = 0; i < input.length; i++) {\n    const sub = [];\n    for (let j = 0; j < len; j++) {\n      sub.push(input[(i + j) % input.length]);\n    }\n    result.push(sub);\n  }\n  return result;\n}\n\n// vec2<f16> interesting (zeros, Inf, and NaN) values for testing cases.\n// vec2<f16> values that has at least one Inf/NaN f16 element, reinterpreted as u32/i32.\nconst f16Vec2InfAndNaNInU32 = [\n...cartesianProduct(f16InfAndNaNInU16, [...f16InfAndNaNInU16, ...f16FiniteInU16]),\n...cartesianProduct(f16FiniteInU16, f16InfAndNaNInU16)].\nmap(u16x2ToU32);\nconst f16Vec2InfAndNaNInI32 = f16Vec2InfAndNaNInU32.map((u) => reinterpretU32AsI32(u));\n// vec2<f16> values with two f16 0.0 element, reinterpreted as u32/i32.\nconst f16Vec2ZerosInU32 = cartesianProduct(f16ZerosInU16, f16ZerosInU16).map(u16x2ToU32);\nconst f16Vec2ZerosInI32 = f16Vec2ZerosInU32.map((u) => reinterpretU32AsI32(u));\n\n// i32/u32/f32 range for bitcasting to vec2<f16>\n// u32 values for bitcasting to vec2<f16> finite, Inf, and NaN.\nconst u32RangeForF16Vec2FiniteInfNaN = [\n...fullU32Range(),\n...f16Vec2ZerosInU32,\n...f16Vec2InfAndNaNInU32];\n\n// u32 values for bitcasting to finite only vec2<f16>, used for constant evaluation.\nconst u32RangeForF16Vec2Finite = u32RangeForF16Vec2FiniteInfNaN.filter(\n  canU32BitcastToFiniteVec2F16\n);\n// i32 values for bitcasting to vec2<f16> finite, zeros, Inf, and NaN.\nconst i32RangeForF16Vec2FiniteInfNaN = [\n...fullI32Range(),\n...f16Vec2ZerosInI32,\n...f16Vec2InfAndNaNInI32];\n\n// i32 values for bitcasting to finite only vec2<f16>, used for constant evaluation.\nconst i32RangeForF16Vec2Finite = i32RangeForF16Vec2FiniteInfNaN.filter((u) =>\ncanU32BitcastToFiniteVec2F16(reinterpretI32AsU32(u))\n);\n// f32 values with finite/Inf/NaN f32, for bitcasting to vec2<f16> finite, zeros, Inf, and NaN.\nconst f32RangeWithInfAndNaNForF16Vec2FiniteInfNaN = [\n...f32RangeWithInfAndNaN,\n...u32RangeForF16Vec2FiniteInfNaN.map(reinterpretU32AsF32)];\n\n// Finite f32 values for bitcasting to finite only vec2<f16>, used for constant evaluation.\nconst f32FiniteRangeForF16Vec2Finite = f32RangeWithInfAndNaNForF16Vec2FiniteInfNaN.\nfilter(isFiniteF32).\nfilter((u) => canU32BitcastToFiniteVec2F16(reinterpretF32AsU32(u)));\n\n// vec2<f16> cases for bitcasting to i32/u32/f32, by combining f16 values into pairs\nconst f16Vec2FiniteInU16x2 = slidingSlice(f16FiniteInU16, 2);\nconst f16Vec2FiniteInfNanInU16x2 = slidingSlice([...f16FiniteInU16, ...f16InfAndNaNInU16], 2);\n// vec4<f16> cases for bitcasting to vec2<i32/u32/f32>, by combining f16 values 4-by-4\nconst f16Vec2FiniteInU16x4 = slidingSlice(f16FiniteInU16, 4);\nconst f16Vec2FiniteInfNanInU16x4 = slidingSlice([...f16FiniteInU16, ...f16InfAndNaNInU16], 4);\n\n// alwaysPass comparator for i32/u32/f32 cases. For f32/f16 we also use unbound interval, which\n// allow per-element unbounded expectation for vector.\nconst anyF32 = alwaysPass('any f32');\nconst anyI32 = alwaysPass('any i32');\nconst anyU32 = alwaysPass('any u32');\n\n// Unbounded FPInterval\nconst f32UnboundedInterval = FP.f32.constants().unboundedInterval;\nconst f16UnboundedInterval = FP.f16.constants().unboundedInterval;\n\n// i32 and u32 cases for bitcasting to f32.\n// i32 cases for bitcasting to f32 finite, zeros, Inf, and NaN.\nconst i32RangeForF32FiniteInfNaN = [\n...fullI32Range(),\n...f32ZerosInI32,\n...f32InfAndNaNInI32];\n\n// i32 cases for bitcasting to f32 finite only.\nconst i32RangeForF32Finite = i32RangeForF32FiniteInfNaN.filter((i) =>\nisFiniteF32(reinterpretI32AsF32(i))\n);\n// u32 cases for bitcasting to f32 finite, zeros, Inf, and NaN.\nconst u32RangeForF32FiniteInfNaN = [\n...fullU32Range(),\n...f32ZerosInU32,\n...f32InfAndNaNInU32];\n\n// u32 cases for bitcasting to f32 finite only.\nconst u32RangeForF32Finite = u32RangeForF32FiniteInfNaN.filter((u) =>\nisFiniteF32(reinterpretU32AsF32(u))\n);\n\n/**\n * @returns a Comparator for checking if a f32 value is a valid\n * bitcast conversion from f32.\n */\nfunction bitcastF32ToF32Comparator(f) {\n  if (!isFiniteF32(f)) return anyF32;\n  const acceptable = [f, ...(isSubnormalNumberF32(f) ? f32ZerosInF32 : [])];\n  return anyOf(...acceptable.map(f32));\n}\n\n/**\n * @returns a Comparator for checking if a u32 value is a valid\n * bitcast conversion from f32.\n */\nfunction bitcastF32ToU32Comparator(f) {\n  if (!isFiniteF32(f)) return anyU32;\n  const acceptable = [\n  reinterpretF32AsU32(f),\n  ...(isSubnormalNumberF32(f) ? f32ZerosInU32 : [])];\n\n  return anyOf(...acceptable.map(u32));\n}\n\n/**\n * @returns a Comparator for checking if a i32 value is a valid\n * bitcast conversion from f32.\n */\nfunction bitcastF32ToI32Comparator(f) {\n  if (!isFiniteF32(f)) return anyI32;\n  const acceptable = [\n  reinterpretF32AsI32(f),\n  ...(isSubnormalNumberF32(f) ? f32ZerosInI32 : [])];\n\n  return anyOf(...acceptable.map(i32));\n}\n\n/**\n * @returns a Comparator for checking if a f32 value is a valid\n * bitcast conversion from i32.\n */\nfunction bitcastI32ToF32Comparator(i) {\n  const f = reinterpretI32AsF32(i);\n  if (!isFiniteF32(f)) return anyI32;\n  // Positive or negative zero bit pattern map to any zero.\n  if (f32ZerosInI32.includes(i)) return anyOf(...f32ZerosInF32.map(f32));\n  const acceptable = [f, ...(isSubnormalNumberF32(f) ? f32ZerosInF32 : [])];\n  return anyOf(...acceptable.map(f32));\n}\n\n/**\n * @returns a Comparator for checking if a f32 value is a valid\n * bitcast conversion from u32.\n */\nfunction bitcastU32ToF32Comparator(u) {\n  const f = reinterpretU32AsF32(u);\n  if (!isFiniteF32(f)) return anyU32;\n  // Positive or negative zero bit pattern map to any zero.\n  if (f32ZerosInU32.includes(u)) return anyOf(...f32ZerosInF32.map(f32));\n  const acceptable = [f, ...(isSubnormalNumberF32(f) ? f32ZerosInF32 : [])];\n  return anyOf(...acceptable.map(f32));\n}\n\n/**\n * @returns an array of expected f16 FPInterval for the given bitcasted f16 value, which may be\n * subnormal, Inf, or NaN. Test cases that bitcasted to vector of f16 use this function to get\n * per-element expectation and build vector expectation using cartesianProduct.\n */\nfunction generateF16ExpectationIntervals(bitcastedF16Value) {\n  // If the bitcasted f16 value is inf or nan, the result is unbounded\n  if (!isFiniteF16(bitcastedF16Value)) {\n    return [f16UnboundedInterval];\n  }\n  // If the casted f16 value is +/-0.0, the result can be one of both. Note that in JS -0.0 === 0.0.\n  if (bitcastedF16Value === 0.0) {\n    return [f16ZerosInterval];\n  }\n  const exactInterval = FP.f16.toInterval(bitcastedF16Value);\n  // If the casted f16 value is subnormal, it also may be flushed to +/-0.0.\n  return [exactInterval, ...(isSubnormalNumberF16(bitcastedF16Value) ? [f16ZerosInterval] : [])];\n}\n\n/**\n * @returns a Comparator for checking if a f16 value is a valid\n * bitcast conversion from f16.\n */\nfunction bitcastF16ToF16Comparator(f) {\n  if (!isFiniteF16(f)) return anyOf(f16UnboundedInterval);\n  return anyOf(...generateF16ExpectationIntervals(f));\n}\n\n/**\n * @returns a Comparator for checking if a vec2<f16> is a valid bitcast\n * conversion from u32.\n */\nfunction bitcastU32ToVec2F16Comparator(u) {\n  const bitcastedVec2F16InU16x2 = u32ToU16x2(u).map(reinterpretU16AsF16);\n  // Generate expection for vec2 f16 result, by generating expected intervals for each elements and\n  // then do cartesian product.\n  const expectedIntervalsCombination = cartesianProduct(\n    ...bitcastedVec2F16InU16x2.map(generateF16ExpectationIntervals)\n  );\n  return anyOf(...expectedIntervalsCombination);\n}\n\n/**\n * @returns a Comparator for checking if a vec2<f16> value is a valid\n * bitcast conversion from i32.\n */\nfunction bitcastI32ToVec2F16Comparator(i) {\n  const bitcastedVec2F16InU16x2 = u32ToU16x2(reinterpretI32AsU32(i)).map(reinterpretU16AsF16);\n  // Generate expection for vec2 f16 result, by generating expected intervals for each elements and\n  // then do cartesian product.\n  const expectedIntervalsCombination = cartesianProduct(\n    ...bitcastedVec2F16InU16x2.map(generateF16ExpectationIntervals)\n  );\n  return anyOf(...expectedIntervalsCombination);\n}\n\n/**\n * @returns a Comparator for checking if a vec2<f16> value is a valid\n * bitcast conversion from f32.\n */\nfunction bitcastF32ToVec2F16Comparator(f) {\n  // If input f32 is not finite, it can be evaluated to any value and thus any result f16 vec2 is\n  // possible.\n  if (!isFiniteF32(f)) {\n    return anyOf([f16UnboundedInterval, f16UnboundedInterval]);\n  }\n  const bitcastedVec2F16InU16x2 = u32ToU16x2(reinterpretF32AsU32(f)).map(reinterpretU16AsF16);\n  // Generate expection for vec2 f16 result, by generating expected intervals for each elements and\n  // then do cartesian product.\n  const expectedIntervalsCombination = cartesianProduct(\n    ...bitcastedVec2F16InU16x2.map(generateF16ExpectationIntervals)\n  );\n  return anyOf(...expectedIntervalsCombination);\n}\n\n/**\n * @returns a Comparator for checking if a vec4<f16> is a valid\n * bitcast conversion from vec2<u32>.\n */\nfunction bitcastVec2U32ToVec4F16Comparator(u32x2) {\n  assert(u32x2.length === 2);\n  const bitcastedVec4F16InU16x4 = u32x2.flatMap(u32ToU16x2).map(reinterpretU16AsF16);\n  // Generate expection for vec4 f16 result, by generating expected intervals for each elements and\n  // then do cartesian product.\n  const expectedIntervalsCombination = cartesianProduct(\n    ...bitcastedVec4F16InU16x4.map(generateF16ExpectationIntervals)\n  );\n  return anyOf(...expectedIntervalsCombination);\n}\n\n/**\n * @returns a Comparator for checking if a vec4<f16> is a valid\n * bitcast conversion from vec2<i32>.\n */\nfunction bitcastVec2I32ToVec4F16Comparator(i32x2) {\n  assert(i32x2.length === 2);\n  const bitcastedVec4F16InU16x4 = i32x2.\n  map(reinterpretI32AsU32).\n  flatMap(u32ToU16x2).\n  map(reinterpretU16AsF16);\n  // Generate expection for vec4 f16 result, by generating expected intervals for each elements and\n  // then do cartesian product.\n  const expectedIntervalsCombination = cartesianProduct(\n    ...bitcastedVec4F16InU16x4.map(generateF16ExpectationIntervals)\n  );\n  return anyOf(...expectedIntervalsCombination);\n}\n\n/**\n * @returns a Comparator for checking if a vec4<f16> is a valid\n * bitcast conversion from vec2<f32>.\n */\nfunction bitcastVec2F32ToVec4F16Comparator(f32x2) {\n  assert(f32x2.length === 2);\n  const bitcastedVec4F16InU16x4 = f32x2.\n  map(reinterpretF32AsU32).\n  flatMap(u32ToU16x2).\n  map(reinterpretU16AsF16);\n  // Generate expection for vec4 f16 result, by generating expected intervals for each elements and\n  // then do cartesian product.\n  const expectedIntervalsCombination = cartesianProduct(\n    ...bitcastedVec4F16InU16x4.map(generateF16ExpectationIntervals)\n  );\n  return anyOf(...expectedIntervalsCombination);\n}\n\n// Structure that store the expectations of a single 32bit scalar/element bitcasted from two f16.\n\n\n\n\n\n\n\n/**\n * @returns the array of possible 16bits, represented in u16, that bitcasted\n * from a given finite f16 represented in u16, handling the possible subnormal\n * flushing. Used to build up 32bits or larger results.\n */\nfunction possibleBitsInU16FromFiniteF16InU16(f16InU16) {\n  const h = reinterpretU16AsF16(f16InU16);\n  assert(isFiniteF16(h));\n  return [f16InU16, ...(isSubnormalNumberF16(h) ? f16ZerosInU16 : [])];\n}\n\n/**\n * @returns the expectation for a single 32bit scalar bitcasted from given pair of\n * f16, result in ExpectionFor32BitsScalarFromF16x2.\n */\nfunction possible32BitScalarIntervalsFromF16x2(\nf16x2InU16x2,\ntype)\n{\n  assert(f16x2InU16x2.length === 2);\n  let reinterpretFromU32;\n  let expectationsForValue;\n  let unboundedExpectations;\n  if (type === 'u32') {\n    reinterpretFromU32 = (x) => x;\n    expectationsForValue = (x) => [u32(x)];\n    // Scalar expectation can not express \"unbounded\" for i32 and u32, so use 0 here as a\n    // placeholder, and the possibleExpectations should be ignored if the result is unbounded.\n    unboundedExpectations = [u32(0)];\n  } else if (type === 'i32') {\n    reinterpretFromU32 = (x) => reinterpretU32AsI32(x);\n    expectationsForValue = (x) => [i32(x)];\n    // Scalar expectation can not express \"unbounded\" for i32 and u32, so use 0 here as a\n    // placeholder, and the possibleExpectations should be ignored if the result is unbounded.\n    unboundedExpectations = [i32(0)];\n  } else {\n    assert(type === 'f32');\n    reinterpretFromU32 = (x) => reinterpretU32AsF32(x);\n    expectationsForValue = (x) => {\n      // Handle the possible Inf/NaN/zeros and subnormal cases for f32 result.\n      if (!isFiniteF32(x)) {\n        return [f32UnboundedInterval];\n      }\n      // If the casted f16 value is +/-0.0, the result can be one of both. Note that in JS -0.0 === 0.0.\n      if (x === 0.0) {\n        return [f32ZerosInterval];\n      }\n      const exactInterval = FP.f32.toInterval(x);\n      // If the casted f16 value is subnormal, it also may be flushed to +/-0.0.\n      return [exactInterval, ...(isSubnormalNumberF32(x) ? [f32ZerosInterval] : [])];\n    };\n    unboundedExpectations = [f32UnboundedInterval];\n  }\n  // Return unbounded expection if f16 Inf/NaN occurs\n  if (\n  !isFiniteF16(reinterpretU16AsF16(f16x2InU16x2[0])) ||\n  !isFiniteF16(reinterpretU16AsF16(f16x2InU16x2[1])))\n  {\n    return { possibleExpectations: unboundedExpectations, isUnbounded: true };\n  }\n  const possibleU16Bits = f16x2InU16x2.map(possibleBitsInU16FromFiniteF16InU16);\n  const possibleExpectations = cartesianProduct(...possibleU16Bits).flatMap(\n\n    (possibleBitsU16x2) => {\n      assert(possibleBitsU16x2.length === 2);\n      return expectationsForValue(reinterpretFromU32(u16x2ToU32(possibleBitsU16x2)));\n    });\n  return { possibleExpectations, isUnbounded: false };\n}\n\n/**\n * @returns a Comparator for checking if a u32 value is a valid\n * bitcast conversion from vec2 f16.\n */\nfunction bitcastVec2F16ToU32Comparator(vec2F16InU16x2) {\n  assert(vec2F16InU16x2.length === 2);\n  const expectations = possible32BitScalarIntervalsFromF16x2(vec2F16InU16x2, 'u32');\n  // Return alwaysPass if result is expected unbounded.\n  if (expectations.isUnbounded) {\n    return anyU32;\n  }\n  return anyOf(...expectations.possibleExpectations);\n}\n\n/**\n * @returns a Comparator for checking if a i32 value is a valid\n * bitcast conversion from vec2 f16.\n */\nfunction bitcastVec2F16ToI32Comparator(vec2F16InU16x2) {\n  assert(vec2F16InU16x2.length === 2);\n  const expectations = possible32BitScalarIntervalsFromF16x2(vec2F16InU16x2, 'i32');\n  // Return alwaysPass if result is expected unbounded.\n  if (expectations.isUnbounded) {\n    return anyI32;\n  }\n  return anyOf(...expectations.possibleExpectations);\n}\n\n/**\n * @returns a Comparator for checking if a i32 value is a valid\n * bitcast conversion from vec2 f16.\n */\nfunction bitcastVec2F16ToF32Comparator(vec2F16InU16x2) {\n  assert(vec2F16InU16x2.length === 2);\n  const expectations = possible32BitScalarIntervalsFromF16x2(vec2F16InU16x2, 'f32');\n  // Return alwaysPass if result is expected unbounded.\n  if (expectations.isUnbounded) {\n    return anyF32;\n  }\n  return anyOf(...expectations.possibleExpectations);\n}\n\n/**\n * @returns a Comparator for checking if a vec2 u32 value is a valid\n * bitcast conversion from vec4 f16.\n */\nfunction bitcastVec4F16ToVec2U32Comparator(vec4F16InU16x4) {\n  assert(vec4F16InU16x4.length === 4);\n  const expectationsPerElement = [vec4F16InU16x4.slice(0, 2), vec4F16InU16x4.slice(2, 4)].map((e) =>\n  possible32BitScalarIntervalsFromF16x2(e, 'u32')\n  );\n  // Return alwaysPass if any element is expected unbounded. Although it may be only one unbounded\n  // element in the result vector, currently we don't have a way to build a comparator that expect\n  // only one element of i32/u32 vector unbounded.\n  if (expectationsPerElement.map((e) => e.isUnbounded).reduce((a, b) => a || b, false)) {\n    return alwaysPass('any vec2<u32>');\n  }\n  return anyOf(\n    ...cartesianProduct(...expectationsPerElement.map((e) => e.possibleExpectations)).map(\n      (e) => new VectorValue(e)\n    )\n  );\n}\n\n/**\n * @returns a Comparator for checking if a vec2 i32 value is a valid\n * bitcast conversion from vec4 f16.\n */\nfunction bitcastVec4F16ToVec2I32Comparator(vec4F16InU16x4) {\n  assert(vec4F16InU16x4.length === 4);\n  const expectationsPerElement = [vec4F16InU16x4.slice(0, 2), vec4F16InU16x4.slice(2, 4)].map((e) =>\n  possible32BitScalarIntervalsFromF16x2(e, 'i32')\n  );\n  // Return alwaysPass if any element is expected unbounded. Although it may be only one unbounded\n  // element in the result vector, currently we don't have a way to build a comparator that expect\n  // only one element of i32/u32 vector unbounded.\n  if (expectationsPerElement.map((e) => e.isUnbounded).reduce((a, b) => a || b, false)) {\n    return alwaysPass('any vec2<i32>');\n  }\n  return anyOf(\n    ...cartesianProduct(...expectationsPerElement.map((e) => e.possibleExpectations)).map(\n      (e) => new VectorValue(e)\n    )\n  );\n}\n\n/**\n * @returns a Comparator for checking if a vec2 f32 value is a valid\n * bitcast conversion from vec4 f16.\n */\nfunction bitcastVec4F16ToVec2F32Comparator(vec4F16InU16x4) {\n  assert(vec4F16InU16x4.length === 4);\n  const expectationsPerElement = [vec4F16InU16x4.slice(0, 2), vec4F16InU16x4.slice(2, 4)].map((e) =>\n  possible32BitScalarIntervalsFromF16x2(e, 'f32')\n  );\n  return anyOf(\n    ...cartesianProduct(...expectationsPerElement.map((e) => e.possibleExpectations)).map((e) => [\n    e[0],\n    e[1]]\n    )\n  );\n}\n\nexport const d = makeCaseCache('bitcast', {\n  // Identity Cases\n  i32_to_i32: () => fullI32Range().map((e) => ({ input: i32(e), expected: i32(e) })),\n  u32_to_u32: () => fullU32Range().map((e) => ({ input: u32(e), expected: u32(e) })),\n  f32_inf_nan_to_f32: () =>\n  f32RangeWithInfAndNaN.map((e) => ({\n    input: f32(e),\n    expected: bitcastF32ToF32Comparator(e)\n  })),\n  f32_to_f32: () =>\n  f32FiniteRange.map((e) => ({ input: f32(e), expected: bitcastF32ToF32Comparator(e) })),\n  f16_inf_nan_to_f16: () =>\n  [...f16FiniteInF16, ...f16InfAndNaNInF16].map((e) => ({\n    input: f16(e),\n    expected: bitcastF16ToF16Comparator(e)\n  })),\n  f16_to_f16: () =>\n  f16FiniteInF16.map((e) => ({ input: f16(e), expected: bitcastF16ToF16Comparator(e) })),\n\n  // i32,u32,f32,Abstract to different i32,u32,f32\n  i32_to_u32: () => fullI32Range().map((e) => ({ input: i32(e), expected: u32(e) })),\n  i32_to_f32: () =>\n  i32RangeForF32Finite.map((e) => ({\n    input: i32(e),\n    expected: bitcastI32ToF32Comparator(e)\n  })),\n  ai_to_i32: () => fullI32Range().map((e) => ({ input: abstractInt(BigInt(e)), expected: i32(e) })),\n  ai_to_u32: () => fullU32Range().map((e) => ({ input: abstractInt(BigInt(e)), expected: u32(e) })),\n  ai_to_f32: () =>\n  // AbstractInt is converted to i32, because there is no explicit overload\n  i32RangeForF32Finite.map((e) => ({\n    input: abstractInt(BigInt(e)),\n    expected: bitcastI32ToF32Comparator(e)\n  })),\n  i32_to_f32_inf_nan: () =>\n  i32RangeForF32FiniteInfNaN.map((e) => ({\n    input: i32(e),\n    expected: bitcastI32ToF32Comparator(e)\n  })),\n  u32_to_i32: () => fullU32Range().map((e) => ({ input: u32(e), expected: i32(e) })),\n  u32_to_f32: () =>\n  u32RangeForF32Finite.map((e) => ({\n    input: u32(e),\n    expected: bitcastU32ToF32Comparator(e)\n  })),\n  u32_to_f32_inf_nan: () =>\n  u32RangeForF32FiniteInfNaN.map((e) => ({\n    input: u32(e),\n    expected: bitcastU32ToF32Comparator(e)\n  })),\n  f32_inf_nan_to_i32: () =>\n  f32RangeWithInfAndNaN.map((e) => ({\n    input: f32(e),\n    expected: bitcastF32ToI32Comparator(e)\n  })),\n  f32_to_i32: () =>\n  f32FiniteRange.map((e) => ({ input: f32(e), expected: bitcastF32ToI32Comparator(e) })),\n\n  f32_inf_nan_to_u32: () =>\n  f32RangeWithInfAndNaN.map((e) => ({\n    input: f32(e),\n    expected: bitcastF32ToU32Comparator(e)\n  })),\n  f32_to_u32: () =>\n  f32FiniteRange.map((e) => ({ input: f32(e), expected: bitcastF32ToU32Comparator(e) })),\n\n  // i32,u32,f32,AbstractInt to vec2<f16>\n  u32_to_vec2_f16_inf_nan: () =>\n  u32RangeForF16Vec2FiniteInfNaN.map((e) => ({\n    input: u32(e),\n    expected: bitcastU32ToVec2F16Comparator(e)\n  })),\n  u32_to_vec2_f16: () =>\n  u32RangeForF16Vec2Finite.map((e) => ({\n    input: u32(e),\n    expected: bitcastU32ToVec2F16Comparator(e)\n  })),\n  i32_to_vec2_f16_inf_nan: () =>\n  i32RangeForF16Vec2FiniteInfNaN.map((e) => ({\n    input: i32(e),\n    expected: bitcastI32ToVec2F16Comparator(e)\n  })),\n  i32_to_vec2_f16: () =>\n  i32RangeForF16Vec2Finite.map((e) => ({\n    input: i32(e),\n    expected: bitcastI32ToVec2F16Comparator(e)\n  })),\n  ai_to_vec2_f16: () =>\n  // AbstractInt is converted to i32, because there is no explicit overload\n  i32RangeForF16Vec2Finite.map((e) => ({\n    input: abstractInt(BigInt(e)),\n    expected: bitcastI32ToVec2F16Comparator(e)\n  })),\n  f32_inf_nan_to_vec2_f16_inf_nan: () =>\n  f32RangeWithInfAndNaNForF16Vec2FiniteInfNaN.map((e) => ({\n    input: f32(e),\n    expected: bitcastF32ToVec2F16Comparator(e)\n  })),\n  f32_to_vec2_f16: () =>\n  f32FiniteRangeForF16Vec2Finite.map((e) => ({\n    input: f32(e),\n    expected: bitcastF32ToVec2F16Comparator(e)\n  })),\n  af_to_vec2_f16: () =>\n  f32FiniteRangeForF16Vec2Finite.map((e) => ({\n    input: abstractFloat(e),\n    expected: bitcastF32ToVec2F16Comparator(e)\n  })),\n\n  // vec2<i32>, vec2<u32>, vec2<f32>, vec2<AbstractInt> to vec4<f16>\n  vec2_i32_to_vec4_f16_inf_nan: () =>\n  slidingSlice(i32RangeForF16Vec2FiniteInfNaN, 2).map((e) => ({\n    input: toVector(e, i32),\n    expected: bitcastVec2I32ToVec4F16Comparator(e)\n  })),\n  vec2_i32_to_vec4_f16: () =>\n  slidingSlice(i32RangeForF16Vec2Finite, 2).map((e) => ({\n    input: toVector(e, i32),\n    expected: bitcastVec2I32ToVec4F16Comparator(e)\n  })),\n  vec2_ai_to_vec4_f16: () =>\n  // AbstractInt is converted to i32, because there is no explicit overload\n  slidingSlice(i32RangeForF16Vec2Finite, 2).map((e) => ({\n    input: toVector(e, (n) => abstractInt(BigInt(n))),\n    expected: bitcastVec2I32ToVec4F16Comparator(e)\n  })),\n  vec2_u32_to_vec4_f16_inf_nan: () =>\n  slidingSlice(u32RangeForF16Vec2FiniteInfNaN, 2).map((e) => ({\n    input: toVector(e, u32),\n    expected: bitcastVec2U32ToVec4F16Comparator(e)\n  })),\n  vec2_u32_to_vec4_f16: () =>\n  slidingSlice(u32RangeForF16Vec2Finite, 2).map((e) => ({\n    input: toVector(e, u32),\n    expected: bitcastVec2U32ToVec4F16Comparator(e)\n  })),\n  vec2_f32_inf_nan_to_vec4_f16_inf_nan: () =>\n  slidingSlice(f32RangeWithInfAndNaNForF16Vec2FiniteInfNaN, 2).map((e) => ({\n    input: toVector(e, f32),\n    expected: bitcastVec2F32ToVec4F16Comparator(e)\n  })),\n  vec2_f32_to_vec4_f16: () =>\n  slidingSlice(f32FiniteRangeForF16Vec2Finite, 2).map((e) => ({\n    input: toVector(e, f32),\n    expected: bitcastVec2F32ToVec4F16Comparator(e)\n  })),\n  vec2_af_to_vec4_f16: () =>\n  slidingSlice(f32FiniteRangeForF16Vec2Finite, 2).map((e) => ({\n    input: toVector(e, abstractFloat),\n    expected: bitcastVec2F32ToVec4F16Comparator(e)\n  })),\n\n  // vec2<f16> to i32, u32, f32\n  vec2_f16_to_u32: () =>\n  f16Vec2FiniteInU16x2.map((e) => ({\n    input: u16x2ToVec2F16(e),\n    expected: bitcastVec2F16ToU32Comparator(e)\n  })),\n  vec2_f16_inf_nan_to_u32: () =>\n  f16Vec2FiniteInfNanInU16x2.map((e) => ({\n    input: u16x2ToVec2F16(e),\n    expected: bitcastVec2F16ToU32Comparator(e)\n  })),\n  vec2_f16_to_i32: () =>\n  f16Vec2FiniteInU16x2.map((e) => ({\n    input: u16x2ToVec2F16(e),\n    expected: bitcastVec2F16ToI32Comparator(e)\n  })),\n  vec2_f16_inf_nan_to_i32: () =>\n  f16Vec2FiniteInfNanInU16x2.map((e) => ({\n    input: u16x2ToVec2F16(e),\n    expected: bitcastVec2F16ToI32Comparator(e)\n  })),\n  vec2_f16_to_f32_finite: () =>\n  f16Vec2FiniteInU16x2.\n  filter((u16x2) => isFiniteF32(reinterpretU32AsF32(u16x2ToU32(u16x2)))).\n  map((e) => ({\n    input: u16x2ToVec2F16(e),\n    expected: bitcastVec2F16ToF32Comparator(e)\n  })),\n  vec2_f16_inf_nan_to_f32: () =>\n  f16Vec2FiniteInfNanInU16x2.map((e) => ({\n    input: u16x2ToVec2F16(e),\n    expected: bitcastVec2F16ToF32Comparator(e)\n  })),\n\n  // vec4<f16> to vec2 of i32, u32, f32\n  vec4_f16_to_vec2_u32: () =>\n  f16Vec2FiniteInU16x4.map((e) => ({\n    input: u16x4ToVec4F16(e),\n    expected: bitcastVec4F16ToVec2U32Comparator(e)\n  })),\n  vec4_f16_inf_nan_to_vec2_u32: () =>\n  f16Vec2FiniteInfNanInU16x4.map((e) => ({\n    input: u16x4ToVec4F16(e),\n    expected: bitcastVec4F16ToVec2U32Comparator(e)\n  })),\n  vec4_f16_to_vec2_i32: () =>\n  f16Vec2FiniteInU16x4.map((e) => ({\n    input: u16x4ToVec4F16(e),\n    expected: bitcastVec4F16ToVec2I32Comparator(e)\n  })),\n  vec4_f16_inf_nan_to_vec2_i32: () =>\n  f16Vec2FiniteInfNanInU16x4.map((e) => ({\n    input: u16x4ToVec4F16(e),\n    expected: bitcastVec4F16ToVec2I32Comparator(e)\n  })),\n  vec4_f16_to_vec2_f32_finite: () =>\n  f16Vec2FiniteInU16x4.\n  filter(\n    (u16x4) =>\n    isFiniteF32(reinterpretU32AsF32(u16x2ToU32(u16x4.slice(0, 2)))) &&\n    isFiniteF32(reinterpretU32AsF32(u16x2ToU32(u16x4.slice(2, 4))))\n  ).\n  map((e) => ({\n    input: u16x4ToVec4F16(e),\n    expected: bitcastVec4F16ToVec2F32Comparator(e)\n  })),\n  vec4_f16_inf_nan_to_vec2_f32: () =>\n  f16Vec2FiniteInfNanInU16x4.map((e) => ({\n    input: u16x4ToVec4F16(e),\n    expected: bitcastVec4F16ToVec2F32Comparator(e)\n  }))\n});"],"mappings":"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","ignoreList":[]}