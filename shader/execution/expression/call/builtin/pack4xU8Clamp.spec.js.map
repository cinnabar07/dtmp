{"version":3,"file":"pack4xU8Clamp.spec.js","names":["description","makeTestGroup","GPUTest","u32","toVector","Type","clamp","allInputSources","run","builtin","g","test","specURL","desc","params","u","combine","fn","t","cfg","pack4xU8Clamp","vals","result","Uint32Array","i","clampedValue","min","max","testInputs","makeCase","input","expected","cases","flatMap","v","vec4u"],"sources":["../../../../../../../src/webgpu/shader/execution/expression/call/builtin/pack4xU8Clamp.spec.ts"],"sourcesContent":["/**\n* AUTO-GENERATED - DO NOT EDIT. Source: https://github.com/gpuweb/cts\n**/export const description = `\nExecution tests for the 'pack4xU8Clamp' builtin function\n\n@const fn pack4xU8Clamp(e: vec4<u32>) -> u32\nClamp each component of e in the range of [0, 255] and then pack the lower 8 bits of each component\ninto a u32 value. Component e[i] of the input is mapped to bits (8 * i) through (8 * (i + 7)) of the\nresult.\n`;import { makeTestGroup } from '../../../../../../common/framework/test_group.js';\nimport { GPUTest } from '../../../../../gpu_test.js';\nimport { u32, toVector, Type } from '../../../../../util/conversion.js';\nimport { clamp } from '../../../../../util/math.js';\n\nimport { allInputSources, run } from '../../expression.js';\n\nimport { builtin } from './builtin.js';\n\nexport const g = makeTestGroup(GPUTest);\n\ng.test('basic').\nspecURL('https://www.w3.org/TR/WGSL/#pack4xU8Clamp-builtin').\ndesc(\n  `\n@const fn pack4xU8Clamp(e: vec4<u32>) -> u32\n  `\n).\nparams((u) => u.combine('inputSource', allInputSources)).\nfn(async (t) => {\n  const cfg = t.params;\n\n  const pack4xU8Clamp = (vals) => {\n    const result = new Uint32Array(1);\n    for (let i = 0; i < 4; ++i) {\n      const clampedValue = clamp(vals[i], { min: 0, max: 255 });\n      result[0] |= clampedValue << i * 8;\n    }\n    return result[0];\n  };\n\n  const testInputs = [\n  [0, 0, 0, 0],\n  [1, 2, 3, 4],\n  [255, 255, 255, 255],\n  [254, 255, 256, 257],\n  [65535, 65536, 255, 254]];\n\n\n  const makeCase = (vals) => {\n    return { input: [toVector(vals, u32)], expected: u32(pack4xU8Clamp(vals)) };\n  };\n  const cases = testInputs.flatMap((v) => {\n    return [makeCase(v)];\n  });\n\n  await run(t, builtin('pack4xU8Clamp'), [Type.vec4u], Type.u32, cfg, cases);\n});"],"mappings":";;IAAA;AACA;AACA,GAAG,OAAO,MAAMA,WAAW,GAAG;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,SAASC,aAAa,QAAQ,kDAAkD,CAClF,SAASC,OAAO,QAAQ,4BAA4B,CACpD,SAASC,GAAG,EAAEC,QAAQ,EAAEC,IAAI,QAAQ,mCAAmC;AACvE,SAASC,KAAK,QAAQ,6BAA6B;;AAEnD,SAASC,eAAe,EAAEC,GAAG,QAAQ,qBAAqB;;AAE1D,SAASC,OAAO,QAAQ,cAAc;;AAEtC,OAAO,MAAMC,CAAC,GAAGT,aAAa,CAACC,OAAO,CAAC;;AAEvCQ,CAAC,CAACC,IAAI,CAAC,OAAO,CAAC;AACfC,OAAO,CAAC,mDAAmD,CAAC;AAC5DC,IAAI;EACF;AACF;AACA;AACA,CAAC;AACDC,MAAM,CAAC,CAACC,CAAC,KAAKA,CAAC,CAACC,OAAO,CAAC,aAAa,EAAET,eAAe,CAAC,CAAC;AACxDU,EAAE,CAAC,OAAOC,CAAC,KAAK;EACd,MAAMC,GAAG,GAAGD,CAAC,CAACJ,MAAM;;EAEpB,MAAMM,aAAa,GAAGA,CAACC,IAAI,KAAK;IAC9B,MAAMC,MAAM,GAAG,IAAIC,WAAW,CAAC,CAAC,CAAC;IACjC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAE,EAAEA,CAAC,EAAE;MAC1B,MAAMC,YAAY,GAAGnB,KAAK,CAACe,IAAI,CAACG,CAAC,CAAC,EAAE,EAAEE,GAAG,EAAE,CAAC,EAAEC,GAAG,EAAE,GAAG,CAAC,CAAC,CAAC;MACzDL,MAAM,CAAC,CAAC,CAAC,IAAIG,YAAY,IAAID,CAAC,GAAG,CAAC;IACpC;IACA,OAAOF,MAAM,CAAC,CAAC,CAAC;EAClB,CAAC;;EAED,MAAMM,UAAU,GAAG;EACnB,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;EACZ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;EACZ,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;EACpB,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;EACpB,CAAC,KAAK,EAAE,KAAK,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;;;EAGzB,MAAMC,QAAQ,GAAGA,CAACR,IAAI,KAAK;IACzB,OAAO,EAAES,KAAK,EAAE,CAAC1B,QAAQ,CAACiB,IAAI,EAAElB,GAAG,CAAC,CAAC,EAAE4B,QAAQ,EAAE5B,GAAG,CAACiB,aAAa,CAACC,IAAI,CAAC,CAAC,CAAC,CAAC;EAC7E,CAAC;EACD,MAAMW,KAAK,GAAGJ,UAAU,CAACK,OAAO,CAAC,CAACC,CAAC,KAAK;IACtC,OAAO,CAACL,QAAQ,CAACK,CAAC,CAAC,CAAC;EACtB,CAAC,CAAC;;EAEF,MAAM1B,GAAG,CAACU,CAAC,EAAET,OAAO,CAAC,eAAe,CAAC,EAAE,CAACJ,IAAI,CAAC8B,KAAK,CAAC,EAAE9B,IAAI,CAACF,GAAG,EAAEgB,GAAG,EAAEa,KAAK,CAAC;AAC5E,CAAC,CAAC","ignoreList":[]}