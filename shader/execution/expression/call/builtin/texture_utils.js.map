{"version":3,"file":"texture_utils.js","names":["keysOf","assert","range","unreachable","Float16Array","is32Float","isCompressedFloatTextureFormat","isCompressedTextureFormat","isDepthOrStencilTextureFormat","isDepthTextureFormat","isEncodableTextureFormat","isSintOrUintFormat","isStencilTextureFormat","kEncodableTextureFormats","kTextureFormatInfo","GPUTest","align","clamp","dotProduct","hashU32","lcm","lerp","quantizeToF32","effectiveViewDimensionForDimension","physicalMipSize","physicalMipSizeFromTexture","reifyTextureDescriptor","virtualMipSize","kTexelRepresentationInfo","TexelComponent","TexelView","createTextureFromTexelViews","reifyExtent3D","kShortShaderStageToShaderStage","c","f","v","kShortShaderStages","kShortAddressModeToAddressMode","r","m","kShortAddressModes","kSampleTypeInfo","f32","format","i32","u32","isSupportedViewFormatCombo","viewDimension","getTextureTypeForTextureViewDimension","isUnencodableDepthFormat","skipIfNeedsFilteringAndIsUnfilterableOrSelectDevice","t","filter","features","Set","add","feature","skipIf","type","color","size","selectDeviceOrSkipTestCase","Array","from","skipIfNeedsFilteringAndIsUnfilterable","isFillable","endsWith","isPotentiallyFilterableAndFillable","info","depth","canPotentiallyFilter","result","skipIfTextureFormatNotSupportedNotAvailableOrNotFilterable","skipIfTextureFormatNotSupported","selectDeviceForTextureFormatOrSkipTestCase","builtinNeedsMipLevelWeights","builtin","unzip","array","num","srcStride","undefined","arrays","numEntries","Math","ceil","length","i","j","push","makeGraph","width","height","data","Uint8Array","plot","norm","x","y","floor","min","max","offset","plotValues","values","toString","conversion","lines","subarray","map","join","linear0to1OverN","n","graphWeights","weights","graph","validateWeights","stage","showWeights","rec","debugging","padStart","kMipLevelWeightSteps","kMinPercentUniqueWeights","queryMipLevelMixWeightsForDevice","device","kNumWeightTypes","module","createShaderModule","code","texture","createTextureTracked","usage","GPUTextureUsage","TEXTURE_BINDING","COPY_DST","mipLevelCount","queue","writeTexture","mipLevel","bytesPerRow","sampler","createSampler","minFilter","magFilter","mipmapFilter","target","RENDER_ATTACHMENT","COPY_SRC","storageBuffer","createBufferTracked","GPUBufferUsage","STORAGE","resultBuffer","MAP_READ","createBindGroup","pipeline","layout","getBindGroupLayout","entries","binding","resource","createView","buffer","encoder","globalThis","_TRAMPOLINE_","createCommandEncoder","createComputePipeline","compute","pass","beginComputePass","setPipeline","setBindGroup","dispatchWorkgroups","end","copyBufferToBuffer","createRenderPipeline","vertex","entryPoint","fragment","targets","beginRenderPass","colorAttachments","view","loadOp","storeOp","setViewport","draw","copyTextureToBuffer","submit","finish","mapAsync","GPUMapMode","READ","Float32Array","getMappedRange","unmap","destroy","sampleLevelWeights","gradWeights","softwareMixToGPUMixGradWeights","generateSoftwareMixToGPUMixGradWeights","getIndexAndWeight","lo","hi","w0","w1","weight","bilinearFilter","ndx","v0","v1","gpuWeights","numSteps","depthOrArrayLayers","softwareWeights","u","g","computeMipLevelFromGradients","softwareMixToGPUMixMap","mix","mapSoftwareMipLevelToGPUMipLevel","baseLevel","softwareMix","gpuMix","getMixWeightByTypeForMipLevel","euclideanModulo","s_deviceToMipLevelWeightsPromise","WeakMap","s_deviceToMipLevelWeights","initMipLevelWeightsForDevice","stageWeightsP","get","set","weightsP","then","stageWeights","catch","e","weightType","steps","w","lowerNdx","upperNdx","getWeightForMipLevel","WGSLTextureQueryTest","executeAndExpectResult","viewDescriptor","expected","returnType","castWGSL","stageWGSL","wgsl","visibility","GPUShaderStage","COMPUTE","FRAGMENT","VERTEX","GPUExternalTexture","externalTexture","includes","storageTexture","access","dimension","sampleType","aspect","sampleCount","multisampled","bindGroupLayouts","createBindGroupLayout","hasDynamicOffset","minBindingSize","createPipelineLayout","bindGroup0","renderTarget","bindGroup1","Uint32Array","expectGPUBufferValuesEqual","WGSLTextureSampleTest","init","getLimitValue","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","getMinAndMaxTexelValueForComponent","rep","component","numericRange","perComponentRanges","perComponentRange","getTexelViewFormatForTextureFormat","kTextureTypeInfo","componentType","resultType","resultFormat","float","sint","uint","getTextureFormatTypeInfo","stencil","appendComponentTypeForFormatToTextureType","base","makeRandomDepthComparisonTexelGenerator","comparison","comparisonIsEqualOrNotEqual","fixedValues","encode","coords","texel","componentOrder","rnd","z","sampleIndex","charCodeAt","normalized","quantize","createRandomTexelViewViaColors","options","minMax","Object","fromEntries","generator","fromTexelsAsColors","createRandomTexelViewViaBytes","formatInfo","bytesPerBlock","bytes","blocksAcross","blockWidth","blocksDown","blockHeight","bytesNeeded","hashBase","sumOfCharCodesOfString","R","asFloat","asU32","fromTextureDataByReference","rowsPerImage","subrectOrigin","subrectSize","createRandomTexelView","canFillWithRandomTypedData","createRandomTexelViewMipmap","kTextureCallArgNames","isBuiltinComparison","isBuiltinGather","builtinNeedsSampler","startsWith","builtinNeedsDerivatives","isCubeViewDimension","isViewDimensionCubeOrCubeArray","s_u32","s_f32","s_i32","Int32Array","kBitCastFunctions","getCallArgType","call","argName","coordType","levelType","arrayIndexType","sampleIndexType","toArray","repl","bitsToNumber","unpackBits","pack","apply","a","b","op","getUnusedCubeCornerSampleIndex","textureSize","convertPerTexelComponentToResultFormat","src","out","G","B","A","convertToTexelViewFormat","Depth","Stencil","convertResultFormatToTexelViewFormat","zeroValuePerTexelComponent","components","kSamplerFns","never","ref","less","equal","less-equal","greater","not-equal","greater-equal","always","applyCompare","depthRef","compareFn","compare","softwareTextureReadMipLevel","texels","descriptor","addressMode","addressModeU","addressModeV","addressModeW","isCube","arrayIndexMult","numLayers","textureSizeForCube","load","at","zFromArrayIndex","arrayIndex","convertCubeCoordToNormalized3DTextureCoord","samples","p0","p1","p1W","p0W","describeTextureCall","p","round","componentNdx","kRGBAComponents","forEach","sample","wrapFaceCoordToCubeFaceAtEdgeBoundaries","applyAddressModesToCoords","postV","rgba","isOutOfBoundsCall","softwareTextureReadLevel","maxLevel","effectiveMipmapFilter","clampedMipLevel","baseMipLevel","nextMipLevel","t0","t1","ddx","ddy","texSize","scaledDdx","scaledDdy","dotDDX","dotDDY","deltaMax","log2","computeMipLevelFromGradientsForCall","softwareTextureReadGrad","bias","weightMipLevel","derivativeBaseForCall","isDDX","derivativeForCall","dd","derivativeMult","softwareTextureRead","newCall","desc","isValidOutOfBoundsValue","gotRGBA","maxFractionalDiff","mipTexels","texelsApproximatelyEqual","okBecauseOutOfBounds","kRComponent","gotFormat","expectRGBA","expectedFormat","got","expect","gULP","bitsToULPFromZero","numberToBits","eULP","rgbaComponentsToCheck","absDiff","abs","ulpDiff","getULPFromZeroForComponents","temp","comp","ulp","checkCallResults","textureType","calls","results","shortShaderStage","gpuTexture","haveComparisonCheckInfo","checkInfo","runner","gpuTexels","errs","getMaxFractionalDiffForTextureFormat","callIdx","callSpecificMaxFractionalDiff","bad","diffs","isNaN","maxAbs","relDiff","isFloatType","fix5","toFixed","fix5v","arr","rgbaToArray","coord","faceNdx","mipSize","slice","kFaceNames","biasStr","clampedBias","debugCalls","debugCall","debugSampler","debugRunner","createTextureCallsRunner","readTextureToTexelViews","callForSamplePoints","useTexelFormatForGPUTexture","expectedSamplePoints","identifySamplePoints","Promise","resolve","gotSamplePoints","createTextureFromTexelViewsLocal","run","layoutTwoColumns","Error","s","String","split","reduce","sum","makeAstcBlockFiller","makeRandomBytesBlockFiller","getBlockFiller","fillTextureWithRandomData","fillBlock","s_readTextureToRGBA32DeviceToPipeline","getEffectiveViewDimension","textureBindingViewDimension","viewDimensionToPipelineMap","Map","id","textureWGSL","loadWGSL","dimensionWGSL","textureLoadCubeWGSL","bindGroupLayout","readBuffers","uniformValues","uniformBuffer","byteLength","UNIFORM","writeBuffer","readBuffer","getAspectForTexture","bindGroup","texelViews","Ctor","modifiedDescriptor","createTextureWithRandomDataAndGetTexels","d32Descriptor","tempTexels","valueIfAllComponentsAreEqual","next","value","createVideoFrameWithRandomDataAndGetTexels","imageData","ImageData","canvas","OffscreenCanvas","ctx","getContext","putImageData","videoFrame","VideoFrame","timestamp","alpha","callForSamples","originalCall","mipLevelSize","numTexelsPerLevel","numTexelsOfPrecedingLevels","total","numTexels","getMipLevelFromTexelId","texelId","getTexelCoordFromTexelId","texelsPerSlice","layer","xyId","convertResultAsAppropriate","sampledTexelWeights","unclassifiedStack","unclassified","pop","setA","setB","keys","texelsPerRow","isCandidate","has","some","levels","level","layerEntries","letter","idx","fromCodePoint","idCount","blockHChar","blockVChar","blockHCell","rangeCat","fn","orderedTexelIndices","unSampled","face","padEnd","line","colChar","texelIdx","pad2","pad3","formatValue","formatTexel","k","colorLines","compareLines","levelWeight","singleWeight","texelStr","compareTexel","columnA","columnB","widthA","l","repeat","getDepthOrArrayLayersForViewDimension","chooseTextureSize","minSize","minBlocks","blockLCM","largest","kSamplePointMethods","kCubeSamplePointMethods","generateTextureBuiltinInputsImpl","makeValue","args","method","radius","loops","PI","cos","sin","_hashInputs","hashInputs","makeRandValue","number","makeRangeValue","makeIntHashValueRepeatable","kSubdivisionsPerTexel","avoidEdgeCase","textureBuiltin","edgeRemainder","avoidTextureEdge","axis","textureDimensionUnits","inside","outside","numComponents","quantizeMipLevel","q","isTexelEdgeCase","v2","v3","makeGradient","hashInput","_","intPart","fractPart","makeDerivativeMult","mult","fill","pow","chooseMipLevel","innerLevelR","innerLevel","outerLevel","makeDerivativeMultForTextureSample","makeBiasAndDerivativeMult","derivativeBasedMipLevel","derivatives","grad","kMipEpsilon","intMip","fractionalMip","generateTextureBuiltinInputs1D","generateTextureBuiltinInputs2D","generateTextureBuiltinInputs3D","kFaceUVMatrices","transformMat3","normalize","sqrt","uvw","absR","negX","negY","negZ","convertNormalized3DTexCoordToCubeCoord","uvLayer","faceLayer","faceCoord","nc0","cc","nc1","fc","generateSamplePointsCube","textureWidth","theta","phi","sinTheta","cosTheta","sinPhi","cosPhi","ux","uy","uz","makeIntHashValue","halfTexel","quantizedUVW","isEdgeCase","units","wgslTypeFor","isArray","wgslExpr","wgslExprFor","binKey","name","buildBinnedCalls","fields","prototype","bitcastToU32","expr","binCalls","bins","key","binIdx","derivativeWGSL","s_deviceToPipelines","structs","body","dataFields","callCount","binned","dataBuffer","isCompare","samplerType","derivativeBaseWGSL","derivativeType","pipelines","isFiltering","JSON","stringify","bindGroupLayout0","bindGroupLayout1","gpuSampler","runViewDescriptor","outIdx","bin","doTextureCalls"],"sources":["../../../../../../../src/webgpu/shader/execution/expression/call/builtin/texture_utils.ts"],"sourcesContent":["/**\n* AUTO-GENERATED - DO NOT EDIT. Source: https://github.com/gpuweb/cts\n**/import { keysOf } from '../../../../../../common/util/data_tables.js';import { assert, range, unreachable } from '../../../../../../common/util/util.js';import { Float16Array } from '../../../../../../external/petamoriken/float16/float16.js';\nimport {\n\n  is32Float,\n  isCompressedFloatTextureFormat,\n  isCompressedTextureFormat,\n  isDepthOrStencilTextureFormat,\n  isDepthTextureFormat,\n  isEncodableTextureFormat,\n  isSintOrUintFormat,\n  isStencilTextureFormat,\n  kEncodableTextureFormats,\n  kTextureFormatInfo } from\n'../../../../../format_info.js';\nimport { GPUTest } from '../../../../../gpu_test.js';\nimport {\n  align,\n  clamp,\n  dotProduct,\n  hashU32,\n  lcm,\n  lerp,\n  quantizeToF32 } from\n'../../../../../util/math.js';\nimport {\n  effectiveViewDimensionForDimension,\n  physicalMipSize,\n  physicalMipSizeFromTexture,\n  reifyTextureDescriptor,\n\n  virtualMipSize } from\n'../../../../../util/texture/base.js';\nimport {\n  kTexelRepresentationInfo,\n\n\n\n  TexelComponent } from\n\n'../../../../../util/texture/texel_data.js';\nimport { TexelView } from '../../../../../util/texture/texel_view.js';\nimport { createTextureFromTexelViews } from '../../../../../util/texture.js';\nimport { reifyExtent3D } from '../../../../../util/unions.js';\n\n\n// These are needed because the list of parameters was too long when converted to a filename.\nexport const kShortShaderStageToShaderStage = {\n  c: 'compute',\n  f: 'fragment',\n  v: 'vertex'\n};\nexport const kShortShaderStages = keysOf(kShortShaderStageToShaderStage);\n\n\n// These are needed because the list of parameters was too long when converted to a filename.\nexport const kShortAddressModeToAddressMode = {\n  c: 'clamp-to-edge',\n  r: 'repeat',\n  m: 'mirror-repeat'\n};\n\nexport const kShortAddressModes = keysOf(kShortAddressModeToAddressMode);\n\nexport const kSampleTypeInfo = {\n  f32: {\n    format: 'rgba8unorm'\n  },\n  i32: {\n    format: 'rgba8sint'\n  },\n  u32: {\n    format: 'rgba8uint'\n  }\n};\n\n// MAINTENANCE_TODO: Stop excluding sliced compressed 3d formats.\nexport function isSupportedViewFormatCombo(\nformat,\nviewDimension)\n{\n  return !(\n  (isCompressedTextureFormat(format) || isDepthOrStencilTextureFormat(format)) && (\n  viewDimension === '3d' || viewDimension === '1d'));\n\n}\n\n/**\n * Return the texture type for a given view dimension\n */\nexport function getTextureTypeForTextureViewDimension(viewDimension) {\n  switch (viewDimension) {\n    case '1d':\n      return 'texture_1d<f32>';\n    case '2d':\n      return 'texture_2d<f32>';\n    case '2d-array':\n      return 'texture_2d_array<f32>';\n    case '3d':\n      return 'texture_3d<f32>';\n    case 'cube':\n      return 'texture_cube<f32>';\n    case 'cube-array':\n      return 'texture_cube_array<f32>';\n    default:\n      unreachable();\n  }\n}\n\nconst isUnencodableDepthFormat = (format) =>\nformat === 'depth24plus' ||\nformat === 'depth24plus-stencil8' ||\nformat === 'depth32float-stencil8';\n\n/**\n * Skips a subcase if the filter === 'linear' and the format is type\n * 'unfilterable-float' and we cannot enable filtering.\n */\nexport function skipIfNeedsFilteringAndIsUnfilterableOrSelectDevice(\nt,\nfilter,\nformat)\n{\n  const features = new Set();\n  features.add(kTextureFormatInfo[format].feature);\n\n  if (filter === 'linear') {\n    t.skipIf(isDepthTextureFormat(format), 'depth texture are unfilterable');\n\n    const type = kTextureFormatInfo[format].color?.type;\n    if (type === 'unfilterable-float') {\n      assert(is32Float(format));\n      features.add('float32-filterable');\n    }\n  }\n\n  if (features.size > 0) {\n    t.selectDeviceOrSkipTestCase(Array.from(features));\n  }\n}\n\n/**\n * Skips a test if filter === 'linear' and the format is not filterable\n */\nexport function skipIfNeedsFilteringAndIsUnfilterable(\nt,\nfilter,\nformat)\n{\n  if (filter === 'linear') {\n    t.skipIf(isDepthTextureFormat(format), 'depth textures are unfilterable');\n  }\n}\n\n/**\n * Returns if a texture format can be filled with random data.\n */\nexport function isFillable(format) {\n  // We can't easily put random bytes into compressed textures if they are float formats\n  // since we want the range to be +/- 1000 and not +/- infinity or NaN.\n  return !isCompressedTextureFormat(format) || !format.endsWith('float');\n}\n\n/**\n * Returns if a texture format can potentially be filtered and can be filled with random data.\n */\nexport function isPotentiallyFilterableAndFillable(format) {\n  const info = kTextureFormatInfo[format];\n  const type = info.color?.type ?? info.depth?.type;\n  const canPotentiallyFilter =\n  type === 'float' || type === 'unfilterable-float' || type === 'depth';\n  const result = canPotentiallyFilter && isFillable(format);\n  return result;\n}\n\n/**\n * skips the test if the texture format is not supported or not available or not filterable.\n */\nexport function skipIfTextureFormatNotSupportedNotAvailableOrNotFilterable(\nt,\nformat)\n{\n  t.skipIfTextureFormatNotSupported(format);\n  const info = kTextureFormatInfo[format];\n  if (info.color?.type === 'unfilterable-float') {\n    t.selectDeviceOrSkipTestCase('float32-filterable');\n  } else {\n    t.selectDeviceForTextureFormatOrSkipTestCase(format);\n  }\n}\n\nconst builtinNeedsMipLevelWeights = (builtin) =>\nbuiltin !== 'textureLoad' &&\nbuiltin !== 'textureGather' &&\nbuiltin !== 'textureGatherCompare' &&\nbuiltin !== 'textureSampleBaseClampToEdge';\n\n/**\n * Splits in array into multiple arrays where every Nth value goes to a different array\n */\nfunction unzip(array, num, srcStride) {\n  srcStride = srcStride === undefined ? num : srcStride;\n  const arrays = range(num, () => []);\n  const numEntries = Math.ceil(array.length / srcStride);\n  for (let i = 0; i < numEntries; ++i) {\n    for (let j = 0; j < num; ++j) {\n      arrays[j].push(array[i * srcStride + j]);\n    }\n  }\n  return arrays;\n}\n\n\n\n\n\n\n\nfunction makeGraph(width, height) {\n  const data = new Uint8Array(width * height);\n\n  return {\n    plot(norm, x, c) {\n      const y = clamp(Math.floor(norm * height), { min: 0, max: height - 1 });\n      const offset = (height - y - 1) * width + x;\n      data[offset] = c;\n    },\n    plotValues(values, c) {\n      let i = 0;\n      for (const v of values) {\n        this.plot(v, i, c);\n        ++i;\n      }\n    },\n    toString(conversion = ['.', 'e', 'A']) {\n      const lines = [];\n      for (let y = 0; y < height; ++y) {\n        const offset = y * width;\n        lines.push([...data.subarray(offset, offset + width)].map((v) => conversion[v]).join(''));\n      }\n      return lines.join('\\n');\n    }\n  };\n}\n\nfunction* linear0to1OverN(n) {\n  for (let i = 0; i <= n; ++i) {\n    yield i / n;\n  }\n}\n\n/**\n * Generates an ascii graph of weights\n */\nexport function graphWeights(height, weights) {\n  const graph = makeGraph(weights.length, height);\n  graph.plotValues(linear0to1OverN(weights.length - 1), 1);\n  graph.plotValues(weights, 2);\n  return graph.toString();\n}\n\n/**\n * Validates the weights go from 0 to 1 in increasing order.\n */\nfunction validateWeights(t, stage, weights) {\n  const showWeights = t.rec.debugging ?\n  () => `\n${weights.map((v, i) => `${i.toString().padStart(2)}: ${v}`).join('\\n')}\n\ne = expected\nA = actual\n${graphWeights(32, weights)}\n` :\n  () => ``;\n\n  // Validate the weights\n  assert(\n    weights[0] === 0,\n    `stage: ${stage}, weight 0 expected 0 but was ${weights[0]}\\n${showWeights()}`\n  );\n  assert(\n    weights[kMipLevelWeightSteps] === 1,\n    `stage: ${stage}, top weight expected 1 but was ${\n    weights[kMipLevelWeightSteps]}\\n${\n    showWeights()}`\n  );\n\n  // Test that we don't have a mostly flat set of weights.\n  // This is also some small guarantee that we actually read something.\n  // Note: Ideally every value is unique but 25% is about how many an Intel Mac\n  // returns in a compute stage.\n  const kMinPercentUniqueWeights = 25;\n  assert(\n    new Set(weights).size >= (weights.length * kMinPercentUniqueWeights * 0.01 | 0),\n    `stage: ${stage}, expected at least ~${kMinPercentUniqueWeights}% unique weights\\n${showWeights()}`\n  );\n}\n\n/**\n * In an attempt to pass on more devices without lowering the tolerances\n * so low they are meaningless, we ask the hardware to tell us, for a given\n * gradient, level, what mix weights are being used.\n *\n * This is done by drawing instanced quads and using instance_index to\n * write out results into an array. We sample a 2x2 pixel texture with\n * 2 mip levels and set the 2nd mip level to white. This means the value\n * we get back represents the weight used to mix the 2 mip levels.\n *\n * Just as a record of some differences across GPUs\n *\n * level weights: mapping from the mip level\n * parameter of `textureSampleLevel` to\n * the mix weight used by the GPU\n *\n * +--------+--------+--------+--------+\n * |        |        | intel  | amd    |\n * |        |  m1    | gen-9  | rna-1  |\n * | level  |  mac   | mac    | mac    |\n * +--------+--------+--------+--------+\n * | 0.0000 | 0.0000 | 0.0000 | 0.0000 |\n * | 0.0313 | 0.0314 | 0.0313 | 0.0000 |\n * | 0.0625 | 0.0625 | 0.0625 | 0.0000 |\n * | 0.0938 | 0.0939 | 0.0938 | 0.0000 |\n * | 0.1250 | 0.1250 | 0.1250 | 0.0313 |\n * | 0.1563 | 0.1564 | 0.1563 | 0.0703 |\n * | 0.1875 | 0.1875 | 0.1875 | 0.1094 |\n * | 0.2188 | 0.2189 | 0.2188 | 0.1484 |\n * | 0.2500 | 0.2500 | 0.2500 | 0.1875 |\n * | 0.2813 | 0.2814 | 0.2813 | 0.2266 |\n * | 0.3125 | 0.3125 | 0.3125 | 0.2656 |\n * | 0.3438 | 0.3439 | 0.3438 | 0.3047 |\n * | 0.3750 | 0.3750 | 0.3750 | 0.3438 |\n * | 0.4063 | 0.4064 | 0.4063 | 0.3828 |\n * | 0.4375 | 0.4375 | 0.4375 | 0.4219 |\n * | 0.4688 | 0.4689 | 0.4688 | 0.4609 |\n * | 0.5000 | 0.5000 | 0.5000 | 0.5000 |\n * | 0.5313 | 0.5314 | 0.5313 | 0.5391 |\n * | 0.5625 | 0.5625 | 0.5625 | 0.5781 |\n * | 0.5938 | 0.5939 | 0.5938 | 0.6172 |\n * | 0.6250 | 0.6250 | 0.6250 | 0.6563 |\n * | 0.6563 | 0.6564 | 0.6563 | 0.6953 |\n * | 0.6875 | 0.6875 | 0.6875 | 0.7344 |\n * | 0.7188 | 0.7189 | 0.7188 | 0.7734 |\n * | 0.7500 | 0.7500 | 0.7500 | 0.8125 |\n * | 0.7813 | 0.7814 | 0.7813 | 0.8516 |\n * | 0.8125 | 0.8125 | 0.8125 | 0.8906 |\n * | 0.8438 | 0.8439 | 0.8438 | 0.9297 |\n * | 0.8750 | 0.8750 | 0.8750 | 0.9688 |\n * | 0.9063 | 0.9064 | 0.9063 | 1.0000 |\n * | 0.9375 | 0.9375 | 0.9375 | 1.0000 |\n * | 0.9688 | 0.9689 | 0.9688 | 1.0000 |\n * | 1.0000 | 1.0000 | 1.0000 | 1.0000 |\n * +--------+--------+--------+--------+\n *\n * grad weights: mapping from ddx value\n * passed into `textureSampleGrad` to\n * the mix weight used by the GPU\n *\n * +--------+--------+--------+--------+\n * |        |        | intel  | amd    |\n * |        |  m1    | gen-9  | rna-1  |\n * |  ddx   |  mac   | mac    | mac    |\n * +--------+--------+--------+--------+\n * | 0.5000 | 0.0000 | 0.0000 | 0.0000 |\n * | 0.5109 | 0.0390 | 0.0430 | 0.0000 |\n * | 0.5221 | 0.0821 | 0.0859 | 0.0000 |\n * | 0.5336 | 0.1211 | 0.1289 | 0.0352 |\n * | 0.5453 | 0.1600 | 0.1719 | 0.0898 |\n * | 0.5572 | 0.2032 | 0.2109 | 0.1328 |\n * | 0.5694 | 0.2422 | 0.2461 | 0.1797 |\n * | 0.5819 | 0.2814 | 0.2852 | 0.2305 |\n * | 0.5946 | 0.3203 | 0.3203 | 0.2773 |\n * | 0.6076 | 0.3554 | 0.3594 | 0.3164 |\n * | 0.6209 | 0.3868 | 0.3906 | 0.3633 |\n * | 0.6345 | 0.4218 | 0.4258 | 0.4063 |\n * | 0.6484 | 0.4532 | 0.4609 | 0.4492 |\n * | 0.6626 | 0.4882 | 0.4922 | 0.4883 |\n * | 0.6771 | 0.5196 | 0.5234 | 0.5273 |\n * | 0.6920 | 0.5507 | 0.5547 | 0.5664 |\n * | 0.7071 | 0.5860 | 0.5859 | 0.6055 |\n * | 0.7226 | 0.6132 | 0.6133 | 0.6406 |\n * | 0.7384 | 0.6407 | 0.6445 | 0.6797 |\n * | 0.7546 | 0.6679 | 0.6719 | 0.7148 |\n * | 0.7711 | 0.6953 | 0.6992 | 0.7461 |\n * | 0.7880 | 0.7225 | 0.7266 | 0.7813 |\n * | 0.8052 | 0.7500 | 0.7539 | 0.8164 |\n * | 0.8229 | 0.7814 | 0.7813 | 0.8516 |\n * | 0.8409 | 0.8086 | 0.8086 | 0.8828 |\n * | 0.8593 | 0.8321 | 0.8320 | 0.9141 |\n * | 0.8781 | 0.8554 | 0.8594 | 0.9492 |\n * | 0.8974 | 0.8789 | 0.8828 | 0.9766 |\n * | 0.9170 | 0.9025 | 0.9063 | 1.0000 |\n * | 0.9371 | 0.9297 | 0.9297 | 1.0000 |\n * | 0.9576 | 0.9532 | 0.9531 | 1.0000 |\n * | 0.9786 | 0.9765 | 0.9766 | 1.0000 |\n * | 1.0000 | 1.0000 | 1.0000 | 1.0000 |\n * +--------+--------+--------+--------+\n */\n\nexport async function queryMipLevelMixWeightsForDevice(t, stage) {\n  const { device } = t;\n  const kNumWeightTypes = 2;\n  assert(kNumWeightTypes <= 4);\n  const module = device.createShaderModule({\n    code: `\n      @group(0) @binding(0) var tex: texture_2d<f32>;\n      @group(0) @binding(1) var smp: sampler;\n      @group(0) @binding(2) var<storage, read_write> result: array<vec4f>;\n\n      struct VSOutput {\n        @builtin(position) pos: vec4f,\n        @location(0) @interpolate(flat, either) ndx: u32,\n        @location(1) @interpolate(flat, either) result: vec4f,\n      };\n\n      fn getMixLevels(wNdx: u32) -> vec4f {\n        let mipLevel = f32(wNdx) / ${kMipLevelWeightSteps};\n        let size = textureDimensions(tex);\n        let g = mix(1.0, 2.0, mipLevel) / f32(size.x);\n        let ddx = vec2f(g, 0);\n        return vec4f(\n          textureSampleLevel(tex, smp, vec2f(0.5), mipLevel).r,\n          textureSampleGrad(tex, smp, vec2f(0.5), ddx, vec2f(0)).r,\n          0,\n          0);\n      }\n\n      fn getPosition(vNdx: u32) -> vec4f {\n        let pos = array(\n          vec2f(-1,  3),\n          vec2f( 3, -1),\n          vec2f(-1, -1),\n        );\n        let p = pos[vNdx];\n        return vec4f(p, 0, 1);\n      }\n\n      // -- for getting fragment stage weights --\n\n      @vertex fn vs(@builtin(vertex_index) vNdx: u32, @builtin(instance_index) iNdx: u32) -> VSOutput {\n        return VSOutput(getPosition(vNdx), iNdx, vec4f(0));\n      }\n\n      @fragment fn fsRecord(v: VSOutput) -> @location(0) vec4u {\n        return bitcast<vec4u>(getMixLevels(v.ndx));\n      }\n\n      // -- for getting compute stage weights --\n\n      @compute @workgroup_size(1) fn csRecord(@builtin(global_invocation_id) id: vec3u) {\n        result[id.x] = getMixLevels(id.x);\n      }\n\n      // -- for getting vertex stage weights --\n\n      @vertex fn vsRecord(@builtin(vertex_index) vNdx: u32, @builtin(instance_index) iNdx: u32) -> VSOutput {\n        return VSOutput(getPosition(vNdx), iNdx, getMixLevels(iNdx));\n      }\n\n      @fragment fn fsSaveVs(v: VSOutput) -> @location(0) vec4u {\n        return bitcast<vec4u>(v.result);\n      }\n    `\n  });\n\n  const texture = t.createTextureTracked({\n    size: [2, 2, 1],\n    format: 'r8unorm',\n    usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,\n    mipLevelCount: 2\n  });\n\n  device.queue.writeTexture(\n    { texture, mipLevel: 1 },\n    new Uint8Array([255]),\n    { bytesPerRow: 1 },\n    [1, 1]\n  );\n\n  const sampler = device.createSampler({\n    minFilter: 'linear',\n    magFilter: 'linear',\n    mipmapFilter: 'linear'\n  });\n\n  const target = t.createTextureTracked({\n    size: [kMipLevelWeightSteps + 1, 1],\n    format: 'rgba32uint',\n    usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC\n  });\n\n  const storageBuffer = t.createBufferTracked({\n    size: 4 * 4 * (kMipLevelWeightSteps + 1),\n    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC\n  });\n\n  const resultBuffer = t.createBufferTracked({\n    size: align(storageBuffer.size, 256), // padded for copyTextureToBuffer\n    usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ\n  });\n\n  const createBindGroup = (pipeline) =>\n  device.createBindGroup({\n    layout: pipeline.getBindGroupLayout(0),\n    entries: [\n    { binding: 0, resource: texture.createView() },\n    { binding: 1, resource: sampler },\n    ...(stage === 'compute' ? [{ binding: 2, resource: { buffer: storageBuffer } }] : [])]\n\n  });\n\n  const encoder = globalThis._TRAMPOLINE_(\"createCommandEncoder\", device, device.createCommandEncoder, [], () => device.createCommandEncoder());\n  switch (stage) {\n    case 'compute':{\n        const pipeline = device.createComputePipeline({\n          layout: 'auto',\n          compute: { module }\n        });\n        const pass = encoder.beginComputePass();\n        pass.setPipeline(pipeline);\n        pass.setBindGroup(0, createBindGroup(pipeline));\n        pass.dispatchWorkgroups(kMipLevelWeightSteps + 1);\n        pass.end();\n        encoder.copyBufferToBuffer(storageBuffer, 0, resultBuffer, 0, storageBuffer.size);\n        break;\n      }\n    case 'fragment':{\n        const pipeline = device.createRenderPipeline({\n          layout: 'auto',\n          vertex: { module, entryPoint: 'vs' },\n          fragment: { module, entryPoint: 'fsRecord', targets: [{ format: 'rgba32uint' }] }\n        });\n        const pass = encoder.beginRenderPass({\n          colorAttachments: [\n          {\n            view: target.createView(),\n            loadOp: 'clear',\n            storeOp: 'store'\n          }]\n\n        });\n        pass.setPipeline(pipeline);\n        pass.setBindGroup(0, createBindGroup(pipeline));\n        for (let x = 0; x <= kMipLevelWeightSteps; ++x) {\n          pass.setViewport(x, 0, 1, 1, 0, 1);\n          pass.draw(3, 1, 0, x);\n        }\n        pass.end();\n        encoder.copyTextureToBuffer({ texture: target }, { buffer: resultBuffer }, [target.width]);\n        break;\n      }\n    case 'vertex':{\n        const pipeline = device.createRenderPipeline({\n          layout: 'auto',\n          vertex: { module, entryPoint: 'vsRecord' },\n          fragment: { module, entryPoint: 'fsSaveVs', targets: [{ format: 'rgba32uint' }] }\n        });\n        const pass = encoder.beginRenderPass({\n          colorAttachments: [\n          {\n            view: target.createView(),\n            loadOp: 'clear',\n            storeOp: 'store'\n          }]\n\n        });\n        pass.setPipeline(pipeline);\n        pass.setBindGroup(0, createBindGroup(pipeline));\n        for (let x = 0; x <= kMipLevelWeightSteps; ++x) {\n          pass.setViewport(x, 0, 1, 1, 0, 1);\n          pass.draw(3, 1, 0, x);\n        }\n        pass.end();\n        encoder.copyTextureToBuffer({ texture: target }, { buffer: resultBuffer }, [target.width]);\n        break;\n      }\n  }\n  globalThis._TRAMPOLINE_(\"submit\", device, device.queue.submit, [[encoder.finish()]], () => device.queue.submit([encoder.finish()]));\n\n  await globalThis._TRAMPOLINE_(\"mapAsync\", resultBuffer, resultBuffer.mapAsync, [GPUMapMode.READ], () => resultBuffer.mapAsync(GPUMapMode.READ));\n  // need to map a sub-portion since we may have padded the buffer.\n  const result = Array.from(\n    new Float32Array(resultBuffer.getMappedRange(0, (kMipLevelWeightSteps + 1) * 16))\n  );\n  resultBuffer.unmap();\n  globalThis._TRAMPOLINE_(\"destroy\", resultBuffer, resultBuffer.destroy, [], () => resultBuffer.destroy());\n\n  const [sampleLevelWeights, gradWeights] = unzip(result, kNumWeightTypes, 4);\n\n  validateWeights(t, stage, sampleLevelWeights);\n  validateWeights(t, stage, gradWeights);\n\n  globalThis._TRAMPOLINE_(\"destroy\", texture, texture.destroy, [], () => texture.destroy());\n  globalThis._TRAMPOLINE_(\"destroy\", storageBuffer, storageBuffer.destroy, [], () => storageBuffer.destroy());\n\n  return {\n    sampleLevelWeights,\n    softwareMixToGPUMixGradWeights: generateSoftwareMixToGPUMixGradWeights(gradWeights, texture)\n  };\n}\n\n// Given an array of ascending values and a value v, finds\n// which indices in the array v is between. Returns the lower\n// index and the mix weight between the 2 indices for v.\n//\n// In other words, if values = [10, 20, 30, 40, 50]\n//\n//    getIndexAndWeight(values, 38)  -> [2, 0.8]\n//\n// Example:\n//\n//    values = [10, 20, 30, 40, 50]\n//    v = 38\n//    [ndx, weight] = getIndexAndWeight(values, v);\n//    v2 = lerp(values[ndx], values[ndx + 1], weight);\n//    assert(v === v2)\nfunction getIndexAndWeight(values, v) {\n  assert(v >= values[0] && v <= values[values.length - 1]);\n  let lo = 0;\n  let hi = values.length - 1;\n  for (;;) {\n    const i = lo + (hi - lo) / 2 | 0;\n    const w0 = values[i];\n    const w1 = values[i + 1];\n    if (lo === hi || v >= w0 && v <= w1) {\n      const weight = (v - w0) / (w1 - w0);\n      return [i, weight];\n    }\n    if (v < w0) {\n      hi = i;\n    } else {\n      lo = i + 1;\n    }\n  }\n}\n\n/**\n * Given a fractional number between 0 and values.length returns the value between\n * 2 values. Effectively lerp(values[ndx], values[ndx + 1], weight)\n */\nfunction bilinearFilter(values, ndx, weight) {\n  const v0 = values[ndx];\n  const v1 = values[ndx + 1] ?? 0;\n  assert(ndx < values.length - 1 || ndx === values.length - 1 && weight === 0);\n  return lerp(v0, v1, weight);\n}\n\n/**\n * Generates an array of values that maps between the software renderer's gradient computed\n * mip level and the GPUs gradient computed mip level for mip level 0 to 1.\n */\nfunction generateSoftwareMixToGPUMixGradWeights(gpuWeights, texture) {\n  const numSteps = gpuWeights.length - 1;\n  const size = [texture.width, texture.height, texture.depthOrArrayLayers];\n  const softwareWeights = range(numSteps + 1, (i) => {\n    // u goes from 0 to 1\n    const u = i / numSteps;\n    const g = lerp(1, 2, u) / texture.width;\n    const mipLevel = computeMipLevelFromGradients([g], [0], size);\n    assert(mipLevel >= 0 && mipLevel <= 1);\n    return mipLevel;\n  });\n  const softwareMixToGPUMixMap = range(numSteps + 1, (i) => {\n    const mix = i / numSteps;\n    const [ndx, weight] = getIndexAndWeight(softwareWeights, mix);\n    return bilinearFilter(gpuWeights, ndx, weight);\n  });\n  return softwareMixToGPUMixMap;\n}\n\nfunction mapSoftwareMipLevelToGPUMipLevel(t, stage, mipLevel) {\n  const baseLevel = Math.floor(mipLevel);\n  const softwareMix = mipLevel - baseLevel;\n  const gpuMix = getMixWeightByTypeForMipLevel(\n    t,\n    stage,\n    'softwareMixToGPUMixGradWeights',\n    softwareMix\n  );\n  return baseLevel + gpuMix;\n}\n\nconst euclideanModulo = (n, m) => (n % m + m) % m;\n\n/**\n * Gets the mip gradient values for the current device.\n * The issue is, different GPUs have different ways of mixing between mip levels.\n * For most GPUs it's linear but for AMD GPUs on Mac in particular, it's something\n * else (which AFAICT is against all the specs).\n *\n * We seemingly have 3 options:\n *\n * 1. Increase the tolerances of tests so they pass on AMD.\n * 2. Mark AMD as failing\n * 3. Try to figure out how the GPU converts mip levels into weights\n *\n * We're doing 3.\n *\n * There's an assumption that the gradient will be the same for all formats\n * and usages.\n *\n * Note: The code below has 2 maps. One device->Promise, the other device->weights\n * device->weights is meant to be used synchronously by other code so we don't\n * want to leave initMipGradientValuesForDevice until the weights have been read.\n * But, multiple subcases will run because this function is async. So, subcase 1\n * runs, hits this init code, this code waits for the weights. Then, subcase 2\n * runs and hits this init code. The weights will not be in the device->weights map\n * yet which is why we have the device->Promise map. This is so subcase 2 waits\n * for subcase 1's \"query the weights\" step. Otherwise, all subcases would do the\n * \"get the weights\" step separately.\n */\nconst kMipLevelWeightSteps = 64;\nconst s_deviceToMipLevelWeightsPromise = new WeakMap(\n\n\n);\nconst s_deviceToMipLevelWeights = new WeakMap();\n\nasync function initMipLevelWeightsForDevice(t, stage) {\n  const { device } = t;\n  // Get the per stage promises (or make them)\n  const stageWeightsP =\n  s_deviceToMipLevelWeightsPromise.get(device) ??\n  {};\n  s_deviceToMipLevelWeightsPromise.set(device, stageWeightsP);\n\n  let weightsP = stageWeightsP[stage];\n  if (!weightsP) {\n    // There was no promise for this weight so request it\n    // and add a then clause so the first thing that will happen\n    // when the promise resolves is that we'll record the weights for\n    // that stage.\n    weightsP = queryMipLevelMixWeightsForDevice(t, stage);\n    weightsP.\n    then((weights) => {\n      const stageWeights =\n      s_deviceToMipLevelWeights.get(device) ?? {};\n      s_deviceToMipLevelWeights.set(device, stageWeights);\n      stageWeights[stage] = weights;\n    }).\n    catch((e) => {\n      throw e;\n    });\n    stageWeightsP[stage] = weightsP;\n  }\n  return await weightsP;\n}\n\nfunction getMixWeightByTypeForMipLevel(\nt,\nstage,\nweightType,\nmipLevel)\n{\n  if (weightType === 'identity') {\n    return euclideanModulo(mipLevel, 1);\n  }\n  // linear interpolate between weights\n  const weights = s_deviceToMipLevelWeights.get(t.device)[stage][weightType];\n  assert(\n    !!weights,\n    'you must use WGSLTextureSampleTest or call initializeDeviceMipWeights before calling this function'\n  );\n  const steps = weights.length - 1;\n  const w = euclideanModulo(mipLevel, 1) * steps;\n  const lowerNdx = Math.floor(w);\n  const upperNdx = Math.ceil(w);\n  const mix = w % 1;\n  return lerp(weights[lowerNdx], weights[upperNdx], mix);\n}\n\nfunction getWeightForMipLevel(\nt,\nstage,\nweightType,\nmipLevelCount,\nmipLevel)\n{\n  if (mipLevel < 0 || mipLevel >= mipLevelCount) {\n    return 1;\n  }\n  return getMixWeightByTypeForMipLevel(t, stage, weightType, mipLevel);\n}\n\n/**\n * Used for textureNumSamples, textureNumLevels, textureNumLayers, textureDimension\n */\nexport class WGSLTextureQueryTest extends GPUTest {\n  executeAndExpectResult(\n  stage,\n  code,\n  texture,\n  viewDescriptor,\n  expected)\n  {\n    const { device } = this;\n    const returnType = `vec4<u32>`;\n    const castWGSL = `${returnType}(getValue()${range(4 - expected.length, () => ', 0').join('')})`;\n    const stageWGSL =\n    stage === 'vertex' ?\n    `\n// --------------------------- vertex stage shaders --------------------------------\n@vertex fn vsVertex(\n    @builtin(vertex_index) vertex_index : u32,\n    @builtin(instance_index) instance_index : u32) -> VOut {\n  let positions = array(vec2f(-1, 3), vec2f(3, -1), vec2f(-1, -1));\n  return VOut(vec4f(positions[vertex_index], 0, 1),\n              instance_index,\n              ${castWGSL});\n}\n\n@fragment fn fsVertex(v: VOut) -> @location(0) vec4u {\n  return bitcast<vec4u>(v.result);\n}\n` :\n    stage === 'fragment' ?\n    `\n// --------------------------- fragment stage shaders --------------------------------\n@vertex fn vsFragment(\n    @builtin(vertex_index) vertex_index : u32,\n    @builtin(instance_index) instance_index : u32) -> VOut {\n  let positions = array(vec2f(-1, 3), vec2f(3, -1), vec2f(-1, -1));\n  return VOut(vec4f(positions[vertex_index], 0, 1), instance_index, ${returnType}(0));\n}\n\n@fragment fn fsFragment(v: VOut) -> @location(0) vec4u {\n  return bitcast<vec4u>(${castWGSL});\n}\n` :\n    `\n// --------------------------- compute stage shaders --------------------------------\n@group(1) @binding(0) var<storage, read_write> results: array<${returnType}>;\n\n@compute @workgroup_size(1) fn csCompute(@builtin(global_invocation_id) id: vec3u) {\n  results[id.x] = ${castWGSL};\n}\n`;\n    const wgsl = `\n      ${code}\n\nstruct VOut {\n  @builtin(position) pos: vec4f,\n  @location(0) @interpolate(flat, either) ndx: u32,\n  @location(1) @interpolate(flat, either) result: ${returnType},\n};\n\n      ${stageWGSL}\n    `;\n    const module = device.createShaderModule({ code: wgsl });\n\n    const visibility =\n    stage === 'compute' ?\n    GPUShaderStage.COMPUTE :\n    stage === 'fragment' ?\n    GPUShaderStage.FRAGMENT :\n    GPUShaderStage.VERTEX;\n\n    const entries = [];\n    if (texture instanceof GPUExternalTexture) {\n      entries.push({\n        binding: 0,\n        visibility,\n        externalTexture: {}\n      });\n    } else if (code.includes('texture_storage')) {\n      entries.push({\n        binding: 0,\n        visibility,\n        storageTexture: {\n          access: code.includes(', read>') ?\n          'read-only' :\n          code.includes(', write>') ?\n          'write-only' :\n          'read-write',\n          viewDimension: viewDescriptor?.dimension ?? '2d',\n          format: texture.format\n        }\n      });\n    } else {\n      const sampleType =\n      viewDescriptor?.aspect === 'stencil-only' ?\n      'uint' :\n      code.includes('texture_depth') ?\n      'depth' :\n      isDepthTextureFormat(texture.format) ?\n      'unfilterable-float' :\n      isStencilTextureFormat(texture.format) ?\n      'uint' :\n      texture.sampleCount > 1 && kTextureFormatInfo[texture.format].color?.type === 'float' ?\n      'unfilterable-float' :\n      kTextureFormatInfo[texture.format].color?.type ?? 'unfilterable-float';\n      entries.push({\n        binding: 0,\n        visibility,\n        texture: {\n          sampleType,\n          viewDimension: viewDescriptor?.dimension ?? '2d',\n          multisampled: texture.sampleCount > 1\n        }\n      });\n    }\n\n    const bindGroupLayouts = [device.createBindGroupLayout({ entries })];\n\n    if (stage === 'compute') {\n      bindGroupLayouts.push(\n        device.createBindGroupLayout({\n          entries: [\n          {\n            binding: 0,\n            visibility: GPUShaderStage.COMPUTE,\n            buffer: {\n              type: 'storage',\n              hasDynamicOffset: false,\n              minBindingSize: 16\n            }\n          }]\n\n        })\n      );\n    }\n\n    const layout = device.createPipelineLayout({\n      bindGroupLayouts\n    });\n\n    let pipeline;\n\n    switch (stage) {\n      case 'compute':\n        pipeline = device.createComputePipeline({\n          layout,\n          compute: { module }\n        });\n        break;\n      case 'fragment':\n      case 'vertex':\n        pipeline = device.createRenderPipeline({\n          layout,\n          vertex: { module },\n          fragment: {\n            module,\n            targets: [{ format: 'rgba32uint' }]\n          }\n        });\n        break;\n    }\n\n    const bindGroup0 = device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [\n      {\n        binding: 0,\n        resource:\n        texture instanceof GPUExternalTexture ? texture : texture.createView(viewDescriptor)\n      }]\n\n    });\n\n    const renderTarget = this.createTextureTracked({\n      format: 'rgba32uint',\n      size: [expected.length, 1],\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT\n    });\n\n    const resultBuffer = this.createBufferTracked({\n      size: align(expected.length * 4, 256),\n      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC\n    });\n\n    let storageBuffer;\n    const encoder = globalThis._TRAMPOLINE_(\"createCommandEncoder\", device, device.createCommandEncoder, [], () => device.createCommandEncoder());\n\n    if (stage === 'compute') {\n      storageBuffer = this.createBufferTracked({\n        size: resultBuffer.size,\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC\n      });\n\n      const bindGroup1 = device.createBindGroup({\n        layout: pipeline.getBindGroupLayout(1),\n        entries: [{ binding: 0, resource: { buffer: storageBuffer } }]\n      });\n\n      const pass = encoder.beginComputePass();\n      pass.setPipeline(pipeline);\n      pass.setBindGroup(0, bindGroup0);\n      pass.setBindGroup(1, bindGroup1);\n      pass.dispatchWorkgroups(expected.length);\n      pass.end();\n      encoder.copyBufferToBuffer(storageBuffer, 0, resultBuffer, 0, storageBuffer.size);\n    } else {\n      const pass = encoder.beginRenderPass({\n        colorAttachments: [\n        {\n          view: renderTarget.createView(),\n          loadOp: 'clear',\n          storeOp: 'store'\n        }]\n\n      });\n\n      pass.setPipeline(pipeline);\n      pass.setBindGroup(0, bindGroup0);\n      for (let i = 0; i < expected.length; ++i) {\n        pass.setViewport(i, 0, 1, 1, 0, 1);\n        pass.draw(3, 1, 0, i);\n      }\n      pass.end();\n      encoder.copyTextureToBuffer(\n        { texture: renderTarget },\n        {\n          buffer: resultBuffer,\n          bytesPerRow: resultBuffer.size\n        },\n        [renderTarget.width, 1]\n      );\n    }\n    globalThis._TRAMPOLINE_(\"submit\", this.device, this.device.queue.submit, [[encoder.finish()]], () => this.device.queue.submit([encoder.finish()]));\n\n    const e = new Uint32Array(4);\n    e.set(expected);\n    this.expectGPUBufferValuesEqual(resultBuffer, e);\n  }\n}\n\n/**\n * Used for textureSampleXXX\n */\nexport class WGSLTextureSampleTest extends GPUTest {\n  async init() {\n    await super.init();\n  }\n}\n\n/**\n * Used to specify a range from [0, num)\n * The type is used to determine if values should be integers and if they can be negative.\n */\n\n\n\n\n\nfunction getLimitValue(v) {\n  switch (v) {\n    case Number.POSITIVE_INFINITY:\n      return 1000;\n    case Number.NEGATIVE_INFINITY:\n      return -1000;\n    default:\n      return v;\n  }\n}\n\nfunction getMinAndMaxTexelValueForComponent(\nrep,\ncomponent)\n{\n  assert(!!rep.numericRange);\n  const perComponentRanges = rep.numericRange;\n  const perComponentRange = perComponentRanges[component];\n  const range = rep.numericRange;\n  const { min, max } = perComponentRange ? perComponentRange : range;\n  return { min: getLimitValue(min), max: getLimitValue(max) };\n}\n\n/**\n * We need the software rendering to do the same interpolation as the hardware\n * rendered so for -srgb formats we set the TexelView to an -srgb format as\n * TexelView handles this case. Note: It might be nice to add rgba32float-srgb\n * or something similar to TexelView.\n */\nexport function getTexelViewFormatForTextureFormat(format) {\n  if (format.endsWith('sint')) {\n    return 'rgba32sint';\n  } else if (format.endsWith('uint')) {\n    return 'rgba32uint';\n  }\n  return format.endsWith('-srgb') ? 'rgba8unorm-srgb' : 'rgba32float';\n}\n\nconst kTextureTypeInfo = {\n  depth: {\n    componentType: 'f32',\n    resultType: 'vec4f',\n    resultFormat: 'rgba32float'\n  },\n  float: {\n    componentType: 'f32',\n    resultType: 'vec4f',\n    resultFormat: 'rgba32float'\n  },\n  'unfilterable-float': {\n    componentType: 'f32',\n    resultType: 'vec4f',\n    resultFormat: 'rgba32float'\n  },\n  sint: {\n    componentType: 'i32',\n    resultType: 'vec4i',\n    resultFormat: 'rgba32sint'\n  },\n  uint: {\n    componentType: 'u32',\n    resultType: 'vec4u',\n    resultFormat: 'rgba32uint'\n  }\n};\n\nfunction getTextureFormatTypeInfo(format) {\n  const info = kTextureFormatInfo[format];\n  const type = info.color?.type ?? info.depth?.type ?? info.stencil?.type;\n  assert(!!type);\n  return kTextureTypeInfo[type];\n}\n\n/**\n * given a texture type 'base', returns the base with the correct component for the given texture format.\n * eg: `getTextureType('texture_2d', someUnsignedIntTextureFormat)` -> `texture_2d<u32>`\n */\nexport function appendComponentTypeForFormatToTextureType(base, format) {\n  return base.includes('depth') ?\n  base :\n  `${base}<${getTextureFormatTypeInfo(format).componentType}>`;\n}\n\n\n\n\n\n/**\n * Make a generator for texels for depth comparison tests.\n */\nexport function makeRandomDepthComparisonTexelGenerator(\ninfo,\n\n\n\ncomparison)\n{\n  const format = isUnencodableDepthFormat(info.format) ? 'depth32float' : info.format;\n  const rep = kTexelRepresentationInfo[format];\n  const size = reifyExtent3D(info.size);\n\n  const comparisonIsEqualOrNotEqual = comparison === 'equal' || comparison === 'not-equal';\n\n  // for equal and not-equal we just want to test 0, 0.6, and 1\n  // for everything else we want 0 to 1\n  // Note: 0.6 is chosen because we'll never choose 0.6 as our depth reference\n  // value. (see generateTextureBuiltinInputsImpl and generateSamplePointsCube)\n  // The problem with comparing equal is other than 0.0 and 1.0, no other\n  // values are guaranteed to be equal.\n  const fixedValues = [0, 0.6, 1, 1];\n  const encode = comparisonIsEqualOrNotEqual ?\n  (norm) => fixedValues[norm * (fixedValues.length - 1) | 0] :\n  (norm) => norm;\n\n  return (coords) => {\n    const texel = {};\n    for (const component of rep.componentOrder) {\n      const rnd = hashU32(\n        coords.x,\n        coords.y,\n        coords.z,\n        coords.sampleIndex ?? 0,\n        component.charCodeAt(0),\n        size.width,\n        size.height,\n        size.depthOrArrayLayers\n      );\n      const normalized = clamp(rnd / 0xffffffff, { min: 0, max: 1 });\n      texel[component] = encode(normalized);\n    }\n    return quantize(texel, rep);\n  };\n}\n\nfunction createRandomTexelViewViaColors(\ninfo,\n\n\n\n\noptions)\n{\n  const rep = kTexelRepresentationInfo[info.format];\n  const size = reifyExtent3D(info.size);\n  const minMax = Object.fromEntries(\n    rep.componentOrder.map((component) => [\n    component,\n    getMinAndMaxTexelValueForComponent(rep, component)]\n    )\n  );\n  const generator = (coords) => {\n    const texel = {};\n    for (const component of rep.componentOrder) {\n      const rnd = hashU32(\n        coords.x,\n        coords.y,\n        coords.z,\n        coords.sampleIndex ?? 0,\n        component.charCodeAt(0),\n        info.mipLevel,\n        size.width,\n        size.height,\n        size.depthOrArrayLayers\n      );\n      const normalized = clamp(rnd / 0xffffffff, { min: 0, max: 1 });\n      const { min, max } = minMax[component];\n      texel[component] = lerp(min, max, normalized);\n    }\n    return quantize(texel, rep);\n  };\n  return TexelView.fromTexelsAsColors(\n    info.format,\n    options?.generator ?? generator\n  );\n}\n\nfunction createRandomTexelViewViaBytes(info)\n\n\n\n\n{\n  const { format } = info;\n  const formatInfo = kTextureFormatInfo[format];\n  const rep = kTexelRepresentationInfo[info.format];\n  assert(!!rep);\n  const bytesPerBlock = formatInfo.color?.bytes ?? formatInfo.stencil?.bytes;\n  assert(bytesPerBlock > 0);\n  const size = physicalMipSize(reifyExtent3D(info.size), info.format, '2d', 0);\n  const blocksAcross = Math.ceil(size.width / formatInfo.blockWidth);\n  const blocksDown = Math.ceil(size.height / formatInfo.blockHeight);\n  const bytesPerRow = blocksAcross * bytesPerBlock * info.sampleCount;\n  const bytesNeeded = bytesPerRow * blocksDown * size.depthOrArrayLayers;\n  const data = new Uint8Array(bytesNeeded);\n\n  const hashBase =\n  sumOfCharCodesOfString(info.format) +\n  size.width +\n  size.height +\n  size.depthOrArrayLayers +\n  info.mipLevel +\n  info.sampleCount;\n\n  if (info.format.includes('32float') || info.format.includes('16float')) {\n    const { min, max } = getMinAndMaxTexelValueForComponent(rep, TexelComponent.R);\n    const asFloat = info.format.includes('32float') ?\n    new Float32Array(data.buffer) :\n    new Float16Array(data.buffer);\n    for (let i = 0; i < asFloat.length; ++i) {\n      asFloat[i] = lerp(min, max, hashU32(hashBase + i) / 0xffff_ffff);\n    }\n  } else if (bytesNeeded % 4 === 0) {\n    const asU32 = new Uint32Array(data.buffer);\n    for (let i = 0; i < asU32.length; ++i) {\n      asU32[i] = hashU32(hashBase + i);\n    }\n  } else {\n    for (let i = 0; i < bytesNeeded; ++i) {\n      data[i] = hashU32(hashBase + i);\n    }\n  }\n\n  return TexelView.fromTextureDataByReference(info.format, data, {\n    bytesPerRow,\n    rowsPerImage: size.height,\n    subrectOrigin: [0, 0, 0],\n    subrectSize: size\n  });\n}\n\n/**\n * Creates a TexelView filled with random values.\n */\nfunction createRandomTexelView(\ninfo,\n\n\n\n\n\noptions)\n{\n  assert(!isCompressedTextureFormat(info.format));\n  const formatInfo = kTextureFormatInfo[info.format];\n  const type = formatInfo.color?.type ?? formatInfo.depth?.type ?? formatInfo.stencil?.type;\n  const canFillWithRandomTypedData =\n  !options &&\n  isEncodableTextureFormat(info.format) && (\n  info.format.includes('norm') && type !== 'depth' ||\n  info.format.includes('16float') ||\n  info.format.includes('32float') && type !== 'depth' ||\n  type === 'sint' ||\n  type === 'uint');\n\n  return canFillWithRandomTypedData ?\n  createRandomTexelViewViaBytes(info) :\n  createRandomTexelViewViaColors(info, options);\n}\n\n/**\n * Creates a mip chain of TexelViews filled with random values\n */\nfunction createRandomTexelViewMipmap(\ninfo,\n\n\n\n\n\n\noptions)\n{\n  const mipLevelCount = info.mipLevelCount ?? 1;\n  const dimension = info.dimension ?? '2d';\n  return range(mipLevelCount, (i) =>\n  createRandomTexelView(\n    {\n      format: info.format,\n      size: virtualMipSize(dimension, info.size, i),\n      mipLevel: i,\n      sampleCount: info.sampleCount ?? 1\n    },\n    options\n  )\n  );\n}\n\n// Because it's easy to deal with if these types are all array of number\n\n\n\n\n\n\nconst kTextureCallArgNames = [\n'component',\n'coords',\n'derivativeMult', // NOTE: derivativeMult not an argument but is used with coords for implicit derivatives.\n'arrayIndex',\n'bias',\n'sampleIndex',\n'mipLevel',\n'ddx',\n'ddy',\n'depthRef',\n'offset'];\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst isBuiltinComparison = (builtin) =>\nbuiltin === 'textureGatherCompare' ||\nbuiltin === 'textureSampleCompare' ||\nbuiltin === 'textureSampleCompareLevel';\nconst isBuiltinGather = (builtin) =>\nbuiltin === 'textureGather' || builtin === 'textureGatherCompare';\nconst builtinNeedsSampler = (builtin) =>\nbuiltin.startsWith('textureSample') || builtin.startsWith('textureGather');\nconst builtinNeedsDerivatives = (builtin) =>\nbuiltin === 'textureSample' ||\nbuiltin === 'textureSampleBias' ||\nbuiltin === 'textureSampleCompare';\n\nconst isCubeViewDimension = (viewDescriptor) =>\nviewDescriptor?.dimension === 'cube' || viewDescriptor?.dimension === 'cube-array';\n\nconst isViewDimensionCubeOrCubeArray = (viewDimension) =>\nviewDimension === 'cube' || viewDimension === 'cube-array';\n\nconst s_u32 = new Uint32Array(1);\nconst s_f32 = new Float32Array(s_u32.buffer);\nconst s_i32 = new Int32Array(s_u32.buffer);\n\nconst kBitCastFunctions = {\n  f: (v) => {\n    s_f32[0] = v;\n    return s_u32[0];\n  },\n  i: (v) => {\n    s_i32[0] = v;\n    assert(s_i32[0] === v, 'check we are not casting non-int or out-of-range value');\n    return s_u32[0];\n  },\n  u: (v) => {\n    s_u32[0] = v;\n    assert(s_u32[0] === v, 'check we are not casting non-uint or out-of-range value');\n    return s_u32[0];\n  }\n};\n\nfunction getCallArgType(\ncall,\nargName)\n{\n  switch (argName) {\n    case 'coords':\n    case 'derivativeMult':\n      return call.coordType;\n    case 'component':\n      assert(call.componentType !== undefined);\n      return call.componentType;\n    case 'mipLevel':\n      assert(call.levelType !== undefined);\n      return call.levelType;\n    case 'arrayIndex':\n      assert(call.arrayIndexType !== undefined);\n      return call.arrayIndexType;\n    case 'sampleIndex':\n      assert(call.sampleIndexType !== undefined);\n      return call.sampleIndexType;\n    case 'bias':\n    case 'depthRef':\n    case 'ddx':\n    case 'ddy':\n      return 'f';\n    default:\n      unreachable();\n  }\n}\n\nfunction toArray(coords) {\n  if (coords instanceof Array) {\n    return coords;\n  }\n  return [coords];\n}\n\nfunction quantize(texel, repl) {\n  return repl.bitsToNumber(repl.unpackBits(new Uint8Array(repl.pack(repl.encode(texel)))));\n}\n\nfunction apply(a, b, op) {\n  assert(a.length === b.length, `apply(${a}, ${b}): arrays must have same length`);\n  return a.map((v, i) => op(v, b[i]));\n}\n\n/**\n * At the corner of a cubemap we need to sample just 3 texels, not 4.\n * The texels are in\n *\n *   0:  (u,v)\n *   1:  (u + 1, v)\n *   2:  (u, v + 1)\n *   3:  (u + 1, v + 1)\n *\n * We pass in the original 2d (converted from cubemap) texture coordinate.\n * If it's within half a pixel of the edge in both directions then it's\n * a corner so we return the index of the one texel that's not needed.\n * Otherwise we return -1.\n */\nfunction getUnusedCubeCornerSampleIndex(textureSize, coords) {\n  const u = coords[0] * textureSize;\n  const v = coords[1] * textureSize;\n  if (v < 0.5) {\n    if (u < 0.5) {\n      return 0;\n    } else if (u >= textureSize - 0.5) {\n      return 1;\n    }\n  } else if (v >= textureSize - 0.5) {\n    if (u < 0.5) {\n      return 2;\n    } else if (u >= textureSize - 0.5) {\n      return 3;\n    }\n  }\n  return -1;\n}\n\nconst add = (a, b) => apply(a, b, (x, y) => x + y);\n\n\n\n\n\n\n\n/**\n * Converts the src texel representation to an RGBA representation.\n */\nfunction convertPerTexelComponentToResultFormat(\nsrc,\nformat)\n{\n  const rep = kTexelRepresentationInfo[format];\n  const out = { R: 0, G: 0, B: 0, A: 1 };\n  for (const component of rep.componentOrder) {\n    switch (component) {\n      case 'Stencil':\n      case 'Depth':\n        out.R = src[component];\n        break;\n      default:\n        assert(out[component] !== undefined); // checks that component = R, G, B or A\n        out[component] = src[component];\n    }\n  }\n  return out;\n}\n\n/**\n * Convert RGBA result format to texel view format.\n * Example, converts\n *   { R: 0.1, G: 0, B: 0, A: 1 } to { Depth: 0.1 }\n *   { R: 0.1 } to { R: 0.1, G: 0, B: 0, A: 1 }\n */\nfunction convertToTexelViewFormat(src, format) {\n  const componentOrder = isDepthTextureFormat(format) ?\n  [TexelComponent.Depth] :\n  isStencilTextureFormat(format) ?\n  [TexelComponent.Stencil] :\n  [TexelComponent.R, TexelComponent.G, TexelComponent.B, TexelComponent.A];\n  const out = {};\n  for (const component of componentOrder) {\n    let v = src[component];\n    if (v === undefined) {\n      if (component === 'Depth' || component === 'Stencil') {\n        v = src.R;\n      } else if (component === 'G' || component === 'B') {\n        v = 0;\n      } else {\n        v = 1;\n      }\n    }\n    out[component] = v;\n  }\n  return out;\n}\n\n/**\n * Convert RGBA result format to texel view format of src texture.\n * Effectively this converts something like { R: 0.1, G: 0, B: 0, A: 1 }\n * to { Depth: 0.1 }\n */\nfunction convertResultFormatToTexelViewFormat(\nsrc,\nformat)\n{\n  const rep = kTexelRepresentationInfo[format];\n  const out = {};\n  for (const component of rep.componentOrder) {\n    out[component] = src[component] ?? src.R;\n  }\n  return out;\n}\n\nfunction zeroValuePerTexelComponent(components) {\n  const out = {};\n  for (const component of components) {\n    out[component] = 0;\n  }\n  return out;\n}\n\nconst kSamplerFns = {\n  never: (ref, v) => false,\n  less: (ref, v) => ref < v,\n  equal: (ref, v) => ref === v,\n  'less-equal': (ref, v) => ref <= v,\n  greater: (ref, v) => ref > v,\n  'not-equal': (ref, v) => ref !== v,\n  'greater-equal': (ref, v) => ref >= v,\n  always: (ref, v) => true\n};\n\nfunction applyCompare(\ncall,\nsampler,\ncomponents,\nsrc)\n{\n  if (isBuiltinComparison(call.builtin)) {\n    assert(sampler !== undefined);\n    assert(call.depthRef !== undefined);\n    const out = {};\n    const compareFn = kSamplerFns[sampler.compare];\n    for (const component of components) {\n      out[component] = compareFn(call.depthRef, src[component]) ? 1 : 0;\n    }\n    return out;\n  } else {\n    return src;\n  }\n}\n\n/**\n * Returns the expect value for a WGSL builtin texture function for a single\n * mip level\n */\nfunction softwareTextureReadMipLevel(\ncall,\ntexture,\nsampler,\nmipLevel)\n{\n  assert(mipLevel % 1 === 0);\n  const { format } = texture.texels[0];\n  const rep = kTexelRepresentationInfo[format];\n  const textureSize = virtualMipSize(\n    texture.descriptor.dimension || '2d',\n    texture.descriptor.size,\n    mipLevel\n  );\n  const addressMode =\n  call.builtin === 'textureSampleBaseClampToEdge' ?\n  ['clamp-to-edge', 'clamp-to-edge', 'clamp-to-edge'] :\n  [\n  sampler?.addressModeU ?? 'clamp-to-edge',\n  sampler?.addressModeV ?? 'clamp-to-edge',\n  sampler?.addressModeW ?? 'clamp-to-edge'];\n\n\n  const isCube = isCubeViewDimension(texture.viewDescriptor);\n  const arrayIndexMult = isCube ? 6 : 1;\n  const numLayers = textureSize[2] / arrayIndexMult;\n  assert(numLayers % 1 === 0);\n  const textureSizeForCube = [textureSize[0], textureSize[1], 6];\n\n  const load = (at) => {\n    const zFromArrayIndex =\n    call.arrayIndex !== undefined ?\n    clamp(call.arrayIndex, { min: 0, max: numLayers - 1 }) * arrayIndexMult :\n    0;\n    return texture.texels[mipLevel].color({\n      x: Math.floor(at[0]),\n      y: Math.floor(at[1] ?? 0),\n      z: Math.floor(at[2] ?? 0) + zFromArrayIndex,\n      sampleIndex: call.sampleIndex\n    });\n  };\n\n  switch (call.builtin) {\n    case 'textureGather':\n    case 'textureGatherCompare':\n    case 'textureSample':\n    case 'textureSampleBias':\n    case 'textureSampleBaseClampToEdge':\n    case 'textureSampleCompare':\n    case 'textureSampleCompareLevel':\n    case 'textureSampleGrad':\n    case 'textureSampleLevel':{\n        let coords = toArray(call.coords);\n\n        if (isCube) {\n          coords = convertCubeCoordToNormalized3DTextureCoord(coords);\n        }\n\n        // convert normalized to absolute texel coordinate\n        // ┌───┬───┬───┬───┐\n        // │ a │   │   │   │  norm: a = 1/8, b = 7/8\n        // ├───┼───┼───┼───┤   abs: a = 0,   b = 3\n        // │   │   │   │   │\n        // ├───┼───┼───┼───┤\n        // │   │   │   │   │\n        // ├───┼───┼───┼───┤\n        // │   │   │   │ b │\n        // └───┴───┴───┴───┘\n        let at = coords.map((v, i) => v * (isCube ? textureSizeForCube : textureSize)[i] - 0.5);\n\n        // Apply offset in whole texel units\n        // This means the offset is added at each mip level in texels. There's no\n        // scaling for each level.\n        if (call.offset !== undefined) {\n          at = add(at, toArray(call.offset));\n        }\n\n        const samples = [];\n\n        const filter = isBuiltinGather(call.builtin) ? 'linear' : sampler?.minFilter ?? 'nearest';\n        switch (filter) {\n          case 'linear':{\n              // 'p0' is the lower texel for 'at'\n              const p0 = at.map((v) => Math.floor(v));\n              // 'p1' is the higher texel for 'at'\n              // If it's cube then don't advance Z.\n              const p1 = p0.map((v, i) => v + (isCube ? i === 2 ? 0 : 1 : 1));\n\n              // interpolation weights for p0 and p1\n              const p1W = at.map((v, i) => v - p0[i]);\n              const p0W = p1W.map((v) => 1 - v);\n\n              switch (coords.length) {\n                case 1:\n                  samples.push({ at: p0, weight: p0W[0] });\n                  samples.push({ at: p1, weight: p1W[0] });\n                  break;\n                case 2:{\n                    // Note: These are ordered to match textureGather\n                    samples.push({ at: [p0[0], p1[1]], weight: p0W[0] * p1W[1] });\n                    samples.push({ at: p1, weight: p1W[0] * p1W[1] });\n                    samples.push({ at: [p1[0], p0[1]], weight: p1W[0] * p0W[1] });\n                    samples.push({ at: p0, weight: p0W[0] * p0W[1] });\n                    break;\n                  }\n                case 3:{\n                    // cube sampling, here in the software renderer, is the same\n                    // as 2d sampling. We'll sample at most 4 texels. The weights are\n                    // the same as if it was just one plane. If the points fall outside\n                    // the slice they'll be wrapped by wrapFaceCoordToCubeFaceAtEdgeBoundaries\n                    // below.\n                    if (isCube) {\n                      // Note: These are ordered to match textureGather\n                      samples.push({ at: [p0[0], p1[1], p0[2]], weight: p0W[0] * p1W[1] });\n                      samples.push({ at: p1, weight: p1W[0] * p1W[1] });\n                      samples.push({ at: [p1[0], p0[1], p0[2]], weight: p1W[0] * p0W[1] });\n                      samples.push({ at: p0, weight: p0W[0] * p0W[1] });\n                      const ndx = getUnusedCubeCornerSampleIndex(textureSize[0], coords);\n                      if (ndx >= 0) {\n                        // # Issues with corners of cubemaps\n                        //\n                        // note: I tried multiple things here\n                        //\n                        // 1. distribute 1/3 of the weight of the removed sample to each of the remaining samples\n                        // 2. distribute 1/2 of the weight of the removed sample to the 2 samples that are not the \"main\" sample.\n                        // 3. normalize the weights of the remaining 3 samples.\n                        //\n                        // none of them matched the M1 in all cases. Checking the dEQP I found this comment\n                        //\n                        // > If any of samples is out of both edges, implementations can do pretty much anything according to spec.\n                        // https://github.com/KhronosGroup/VK-GL-CTS/blob/d2d6aa65607383bb29c8398fe6562c6b08b4de57/framework/common/tcuTexCompareVerifier.cpp#L882\n                        //\n                        // If I understand this correctly it matches the OpenGL ES 3.1 spec it says\n                        // it's implementation defined.\n                        //\n                        // > OpenGL ES 3.1 section 8.12.1 Seamless Cubemap Filtering\n                        // >\n                        // > -  If a texture sample location would lie in the texture\n                        // >    border in both u and v (in one of the corners of the\n                        // >    cube), there is no unique neighboring face from which to\n                        // >    extract one texel. The recommended method to generate this\n                        // >    texel is to average the values of the three available\n                        // >    samples. However, implementations are free to construct\n                        // >    this fourth texel in another way, so long as, when the\n                        // >    three available samples have the same value, this texel\n                        // >    also has that value.\n                        //\n                        // I'm not sure what \"average the values of the three available samples\"\n                        // means. To me that would be (a+b+c)/3 or in other words, set all the\n                        // weights to 0.33333 but that's not what the M1 is doing.\n                        //\n                        // We could check that, given the 3 texels at the corner, if all 3 texels\n                        // are the same value then the result must be the same value. Otherwise,\n                        // the result must be between the 3 values. For now, the code that\n                        // chooses test coordinates avoids corners. This has the restriction\n                        // that the smallest mip level be at least 4x4 so there are some non\n                        // corners to choose from.\n                        unreachable(\n                          `corners of cubemaps are not testable:\\n   ${describeTextureCall(call)}`\n                        );\n                      }\n                    } else {\n                      const p = [p0, p1];\n                      const w = [p0W, p1W];\n                      for (let z = 0; z < 2; ++z) {\n                        for (let y = 0; y < 2; ++y) {\n                          for (let x = 0; x < 2; ++x) {\n                            samples.push({\n                              at: [p[x][0], p[y][1], p[z][2]],\n                              weight: w[x][0] * w[y][1] * w[z][2]\n                            });\n                          }\n                        }\n                      }\n                    }\n                    break;\n                  }\n              }\n              break;\n            }\n          case 'nearest':{\n              const p = at.map((v) => Math.round(quantizeToF32(v)));\n              samples.push({ at: p, weight: 1 });\n              break;\n            }\n          default:\n            unreachable();\n        }\n\n        if (isBuiltinGather(call.builtin)) {\n          const componentNdx = call.component ?? 0;\n          assert(componentNdx >= 0 && componentNdx < 4);\n          assert(samples.length === 4);\n          const component = kRGBAComponents[componentNdx];\n          const out = {};\n          samples.forEach((sample, i) => {\n            const c = isCube ?\n            wrapFaceCoordToCubeFaceAtEdgeBoundaries(textureSize[0], sample.at) :\n            applyAddressModesToCoords(addressMode, textureSize, sample.at);\n            const v = load(c);\n            const postV = applyCompare(call, sampler, rep.componentOrder, v);\n            const rgba = convertPerTexelComponentToResultFormat(postV, format);\n            out[kRGBAComponents[i]] = rgba[component];\n          });\n          return out;\n        }\n\n        const out = {};\n        for (const sample of samples) {\n          const c = isCube ?\n          wrapFaceCoordToCubeFaceAtEdgeBoundaries(textureSize[0], sample.at) :\n          applyAddressModesToCoords(addressMode, textureSize, sample.at);\n          const v = load(c);\n          const postV = applyCompare(call, sampler, rep.componentOrder, v);\n          for (const component of rep.componentOrder) {\n            out[component] = (out[component] ?? 0) + postV[component] * sample.weight;\n          }\n        }\n\n        return convertPerTexelComponentToResultFormat(out, format);\n      }\n    case 'textureLoad':{\n        const out = isOutOfBoundsCall(texture, call) ?\n        zeroValuePerTexelComponent(rep.componentOrder) :\n        load(call.coords);\n        return convertPerTexelComponentToResultFormat(out, format);\n      }\n    default:\n      unreachable();\n  }\n}\n\n/**\n * Reads a texture, optionally sampling between 2 mipLevels\n */\nfunction softwareTextureReadLevel(\nt,\nstage,\ncall,\ntexture,\nsampler,\nmipLevel)\n{\n  const mipLevelCount = texture.texels.length;\n  const maxLevel = mipLevelCount - 1;\n\n  if (!sampler) {\n    return softwareTextureReadMipLevel(call, texture, sampler, mipLevel);\n  }\n\n  const effectiveMipmapFilter = isBuiltinGather(call.builtin) ? 'nearest' : sampler.mipmapFilter;\n  switch (effectiveMipmapFilter) {\n    case 'linear':{\n        const clampedMipLevel = clamp(mipLevel, { min: 0, max: maxLevel });\n        const baseMipLevel = Math.floor(clampedMipLevel);\n        const nextMipLevel = Math.ceil(clampedMipLevel);\n        const t0 = softwareTextureReadMipLevel(call, texture, sampler, baseMipLevel);\n        const t1 = softwareTextureReadMipLevel(call, texture, sampler, nextMipLevel);\n        const weightType = call.builtin === 'textureSampleLevel' ? 'sampleLevelWeights' : 'identity';\n        const mix = getWeightForMipLevel(t, stage, weightType, mipLevelCount, clampedMipLevel);\n        assert(mix >= 0 && mix <= 1);\n        const values = [\n        { v: t0, weight: 1 - mix },\n        { v: t1, weight: mix }];\n\n        const out = {};\n        for (const { v, weight } of values) {\n          for (const component of kRGBAComponents) {\n            out[component] = (out[component] ?? 0) + v[component] * weight;\n          }\n        }\n        return out;\n      }\n    default:{\n        const baseMipLevel = Math.floor(\n          clamp(mipLevel + 0.5, { min: 0, max: texture.texels.length - 1 })\n        );\n        return softwareTextureReadMipLevel(call, texture, sampler, baseMipLevel);\n      }\n  }\n}\n\nfunction computeMipLevelFromGradients(\nddx,\nddy,\nsize)\n{\n  const texSize = reifyExtent3D(size);\n  const textureSize = [texSize.width, texSize.height, texSize.depthOrArrayLayers];\n\n  // Compute the mip level the same way textureSampleGrad does according to the spec.\n  const scaledDdx = ddx.map((v, i) => v * textureSize[i]);\n  const scaledDdy = ddy.map((v, i) => v * textureSize[i]);\n  const dotDDX = dotProduct(scaledDdx, scaledDdx);\n  const dotDDY = dotProduct(scaledDdy, scaledDdy);\n  const deltaMax = Math.max(dotDDX, dotDDY);\n  const mipLevel = 0.5 * Math.log2(deltaMax);\n  return mipLevel;\n}\n\nfunction computeMipLevelFromGradientsForCall(\ncall,\nsize)\n{\n  assert(!!call.ddx);\n  assert(!!call.ddy);\n  // ddx and ddy are the values that would be passed to textureSampleGrad\n  // If we're emulating textureSample then they're the computed derivatives\n  // such that if we passed them to textureSampleGrad they'd produce the\n  // same result.\n  const ddx = typeof call.ddx === 'number' ? [call.ddx] : call.ddx;\n  const ddy = typeof call.ddy === 'number' ? [call.ddy] : call.ddy;\n\n  return computeMipLevelFromGradients(ddx, ddy, size);\n}\n\n/**\n * The software version of textureSampleGrad except with optional level.\n */\nfunction softwareTextureReadGrad(\nt,\nstage,\ncall,\ntexture,\nsampler)\n{\n  const bias = call.bias === undefined ? 0 : clamp(call.bias, { min: -16.0, max: 15.99 });\n  if (call.ddx) {\n    const mipLevel = computeMipLevelFromGradientsForCall(call, texture.descriptor.size);\n    const mipLevelCount = texture.descriptor.mipLevelCount ?? 1;\n    const clampedMipLevel = clamp(mipLevel + bias, { min: 0, max: mipLevelCount - 1 });\n    const weightMipLevel = mapSoftwareMipLevelToGPUMipLevel(t, stage, clampedMipLevel);\n    return softwareTextureReadLevel(t, stage, call, texture, sampler, weightMipLevel);\n  } else {\n    return softwareTextureReadLevel(t, stage, call, texture, sampler, (call.mipLevel ?? 0) + bias);\n  }\n}\n\n/**\n * This must match the code in doTextureCalls for derivativeBase\n *\n * Note: normal implicit derivatives are computed like this\n *\n * fn textureSample(T, S, coord) -> vec4f {\n *    return textureSampleGrad(T, S, dpdx(coord), dpdy(coord));\n * }\n *\n * dpdx and dpdy are effectively computed by,\n * getting the values of coord for 2x2 adjacent texels.\n *\n *   p0 = coord value at x, y\n *   p1 = coord value at x + 1, y\n *   p2 = coord value at x, y + 1\n *   p3 = coord value at x + 1, y + 1\n *\n * dpdx is the average delta in x and dpdy is the average delta in y\n *\n *   dpdx = (p1 - p0 + p3 - p2) / 2   // average of horizontal change\n *   dpdy = (p2 - p0 + p3 - p1) / 2   // average of vertical change\n *\n * derivativeBase is\n *\n *       '1d'    '2d'     '3d'\n *   p0 = [0]   [0, 0]  [0, 0, 0]\n *   p1 = [1]   [1, 0]  [1, 0, 0]\n *   p2 = [0]   [0, 1]  [0, 1, 0]\n *   p3 = [1]   [1, 1]  [1, 1, 0]\n *\n * But, these values are normalized texels coords so if the src texture\n * is 8x8 these would be * 0.125\n *\n * Note: to test other derivatives we add in a multiplier but,\n * this base gives us something to add that starts at 0,0 at the call\n * but who's derivatives we can easily set. We need the default\n * derivativeBase to be 1 otherwise it's 0 which makes the computed mip level\n * be -Infinity which means bias in `textureSampleBias` has no meaning.\n */\nfunction derivativeBaseForCall(texture, isDDX) {\n  const texSize = reifyExtent3D(texture.descriptor.size);\n  const textureSize = [texSize.width, texSize.height, texSize.depthOrArrayLayers];\n  if (isCubeViewDimension(texture.viewDescriptor)) {\n    return isDDX ? [1 / textureSize[0], 0, 1] : [0, 1 / textureSize[1], 1];\n  } else if (texture.descriptor.dimension === '3d') {\n    return isDDX ? [1 / textureSize[0], 0, 0] : [0, 1 / textureSize[1], 0];\n  } else if (texture.descriptor.dimension === '1d') {\n    return [1 / textureSize[0]];\n  } else {\n    return isDDX ? [1 / textureSize[0], 0] : [0, 1 / textureSize[1]];\n  }\n}\n\n/**\n * Multiplies derivativeBase by derivativeMult or 1\n */\nfunction derivativeForCall(\ntexture,\ncall,\nisDDX)\n{\n  const dd = derivativeBaseForCall(texture, isDDX);\n  return dd.map((v, i) => v * (call.derivativeMult?.[i] ?? 1));\n}\n\nfunction softwareTextureRead(\nt,\nstage,\ncall,\ntexture,\nsampler)\n{\n  // add the implicit derivatives that we use from WGSL in doTextureCalls\n  if (builtinNeedsDerivatives(call.builtin) && !call.ddx) {\n    const newCall = {\n      ...call,\n      ddx: call.ddx ?? derivativeForCall(texture, call, true),\n      ddy: call.ddy ?? derivativeForCall(texture, call, false)\n    };\n    call = newCall;\n  }\n  return softwareTextureReadGrad(t, stage, call, texture, sampler);\n}\n\n\n\n\n\n\n\n\n\n\n/**\n * out of bounds is defined as any of the following being true\n *\n * * coords is outside the range [0, textureDimensions(t, level))\n * * array_index is outside the range [0, textureNumLayers(t))\n * * level is outside the range [0, textureNumLevels(t))\n * * sample_index is outside the range [0, textureNumSamples(s))\n */\nfunction isOutOfBoundsCall(texture, call) {\n  assert(call.coords !== undefined);\n\n  const desc = reifyTextureDescriptor(texture.descriptor);\n  const { coords, mipLevel, arrayIndex, sampleIndex } = call;\n\n  if (mipLevel !== undefined && (mipLevel < 0 || mipLevel >= desc.mipLevelCount)) {\n    return true;\n  }\n\n  const size = virtualMipSize(\n    texture.descriptor.dimension || '2d',\n    texture.descriptor.size,\n    mipLevel ?? 0\n  );\n\n  for (let i = 0; i < coords.length; ++i) {\n    const v = coords[i];\n    if (v < 0 || v >= size[i]) {\n      return true;\n    }\n  }\n\n  if (arrayIndex !== undefined) {\n    const size = reifyExtent3D(desc.size);\n    if (arrayIndex < 0 || arrayIndex >= size.depthOrArrayLayers) {\n      return true;\n    }\n  }\n\n  if (sampleIndex !== undefined) {\n    if (sampleIndex < 0 || sampleIndex >= desc.sampleCount) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction isValidOutOfBoundsValue(\ntexture,\ngotRGBA,\nmaxFractionalDiff)\n{\n  // For a texture builtin with no sampler (eg textureLoad),\n  // any out of bounds access is allowed to return one of:\n  //\n  // * the value of any texel in the texture\n  // * 0,0,0,0 or 0,0,0,1 if not a depth texture\n  // * 0 if a depth texture\n  if (texture.descriptor.format.includes('depth')) {\n    if (gotRGBA.R === 0) {\n      return true;\n    }\n  } else {\n    if (\n    gotRGBA.R === 0 &&\n    gotRGBA.B === 0 &&\n    gotRGBA.G === 0 && (\n    gotRGBA.A === 0 || gotRGBA.A === 1))\n    {\n      return true;\n    }\n  }\n\n  // Can be any texel value\n  for (let mipLevel = 0; mipLevel < texture.texels.length; ++mipLevel) {\n    const mipTexels = texture.texels[mipLevel];\n    const size = virtualMipSize(\n      texture.descriptor.dimension || '2d',\n      texture.descriptor.size,\n      mipLevel\n    );\n    const sampleCount = texture.descriptor.sampleCount ?? 1;\n    for (let z = 0; z < size[2]; ++z) {\n      for (let y = 0; y < size[1]; ++y) {\n        for (let x = 0; x < size[0]; ++x) {\n          for (let sampleIndex = 0; sampleIndex < sampleCount; ++sampleIndex) {\n            const texel = mipTexels.color({ x, y, z, sampleIndex });\n            const rgba = convertPerTexelComponentToResultFormat(texel, mipTexels.format);\n            if (\n            texelsApproximatelyEqual(\n              gotRGBA,\n              texture.descriptor.format,\n              rgba,\n              mipTexels.format,\n              maxFractionalDiff\n            ))\n            {\n              return true;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return false;\n}\n\n/**\n * For a texture builtin with no sampler (eg textureLoad),\n * any out of bounds access is allowed to return one of:\n *\n * * the value of any texel in the texture\n * * 0,0,0,0 or 0,0,0,1 if not a depth texture\n * * 0 if a depth texture\n */\nfunction okBecauseOutOfBounds(\ntexture,\ncall,\ngotRGBA,\nmaxFractionalDiff)\n{\n  if (!isOutOfBoundsCall(texture, call)) {\n    return false;\n  }\n\n  return isValidOutOfBoundsValue(texture, gotRGBA, maxFractionalDiff);\n}\n\nconst kRGBAComponents = [\nTexelComponent.R,\nTexelComponent.G,\nTexelComponent.B,\nTexelComponent.A];\n\n\nconst kRComponent = [TexelComponent.R];\n\n/**\n * Compares two Texels\n */\nexport function texelsApproximatelyEqual(\ngotRGBA,\ngotFormat,\nexpectRGBA,\nexpectedFormat,\nmaxFractionalDiff)\n{\n  const rep = kTexelRepresentationInfo[expectedFormat];\n  const got = convertResultFormatToTexelViewFormat(gotRGBA, expectedFormat);\n  const expect = convertResultFormatToTexelViewFormat(expectRGBA, expectedFormat);\n  const gULP = convertPerTexelComponentToResultFormat(\n    rep.bitsToULPFromZero(rep.numberToBits(got)),\n    expectedFormat\n  );\n  const eULP = convertPerTexelComponentToResultFormat(\n    rep.bitsToULPFromZero(rep.numberToBits(expect)),\n    expectedFormat\n  );\n\n  const rgbaComponentsToCheck = isDepthOrStencilTextureFormat(gotFormat) ?\n  kRComponent :\n  kRGBAComponents;\n\n  for (const component of rgbaComponentsToCheck) {\n    const g = gotRGBA[component];\n    const e = expectRGBA[component];\n    const absDiff = Math.abs(g - e);\n    const ulpDiff = Math.abs(gULP[component] - eULP[component]);\n    if (ulpDiff > 3 && absDiff > maxFractionalDiff) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// If it's `textureGather` then we need to convert all values to one component.\n// In other words, imagine the format is rg11b10ufloat. If it was\n// `textureSample` we'd have `r11, g11, b10, a=1` but for `textureGather`\n//\n// component = 0 => `r11, r11, r11, r11`\n// component = 1 => `g11, g11, g11, g11`\n// component = 2 => `b10, b10, b10, b10`\n//\n// etc..., each from a different texel\n//\n// The Texel utils don't handle this. So if `component = 2` we take each value,\n// copy it to the `B` component, run it through the texel utils so it returns\n// the correct ULP for a 10bit float (not an 11 bit float). Then copy it back to\n// the channel it came from.\nfunction getULPFromZeroForComponents(\nrgba,\nformat,\nbuiltin,\ncomponentNdx)\n{\n  const rep = kTexelRepresentationInfo[format];\n  if (isBuiltinGather(builtin)) {\n    const out = {};\n    const component = kRGBAComponents[componentNdx ?? 0];\n    const temp = { R: 0, G: 0, B: 0, A: 1 };\n    for (const comp of kRGBAComponents) {\n      temp[component] = rgba[comp];\n      const texel = convertResultFormatToTexelViewFormat(temp, format);\n      const ulp = convertPerTexelComponentToResultFormat(\n        rep.bitsToULPFromZero(rep.numberToBits(texel)),\n        format\n      );\n      out[comp] = ulp[component];\n    }\n    return out;\n  } else {\n    const texel = convertResultFormatToTexelViewFormat(rgba, format);\n    return convertPerTexelComponentToResultFormat(\n      rep.bitsToULPFromZero(rep.numberToBits(texel)),\n      format\n    );\n  }\n}\n\n/**\n * Checks the result of each call matches the expected result.\n */\nexport async function checkCallResults(\nt,\ntexture,\ntextureType,\nsampler,\ncalls,\nresults,\nshortShaderStage,\ngpuTexture)\n{\n  const stage = kShortShaderStageToShaderStage[shortShaderStage];\n  if (builtinNeedsMipLevelWeights(calls[0].builtin)) {\n    await initMipLevelWeightsForDevice(t, stage);\n  }\n\n  let haveComparisonCheckInfo = false;\n  let checkInfo = {\n    runner: results.runner,\n    calls,\n    sampler\n  };\n  // These are only read if the tests fail. They are used to get the values from the\n  // GPU texture for displaying in diagnostics.\n  let gpuTexels;\n  const errs = [];\n  const format = texture.texels[0].format;\n  const size = reifyExtent3D(texture.descriptor.size);\n  const maxFractionalDiff =\n  sampler?.minFilter === 'linear' ||\n  sampler?.magFilter === 'linear' ||\n  sampler?.mipmapFilter === 'linear' ?\n  getMaxFractionalDiffForTextureFormat(texture.descriptor.format) :\n  0;\n\n  for (let callIdx = 0; callIdx < calls.length; callIdx++) {\n    const call = calls[callIdx];\n    const gotRGBA = results.results[callIdx];\n    const expectRGBA = softwareTextureRead(t, stage, call, texture, sampler);\n    // Issues with textureSampleBias\n    //\n    // textureSampleBias tests start to get unexpected results when bias >= ~12\n    // where the mip level selected by the GPU is off by +/- 0.41.\n    //\n    // The issue is probably an internal precision issue. In order to test a bias of 12\n    // we choose a target mip level between 0 and mipLevelCount - 1. For example 0.4.\n    // We then compute what mip level we need the derivatives to select such that when\n    // we add in the bias it will result in a mip level of 0.4.  For a bias of 12\n    // that's means we need the derivatives to select mip level -11.4. That means\n    // the derivatives are `pow(2, -11.4) / textureSize` so for a texture that's 16\n    // pixels wide that's `0.00002312799936691891`. I'm just guessing some of that\n    // gets rounded off leading. For example, if we round it ourselves.\n    //\n    // | derivative             | mip level |\n    // +------------------------+-----------+\n    // | 0.00002312799936691891 | -11.4     |\n    // | 0.000022               | -11.47    |\n    // | 0.000023               | -11.408   |\n    // | 0.000024               | -11.34    |\n    // +------------------------+-----------+\n    //\n    // Note: As an example of a bad case: set `callSpecificMaxFractionalDiff = maxFractionalDiff` below\n    // then run `webgpu:shader,execution,expression,call,builtin,textureSampleBias:sampled_2d_coords:format=\"astc-6x6-unorm\";filt=\"linear\";modeU=\"m\";modeV=\"m\";offset=false`\n    // on an M1 Mac.\n    //\n    // ```\n    // EXPECTATION FAILED: subcase: samplePoints=\"spiral\"\n    // result was not as expected:\n    //       size: [18, 18, 1]\n    //   mipCount: 3\n    //       call: textureSampleBias(texture: T, sampler: S, coords: vec2f(0.1527777777777778, 1.4166666666666667) + derivativeBase * derivativeMult(vec2f(0.00002249990733551491, 0)), bias: f32(15.739721414633095))  // #32\n    //           : as texel coord @ mip level[0]: (2.750, 25.500)\n    //           : as texel coord @ mip level[1]: (1.375, 12.750)\n    //           : as texel coord @ mip level[2]: (0.611, 5.667)\n    // implicit derivative based mip level: -15.439721414633095 (without bias)\n    //                        clamped bias: 15.739721414633095\n    //                 mip level with bias: 0.3000000000000007\n    //        got: 0.555311381816864, 0.7921856045722961, 0.8004884123802185, 0.38046398758888245\n    //   expected: 0.6069580801937625, 0.7999182825318225, 0.8152446179041957, 0.335314491045024\n    //   max diff: 0.027450980392156862\n    //  abs diffs: 0.0516466983768985, 0.007732677959526368, 0.014756205523977162, 0.04514949654385847\n    //  rel diffs: 8.51%, 0.97%, 1.81%, 11.87%\n    //  ulp diffs: 866488, 129733, 247568, 1514966\n    //\n    //   sample points:\n    // expected:                                                                   | got:\n    // ...\n    // a: mip(0) at: [ 2, 10,  0], weight: 0.52740                                 | a: mip(0) at: [ 2, 10,  0], weight: 0.60931\n    // b: mip(0) at: [ 3, 10,  0], weight: 0.17580                                 | b: mip(0) at: [ 3, 10,  0], weight: 0.20319\n    // a: value: R: 0.46642, G: 0.77875, B: 0.77509, A: 0.45788                    | a: value: R: 0.46642, G: 0.77875, B: 0.77509, A: 0.45788\n    // b: value: R: 0.46642, G: 0.77875, B: 0.77509, A: 0.45788                    | b: value: R: 0.46642, G: 0.77875, B: 0.77509, A: 0.45788\n    // mip level (0) weight: 0.70320                                               | mip level (0) weight: 0.81250\n    // ```\n    //\n    // Notice above the \"expected\" level weight (0.7) matches the \"mip level with bias (0.3)\" which is\n    // the mip level we expected the GPU to select. Selecting mip level 0.3 will do `mix(level0, level1, 0.3)`\n    // which is 0.7 of level 0 and 0.3 of level 1. Notice the \"got\" level weight is 0.81 which is pretty far off.\n    //\n    // Just looking at the failures, the largest formula below makes most of the tests pass\n    //\n    // MAINTENANCE_TODO: Consider different solutions for this issue\n    //\n    // 1. Try to figure out what the exact rounding issue is the take it into account\n    //\n    // 2. The code currently samples the texture once via the GPU and once via softwareTextureRead. These values are\n    //    \"got:\" and \"expected:\" above. The test only fails if they are too different. We could rather get the bilinear\n    //    sample from every mip level and then check the \"got\" value is between 2 of the levels (or equal if nearest).\n    //    In other words.\n    //\n    //        if (bias >= 12)\n    //          colorForEachMipLevel = range(mipLevelCount, mipLevel => softwareTextureReadLevel(..., mipLevel))\n    //          if nearest\n    //            pass = got === one of colorForEachMipLevel\n    //          else // linear\n    //            pass = false;\n    //            for (i = 0; !pass && i < mipLevelCount - 1; i)\n    //              pass = got is between colorForEachMipLevel[i] and colorForEachMipLevel[i + 1]\n    //\n    //    This would check \"something\" but effectively it would no longer be checking \"bias\" for values > 12. Only that\n    //    textureSampleBias returns some possible answer vs some completely wrong answer.\n    //\n    // 3. It's possible this check is just not possible given the precision required. We could just check bias -16 to 12\n    //    and ignore values > 12. We won't be able to test clamping but maybe that's irrelevant.\n    //\n    const callSpecificMaxFractionalDiff =\n    call.bias >= 12 ? maxFractionalDiff * (2 + call.bias - 12) : maxFractionalDiff;\n\n    // The spec says depth and stencil have implementation defined values for G, B, and A\n    // so if this is `textureGather` and component > 0 then there's nothing to check.\n    if (\n    isDepthOrStencilTextureFormat(format) &&\n    isBuiltinGather(call.builtin) &&\n    call.component > 0)\n    {\n      continue;\n    }\n\n    if (\n    texelsApproximatelyEqual(\n      gotRGBA,\n      texture.descriptor.format,\n      expectRGBA,\n      format,\n      callSpecificMaxFractionalDiff\n    ))\n    {\n      continue;\n    }\n\n    if (!sampler && okBecauseOutOfBounds(texture, call, gotRGBA, callSpecificMaxFractionalDiff)) {\n      continue;\n    }\n\n    const gULP = getULPFromZeroForComponents(gotRGBA, format, call.builtin, call.component);\n    const eULP = getULPFromZeroForComponents(expectRGBA, format, call.builtin, call.component);\n\n    // from the spec: https://gpuweb.github.io/gpuweb/#reading-depth-stencil\n    // depth and stencil values are D, ?, ?, ?\n    const rgbaComponentsToCheck =\n    isBuiltinGather(call.builtin) || !isDepthOrStencilTextureFormat(format) ?\n    kRGBAComponents :\n    kRComponent;\n\n    let bad = false;\n    const diffs = rgbaComponentsToCheck.map((component) => {\n      const g = gotRGBA[component];\n      const e = expectRGBA[component];\n      const absDiff = Math.abs(g - e);\n      const ulpDiff = Math.abs(gULP[component] - eULP[component]);\n      assert(!Number.isNaN(ulpDiff));\n      const maxAbs = Math.max(Math.abs(g), Math.abs(e));\n      const relDiff = maxAbs > 0 ? absDiff / maxAbs : 0;\n      if (ulpDiff > 3 && absDiff > callSpecificMaxFractionalDiff) {\n        bad = true;\n      }\n      return { absDiff, relDiff, ulpDiff };\n    });\n\n    const isFloatType = (format) => {\n      const info = kTextureFormatInfo[format];\n      return info.color?.type === 'float' || info.depth?.type === 'depth';\n    };\n    const fix5 = (n) => isFloatType(format) ? n.toFixed(5) : n.toString();\n    const fix5v = (arr) => arr.map((v) => fix5(v)).join(', ');\n    const rgbaToArray = (p) =>\n    rgbaComponentsToCheck.map((component) => p[component]);\n\n    if (bad) {\n      const desc = describeTextureCall(call);\n      errs.push(`result was not as expected:\n      size: [${size.width}, ${size.height}, ${size.depthOrArrayLayers}]\n  mipCount: ${texture.descriptor.mipLevelCount ?? 1}\n      call: ${desc}  // #${callIdx}`);\n      if (isCubeViewDimension(texture.viewDescriptor)) {\n        const coord = convertCubeCoordToNormalized3DTextureCoord(call.coords);\n        const faceNdx = Math.floor(coord[2] * 6);\n        errs.push(`          : as 3D texture coord: (${coord[0]}, ${coord[1]}, ${coord[2]})`);\n        for (let mipLevel = 0; mipLevel < (texture.descriptor.mipLevelCount ?? 1); ++mipLevel) {\n          const mipSize = virtualMipSize(\n            texture.descriptor.dimension ?? '2d',\n            texture.descriptor.size,\n            mipLevel\n          );\n          const t = coord.slice(0, 2).map((v, i) => (v * mipSize[i]).toFixed(3));\n          errs.push(\n            `          : as texel coord mip level[${mipLevel}]: (${t[0]}, ${t[1]}), face: ${faceNdx}(${kFaceNames[faceNdx]})`\n          );\n        }\n      } else {\n        for (let mipLevel = 0; mipLevel < (texture.descriptor.mipLevelCount ?? 1); ++mipLevel) {\n          const mipSize = virtualMipSize(\n            texture.descriptor.dimension ?? '2d',\n            texture.descriptor.size,\n            mipLevel\n          );\n          const t = call.coords.map((v, i) => (v * mipSize[i]).toFixed(3));\n          errs.push(`          : as texel coord @ mip level[${mipLevel}]: (${t.join(', ')})`);\n        }\n      }\n      if (builtinNeedsDerivatives(call.builtin)) {\n        const ddx = derivativeForCall(texture, call, true);\n        const ddy = derivativeForCall(texture, call, false);\n        const mipLevel = computeMipLevelFromGradients(ddx, ddy, size);\n        const biasStr = call.bias === undefined ? '' : ' (without bias)';\n        errs.push(`implicit derivative based mip level: ${fix5(mipLevel)}${biasStr}`);\n        if (call.bias) {\n          const clampedBias = clamp(call.bias ?? 0, { min: -16.0, max: 15.99 });\n          errs.push(`\\\n                       clamped bias: ${fix5(clampedBias)}\n                mip level with bias: ${fix5(mipLevel + clampedBias)}`);\n        }\n      } else if (call.ddx) {\n        const mipLevel = computeMipLevelFromGradientsForCall(call, size);\n        errs.push(`gradient based mip level: ${mipLevel}`);\n      }\n      errs.push(`\\\n       got: ${fix5v(rgbaToArray(gotRGBA))}\n  expected: ${fix5v(rgbaToArray(expectRGBA))}\n  max diff: ${callSpecificMaxFractionalDiff}\n abs diffs: ${fix5v(diffs.map(({ absDiff }) => absDiff))}\n rel diffs: ${diffs.map(({ relDiff }) => `${(relDiff * 100).toFixed(2)}%`).join(', ')}\n ulp diffs: ${diffs.map(({ ulpDiff }) => ulpDiff).join(', ')}\n`);\n\n      if (sampler) {\n        if (t.rec.debugging) {\n          // For compares, we can't use the builtin (textureXXXCompareXXX) because it only\n          // returns 0 or 1 or the average of 0 and 1 for multiple samples. And, for example,\n          // if the comparison is `always` then every sample returns 1. So we need to use the\n          // corresponding sample function to get the actual values from the textures\n          //\n          // textureSampleCompare -> textureSample\n          // textureSampleCompareLevel -> textureSampleLevel\n          // textureGatherCompare -> textureGather\n          if (isBuiltinComparison(call.builtin)) {\n            if (!haveComparisonCheckInfo) {\n              // Convert the comparison calls to their corresponding non-comparison call\n              const debugCalls = calls.map((call) => {\n                const debugCall = { ...call };\n                debugCall.depthRef = undefined;\n                switch (call.builtin) {\n                  case 'textureGatherCompare':\n                    debugCall.builtin = 'textureGather';\n                    break;\n                  case 'textureSampleCompare':\n                    debugCall.builtin = 'textureSample';\n                    break;\n                  case 'textureSampleCompareLevel':\n                    debugCall.builtin = 'textureSampleLevel';\n                    debugCall.levelType = 'f';\n                    debugCall.mipLevel = 0;\n                    break;\n                  default:\n                    unreachable();\n                }\n                return debugCall;\n              });\n\n              // Convert the comparison sampler to a non-comparison sampler\n              const debugSampler = { ...sampler };\n              delete debugSampler.compare;\n\n              // Make a runner for these changed calls.\n              const debugRunner = createTextureCallsRunner(\n                t,\n                {\n                  format,\n                  dimension: texture.descriptor.dimension ?? '2d',\n                  sampleCount: texture.descriptor.sampleCount ?? 1,\n                  depthOrArrayLayers: size.depthOrArrayLayers\n                },\n                texture.viewDescriptor,\n                textureType,\n                debugSampler,\n                debugCalls,\n                stage\n              );\n              checkInfo = {\n                runner: debugRunner,\n                sampler: debugSampler,\n                calls: debugCalls\n              };\n              haveComparisonCheckInfo = true;\n            }\n          }\n\n          if (!gpuTexels && gpuTexture) {\n            // Read the texture back if we haven't yet. We'll use this\n            // to get values for each sample point.\n            gpuTexels = await readTextureToTexelViews(\n              t,\n              gpuTexture,\n              texture.descriptor,\n              getTexelViewFormatForTextureFormat(gpuTexture.format)\n            );\n          }\n\n          const callForSamplePoints = checkInfo.calls[callIdx];\n\n          // We're going to create textures with black and white texels\n          // but if it's a compressed texture we use an encodable texture.\n          // It's not perfect but we already know it failed. We're just hoping\n          // to get sample points.\n          const useTexelFormatForGPUTexture = isCompressedTextureFormat(texture.descriptor.format);\n\n          if (useTexelFormatForGPUTexture) {\n            errs.push(`\n### WARNING: sample points are derived from un-compressed textures and may not match the\nactual GPU results of sampling a compressed texture. The test itself failed at this point\n(see expected: and got: above). We're only trying to determine what the GPU sampled, but\nwe can not do that easily with compressed textures. ###\n`);\n          }\n\n          const expectedSamplePoints = [\n          'expected:',\n          ...(await identifySamplePoints(\n            texture,\n            sampler,\n            callForSamplePoints,\n            call,\n            texture.texels,\n            (texels) => {\n              return Promise.resolve(\n                softwareTextureRead(\n                  t,\n                  stage,\n                  callForSamplePoints,\n                  {\n                    texels,\n                    descriptor: texture.descriptor,\n                    viewDescriptor: texture.viewDescriptor\n                  },\n                  checkInfo.sampler\n                )\n              );\n            }\n          ))];\n\n          const gotSamplePoints = [\n          'got:',\n          ...(await identifySamplePoints(\n            texture,\n            sampler,\n            callForSamplePoints,\n            call,\n            gpuTexels,\n            async (texels) => {\n              const descriptor = { ...texture.descriptor };\n              if (useTexelFormatForGPUTexture) {\n                descriptor.format = texels[0].format;\n              }\n              const gpuTexture = createTextureFromTexelViewsLocal(t, texels, descriptor);\n              const result = (await checkInfo.runner.run(gpuTexture))[callIdx];\n              globalThis._TRAMPOLINE_(\"destroy\", gpuTexture, gpuTexture.destroy, [], () => gpuTexture.destroy());\n              return result;\n            }\n          ))];\n\n          errs.push('  sample points:');\n          errs.push(layoutTwoColumns(expectedSamplePoints, gotSamplePoints).join('\\n'));\n          errs.push('', '');\n        }\n\n        // this is not an else because it's common to comment out the previous `if` for running on a CQ.\n        if (!t.rec.debugging) {\n          errs.push('### turn on debugging to see sample points ###');\n        }\n      } // if (sampler)\n\n      // Don't report the other errors. There 50 sample points per subcase and\n      // 50-100 subcases so the log would get enormous if all 50 fail. One\n      // report per subcase is enough.\n      break;\n    } // if (bad)\n  } // for cellNdx\n\n  globalThis._TRAMPOLINE_(\"destroy\", results.runner, results.runner.destroy, [], () => results.runner.destroy());\n  globalThis._TRAMPOLINE_(\"destroy\", checkInfo.runner, checkInfo.runner.destroy, [], () => checkInfo.runner.destroy());\n\n  return errs.length > 0 ? new Error(errs.join('\\n')) : undefined;\n}\n\nfunction getMaxFractionalDiffForTextureFormat(format) {\n  // Note: I'm not sure what we should do here. My assumption is, given texels\n  // have random values, the difference between 2 texels can be very large. In\n  // the current version, for a float texture they can be +/- 1000 difference.\n  // Sampling is very GPU dependent. So if one pixel gets a random value of\n  // -1000 and the neighboring pixel gets +1000 then any slight variation in how\n  // sampling is applied will generate a large difference when interpolating\n  // between -1000 and +1000.\n  //\n  // We could make some entry for every format but for now I just put the\n  // tolerances here based on format texture suffix.\n  //\n  // It's possible the math in the software rasterizer is just bad but the\n  // results certainly seem close.\n  //\n  // These tolerances started from the OpenGL ES dEQP tests.\n  // Those tests always render to an rgba8unorm texture. The shaders do effectively\n  //\n  //   result = textureSample(...) * scale + bias\n  //\n  // to get the results in a 0.0 to 1.0 range. After reading the values back they\n  // expand them to their original ranges with\n  //\n  //   value = (result - bias) / scale;\n  //\n  // Tolerances from dEQP\n  // --------------------\n  // 8unorm: 3.9 / 255\n  // 8snorm: 7.9 / 128\n  // 2unorm: 7.9 / 512\n  // ufloat: 156.249\n  //  float: 31.2498\n  //\n  // The numbers below have been set empirically to get the tests to pass on all\n  // devices. The devices with the most divergence from the calculated expected\n  // values are MacOS Intel and AMD.\n  //\n  // MAINTENANCE_TODO: Double check the software rendering math and lower these\n  // tolerances if possible.\n\n  if (format.includes('depth')) {\n    return 3 / 100;\n  } else if (format.includes('8unorm')) {\n    return 7 / 255;\n  } else if (format.includes('2unorm')) {\n    return 13 / 512;\n  } else if (format.includes('unorm')) {\n    return 7 / 255;\n  } else if (format.includes('8snorm')) {\n    return 7.9 / 128;\n  } else if (format.includes('snorm')) {\n    return 7.9 / 128;\n  } else if (format.endsWith('ufloat')) {\n    return 156.249;\n  } else if (format.endsWith('float')) {\n    return 44;\n  } else {\n    // It's likely an integer format. In any case, zero tolerance is passable.\n    return 0;\n  }\n}\n\nconst sumOfCharCodesOfString = (s) =>\nString(s).\nsplit('').\nreduce((sum, c) => sum + c.charCodeAt(0), 0);\n\n/**\n * Makes a function that fills a block portion of a Uint8Array with random valid data\n * for an astc block.\n *\n * The astc format is fairly complicated. For now we do the simplest thing.\n * which is to set the block as a \"void-extent\" block (a solid color).\n * This makes our test have far less precision.\n *\n * MAINTENANCE_TODO: generate other types of astc blocks. One option would\n * be to randomly select from set of pre-made blocks.\n *\n * See Spec:\n * https://registry.khronos.org/OpenGL/extensions/KHR/KHR_texture_compression_astc_hdr.txt\n */\nfunction makeAstcBlockFiller(format) {\n  const info = kTextureFormatInfo[format];\n  const bytesPerBlock = info.color.bytes;\n  return (data, offset, hashBase) => {\n    // set the block to be a void-extent block\n    data.set(\n      [\n      0b1111_1100, // 0\n      0b1111_1101, // 1\n      0b1111_1111, // 2\n      0b1111_1111, // 3\n      0b1111_1111, // 4\n      0b1111_1111, // 5\n      0b1111_1111, // 6\n      0b1111_1111 // 7\n      ],\n      offset\n    );\n    // fill the rest of the block with random data\n    const end = offset + bytesPerBlock;\n    for (let i = offset + 8; i < end; ++i) {\n      data[i] = hashU32(hashBase, i);\n    }\n  };\n}\n\n/**\n * Makes a function that fills a block portion of a Uint8Array with random bytes.\n */\nfunction makeRandomBytesBlockFiller(format) {\n  const info = kTextureFormatInfo[format];\n  const bytesPerBlock = info.color.bytes;\n  return (data, offset, hashBase) => {\n    const end = offset + bytesPerBlock;\n    for (let i = offset; i < end; ++i) {\n      data[i] = hashU32(hashBase, i);\n    }\n  };\n}\n\nfunction getBlockFiller(format) {\n  if (format.startsWith('astc')) {\n    return makeAstcBlockFiller(format);\n  } else {\n    return makeRandomBytesBlockFiller(format);\n  }\n}\n\n/**\n * Fills a texture with random data.\n */\nfunction fillTextureWithRandomData(device, texture) {\n  assert(!isCompressedFloatTextureFormat(texture.format));\n  const info = kTextureFormatInfo[texture.format];\n  const hashBase =\n  sumOfCharCodesOfString(texture.format) +\n  sumOfCharCodesOfString(texture.dimension) +\n  texture.width +\n  texture.height +\n  texture.depthOrArrayLayers +\n  texture.mipLevelCount;\n  const bytesPerBlock = info.color.bytes;\n  const fillBlock = getBlockFiller(texture.format);\n  for (let mipLevel = 0; mipLevel < texture.mipLevelCount; ++mipLevel) {\n    const size = physicalMipSizeFromTexture(texture, mipLevel);\n    const blocksAcross = Math.ceil(size[0] / info.blockWidth);\n    const blocksDown = Math.ceil(size[1] / info.blockHeight);\n    const bytesPerRow = blocksAcross * bytesPerBlock;\n    const bytesNeeded = bytesPerRow * blocksDown * size[2];\n    const data = new Uint8Array(bytesNeeded);\n    for (let offset = 0; offset < bytesNeeded; offset += bytesPerBlock) {\n      fillBlock(data, offset, hashBase);\n    }\n    device.queue.writeTexture(\n      { texture, mipLevel },\n      data,\n      { bytesPerRow, rowsPerImage: blocksDown },\n      size\n    );\n  }\n}\n\nconst s_readTextureToRGBA32DeviceToPipeline = new WeakMap(\n\n\n);\n\n// MAINTENANCE_TODO: remove cast once textureBindingViewDimension is added to IDL\nfunction getEffectiveViewDimension(\nt,\ndescriptor)\n{\n  const { textureBindingViewDimension } = descriptor;\n\n\n  const size = reifyExtent3D(descriptor.size);\n  return effectiveViewDimensionForDimension(\n    textureBindingViewDimension,\n    descriptor.dimension,\n    size.depthOrArrayLayers\n  );\n}\n\n/**\n * Reads a texture to an array of TexelViews, one per mip level.\n * format is the format of the TexelView you want. Often this is\n * same as the texture.format but if the texture.format is not\n * \"Encodable\" then you need to choose a different format.\n * Example: depth24plus -> r32float, bc1-rgba-unorm to rgba32float\n */\nexport async function readTextureToTexelViews(\nt,\ntexture,\ndescriptor,\nformat)\n{\n  const device = t.device;\n  const viewDimensionToPipelineMap =\n  s_readTextureToRGBA32DeviceToPipeline.get(device) ??\n  new Map();\n  s_readTextureToRGBA32DeviceToPipeline.set(device, viewDimensionToPipelineMap);\n\n  const { componentType, resultType } = getTextureFormatTypeInfo(texture.format);\n  const viewDimension = getEffectiveViewDimension(t, descriptor);\n  const id = `${texture.format}:${viewDimension}:${texture.sampleCount}`;\n  let pipeline = viewDimensionToPipelineMap.get(id);\n  if (!pipeline) {\n    let textureWGSL;\n    let loadWGSL;\n    let dimensionWGSL = 'textureDimensions(tex, 0)';\n    switch (viewDimension) {\n      case '2d':\n        if (texture.sampleCount > 1) {\n          textureWGSL = `texture_multisampled_2d<${componentType}>`;\n          loadWGSL = 'textureLoad(tex, coord.xy, sampleIndex)';\n          dimensionWGSL = 'textureDimensions(tex)';\n        } else {\n          textureWGSL = `texture_2d<${componentType}>`;\n          loadWGSL = 'textureLoad(tex, coord.xy, 0)';\n        }\n        break;\n      case 'cube-array': // cube-array doesn't exist in compat so we can just use 2d_array for this\n      case '2d-array':\n        textureWGSL = `texture_2d_array<${componentType}>`;\n        loadWGSL = `\n          textureLoad(\n              tex,\n              coord.xy,\n              coord.z,\n              0)`;\n        break;\n      case '3d':\n        textureWGSL = `texture_3d<${componentType}>`;\n        loadWGSL = 'textureLoad(tex, coord.xyz, 0)';\n        break;\n      case 'cube':\n        textureWGSL = `texture_cube<${componentType}>`;\n        loadWGSL = `\n          textureLoadCubeAs2DArray(tex, coord.xy, coord.z);\n        `;\n        break;\n      case '1d':\n        textureWGSL = `texture_1d<${componentType}>`;\n        loadWGSL = `textureLoad(tex, coord.x, 0)`;\n        dimensionWGSL = `vec2u(textureDimensions(tex), 1)`;\n        break;\n      default:\n        unreachable(`unsupported view: ${viewDimension}`);\n    }\n\n    const textureLoadCubeWGSL = `\n      const faceMat = array(\n        mat3x3f( 0,  0,  -2,  0, -2,   0,  1,  1,   1),   // pos-x\n        mat3x3f( 0,  0,   2,  0, -2,   0, -1,  1,  -1),   // neg-x\n        mat3x3f( 2,  0,   0,  0,  0,   2, -1,  1,  -1),   // pos-y\n        mat3x3f( 2,  0,   0,  0,  0,  -2, -1, -1,   1),   // neg-y\n        mat3x3f( 2,  0,   0,  0, -2,   0, -1,  1,   1),   // pos-z\n        mat3x3f(-2,  0,   0,  0, -2,   0,  1,  1,  -1));  // neg-z\n\n      // needed for compat mode.\n      fn textureLoadCubeAs2DArray(tex: texture_cube<${componentType}>, coord: vec2u, layer: u32) -> ${resultType} {\n        // convert texel coord normalized coord\n        let size = textureDimensions(tex, 0);\n        let uv = (vec2f(coord) + 0.5) / vec2f(size.xy);\n\n        // convert uv + layer into cube coord\n        let cubeCoord = faceMat[layer] * vec3f(uv, 1.0);\n\n        // We have to use textureGather as it's the only texture builtin that works on cubemaps\n        // with integer texture formats.\n        let r = textureGather(0, tex, smp, cubeCoord);\n        let g = textureGather(1, tex, smp, cubeCoord);\n        let b = textureGather(2, tex, smp, cubeCoord);\n        let a = textureGather(3, tex, smp, cubeCoord);\n\n        // element 3 is the texel corresponding to cubeCoord\n        return ${resultType}(r[3], g[3], b[3], a[3]);\n      }\n    `;\n\n    const module = device.createShaderModule({\n      code: `\n        ${isViewDimensionCubeOrCubeArray(viewDimension) ? textureLoadCubeWGSL : ''}\n        struct Uniforms {\n          sampleCount: u32,\n        };\n\n        @group(0) @binding(0) var<uniform> uni: Uniforms;\n        @group(0) @binding(1) var tex: ${textureWGSL};\n        @group(0) @binding(2) var smp: sampler;\n        @group(0) @binding(3) var<storage, read_write> data: array<${resultType}>;\n\n        @compute @workgroup_size(1) fn cs(\n          @builtin(global_invocation_id) global_invocation_id : vec3<u32>) {\n          _ = smp;\n          let size = ${dimensionWGSL};\n          let ndx = global_invocation_id.z * size.x * size.y * uni.sampleCount +\n                    global_invocation_id.y * size.x * uni.sampleCount +\n                    global_invocation_id.x;\n          let coord = vec3u(global_invocation_id.x / uni.sampleCount, global_invocation_id.yz);\n          let sampleIndex = global_invocation_id.x % uni.sampleCount;\n          data[ndx] = ${loadWGSL};\n        }\n      `\n    });\n    const info = kTextureFormatInfo[texture.format];\n    const sampleType = info.depth ?\n    'unfilterable-float' // depth only supports unfilterable-float if not a comparison.\n    : info.stencil ?\n    'uint' :\n    info.color.type === 'float' ?\n    'unfilterable-float' :\n    info.color.type;\n    const bindGroupLayout = device.createBindGroupLayout({\n      entries: [\n      {\n        binding: 0,\n        visibility: GPUShaderStage.COMPUTE,\n        buffer: {\n          type: 'uniform'\n        }\n      },\n      {\n        binding: 1,\n        visibility: GPUShaderStage.COMPUTE,\n        texture: {\n          sampleType,\n          viewDimension,\n          multisampled: texture.sampleCount > 1\n        }\n      },\n      {\n        binding: 2,\n        visibility: GPUShaderStage.COMPUTE,\n        sampler: {\n          type: 'non-filtering'\n        }\n      },\n      {\n        binding: 3,\n        visibility: GPUShaderStage.COMPUTE,\n        buffer: {\n          type: 'storage'\n        }\n      }]\n\n    });\n    const layout = device.createPipelineLayout({\n      bindGroupLayouts: [bindGroupLayout]\n    });\n    pipeline = device.createComputePipeline({ layout, compute: { module } });\n    viewDimensionToPipelineMap.set(id, pipeline);\n  }\n\n  const encoder = globalThis._TRAMPOLINE_(\"createCommandEncoder\", device, device.createCommandEncoder, [], () => device.createCommandEncoder());\n\n  const readBuffers = [];\n  for (let mipLevel = 0; mipLevel < texture.mipLevelCount; ++mipLevel) {\n    const size = virtualMipSize(texture.dimension, texture, mipLevel);\n\n    const uniformValues = new Uint32Array([texture.sampleCount, 0, 0, 0]); // min size is 16 bytes\n    const uniformBuffer = t.createBufferTracked({\n      size: uniformValues.byteLength,\n      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST\n    });\n    device.queue.writeBuffer(uniformBuffer, 0, uniformValues);\n\n    const storageBuffer = t.createBufferTracked({\n      size: size[0] * size[1] * size[2] * 4 * 4 * texture.sampleCount, // rgba32float\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC\n    });\n\n    const readBuffer = t.createBufferTracked({\n      size: storageBuffer.size,\n      usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST\n    });\n    readBuffers.push({ size, readBuffer });\n\n    const sampler = device.createSampler();\n\n    const aspect = getAspectForTexture(texture);\n    const bindGroup = device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [\n      { binding: 0, resource: { buffer: uniformBuffer } },\n      {\n        binding: 1,\n        resource: texture.createView({\n          dimension: viewDimension,\n          aspect,\n          baseMipLevel: mipLevel,\n          mipLevelCount: 1\n        })\n      },\n      { binding: 2, resource: sampler },\n      { binding: 3, resource: { buffer: storageBuffer } }]\n\n    });\n\n    const pass = encoder.beginComputePass();\n    pass.setPipeline(pipeline);\n    pass.setBindGroup(0, bindGroup);\n    pass.dispatchWorkgroups(size[0] * texture.sampleCount, size[1], size[2]);\n    pass.end();\n    encoder.copyBufferToBuffer(storageBuffer, 0, readBuffer, 0, readBuffer.size);\n  }\n\n  globalThis._TRAMPOLINE_(\"submit\", device, device.queue.submit, [[encoder.finish()]], () => device.queue.submit([encoder.finish()]));\n\n  const texelViews = [];\n\n  for (const { readBuffer, size } of readBuffers) {\n    await globalThis._TRAMPOLINE_(\"mapAsync\", readBuffer, readBuffer.mapAsync, [GPUMapMode.READ], () => readBuffer.mapAsync(GPUMapMode.READ));\n\n    // need a copy of the data since unmapping will nullify the typedarray view.\n    const Ctor =\n    componentType === 'i32' ? Int32Array : componentType === 'u32' ? Uint32Array : Float32Array;\n    const data = new Ctor(readBuffer.getMappedRange()).slice();\n    readBuffer.unmap();\n\n    const { sampleCount } = texture;\n    texelViews.push(\n      TexelView.fromTexelsAsColors(format, (coord) => {\n        const offset =\n        ((coord.z * size[0] * size[1] + coord.y * size[0] + coord.x) * sampleCount + (\n        coord.sampleIndex ?? 0)) *\n        4;\n        return {\n          R: data[offset + 0],\n          G: data[offset + 1],\n          B: data[offset + 2],\n          A: data[offset + 3]\n        };\n      })\n    );\n  }\n\n  return texelViews;\n}\n\nfunction createTextureFromTexelViewsLocal(\nt,\ntexelViews,\ndesc)\n{\n  const modifiedDescriptor = { ...desc };\n  // If it's a depth or stencil texture we need to render to it to fill it with data.\n  if (isDepthOrStencilTextureFormat(desc.format) || desc.sampleCount > 1) {\n    modifiedDescriptor.usage = desc.usage | GPUTextureUsage.RENDER_ATTACHMENT;\n  }\n  return createTextureFromTexelViews(t, texelViews, modifiedDescriptor);\n}\n\n/**\n * Fills a texture with random data and returns that data as\n * an array of TexelView.\n *\n * For compressed textures the texture is filled with random bytes\n * and then read back from the GPU by sampling so the GPU decompressed\n * the texture.\n *\n * For uncompressed textures the TexelViews are generated and then\n * copied to the texture.\n */\nexport async function createTextureWithRandomDataAndGetTexels(\nt,\ndescriptor,\noptions)\n{\n  if (isCompressedTextureFormat(descriptor.format)) {\n    assert(!options, 'options not supported for compressed textures');\n    const texture = t.createTextureTracked(descriptor);\n\n    fillTextureWithRandomData(t.device, texture);\n    const texels = await readTextureToTexelViews(\n      t,\n      texture,\n      descriptor,\n      getTexelViewFormatForTextureFormat(texture.format)\n    );\n    return { texture, texels };\n  } else if (isUnencodableDepthFormat(descriptor.format)) {\n    // This is round about. We can't directly write to depth24plus, depth24plus-stencil8, depth32float-stencil8\n    // and they are not encodable. So: (1) we make random data using `depth32float`. We create a texture with\n    // that data (createTextureFromTexelViewsLocal will render the data into the texture rather than copy).\n    // We then need to read it back out but as rgba32float since that is encodable but, since it round tripped\n    // through the GPU it's now been quantized.\n    const d32Descriptor = {\n      ...descriptor,\n      format: 'depth32float'\n    };\n    const tempTexels = createRandomTexelViewMipmap(d32Descriptor, options);\n    const texture = createTextureFromTexelViewsLocal(t, tempTexels, descriptor);\n    const texels = await readTextureToTexelViews(\n      t,\n      texture,\n      descriptor,\n      getTexelViewFormatForTextureFormat(texture.format)\n    );\n    return { texture, texels };\n  } else {\n    const texels = createRandomTexelViewMipmap(descriptor, options);\n    const texture = createTextureFromTexelViewsLocal(t, texels, descriptor);\n    return { texture, texels };\n  }\n}\n\nfunction valueIfAllComponentsAreEqual(\nc,\ncomponentOrder)\n{\n  const s = new Set(componentOrder.map((component) => c[component]));\n  return s.size === 1 ? s.values().next().value : undefined;\n}\n\n/**\n * Creates a VideoFrame with random data and a TexelView with the same data.\n */\nexport function createVideoFrameWithRandomDataAndGetTexels(textureSize) {\n  const size = reifyExtent3D(textureSize);\n  assert(size.depthOrArrayLayers === 1);\n\n  // Fill ImageData with random values.\n  const imageData = new ImageData(size.width, size.height);\n  const data = imageData.data;\n  const asU32 = new Uint32Array(data.buffer);\n  for (let i = 0; i < asU32.length; ++i) {\n    asU32[i] = hashU32(i);\n  }\n\n  // Put the ImageData into a canvas and make a VideoFrame\n  const canvas = new OffscreenCanvas(size.width, size.height);\n  const ctx = canvas.getContext('2d');\n  ctx.putImageData(imageData, 0, 0);\n  const videoFrame = new VideoFrame(canvas, { timestamp: 0 });\n\n  // Premultiply the ImageData\n  for (let i = 0; i < data.length; i += 4) {\n    const alpha = data[i + 3] / 255;\n    data[i + 0] = data[i + 0] * alpha;\n    data[i + 1] = data[i + 1] * alpha;\n    data[i + 2] = data[i + 2] * alpha;\n  }\n\n  // Create a TexelView from the premultiplied ImageData\n  const texels = [\n  TexelView.fromTextureDataByReference('rgba8unorm', data, {\n    bytesPerRow: size.width * 4,\n    rowsPerImage: size.height,\n    subrectOrigin: [0, 0, 0],\n    subrectSize: size\n  })];\n\n\n  return { videoFrame, texels };\n}\n\nconst kFaceNames = ['+x', '-x', '+y', '-y', '+z', '-z'];\n\n/**\n * Generates a text art grid showing which texels were sampled\n * followed by a list of the samples and the weights used for each\n * component.\n *\n * It works by making a set of indices for every texel in the texture.\n * It splits the set into 2. It picks one set and generates texture data\n * using TexelView.fromTexelsAsColor with [1, 1, 1, 1] texels for members\n * of the current set.\n *\n * In then calls 'run' which renders a single `call`. `run` uses either\n * the software renderer or WebGPU. It then checks the results. If the\n * result is zero, all texels in the current had no influence when sampling\n * and can be discarded.\n *\n * If the result is > 0 then, if the set has more than one member, the\n * set is split and added to the list to sets to test. If the set only\n * had one member then the result is the weight used when sampling that texel.\n *\n * This lets you see if the weights from the software renderer match the\n * weights from WebGPU.\n *\n * Example:\n *\n *     0   1   2   3   4   5   6   7\n *   +---+---+---+---+---+---+---+---+\n * 0 |   |   |   |   |   |   |   |   |\n *   +---+---+---+---+---+---+---+---+\n * 1 |   |   |   |   |   |   |   | a |\n *   +---+---+---+---+---+---+---+---+\n * 2 |   |   |   |   |   |   |   | b |\n *   +---+---+---+---+---+---+---+---+\n * 3 |   |   |   |   |   |   |   |   |\n *   +---+---+---+---+---+---+---+---+\n * 4 |   |   |   |   |   |   |   |   |\n *   +---+---+---+---+---+---+---+---+\n * 5 |   |   |   |   |   |   |   |   |\n *   +---+---+---+---+---+---+---+---+\n * 6 |   |   |   |   |   |   |   |   |\n *   +---+---+---+---+---+---+---+---+\n * 7 |   |   |   |   |   |   |   |   |\n *   +---+---+---+---+---+---+---+---+\n * a: at: [7, 1], weights: [R: 0.75000]\n * b: at: [7, 2], weights: [R: 0.25000]\n */\nasync function identifySamplePoints(\ntexture,\nsampler,\ncallForSamples,\noriginalCall,\ntexels,\nrun)\n{\n  const info = texture.descriptor;\n  const isCube = isCubeViewDimension(texture.viewDescriptor);\n  const mipLevelCount = texture.descriptor.mipLevelCount ?? 1;\n  const mipLevelSize = range(mipLevelCount, (mipLevel) =>\n  virtualMipSize(texture.descriptor.dimension ?? '2d', texture.descriptor.size, mipLevel)\n  );\n  const numTexelsPerLevel = mipLevelSize.map((size) => size.reduce((s, v) => s * v));\n  const numTexelsOfPrecedingLevels = (() => {\n    let total = 0;\n    return numTexelsPerLevel.map((v) => {\n      const num = total;\n      total += v;\n      return num;\n    });\n  })();\n  const numTexels = numTexelsPerLevel.reduce((sum, v) => sum + v);\n\n  const getMipLevelFromTexelId = (texelId) => {\n    for (let mipLevel = mipLevelCount - 1; mipLevel > 0; --mipLevel) {\n      if (texelId - numTexelsOfPrecedingLevels[mipLevel] >= 0) {\n        return mipLevel;\n      }\n    }\n    return 0;\n  };\n\n  const getTexelCoordFromTexelId = (texelId) => {\n    const mipLevel = getMipLevelFromTexelId(texelId);\n    const size = mipLevelSize[mipLevel];\n    const texelsPerSlice = size[0] * size[1];\n    const id = texelId - numTexelsOfPrecedingLevels[mipLevel];\n    const layer = Math.floor(id / texelsPerSlice);\n    const xyId = id - layer * texelsPerSlice;\n    const y = xyId / size[0] | 0;\n    const x = xyId % size[0];\n    return { x, y, z: layer, mipLevel, xyId };\n  };\n\n  // This isn't perfect. We already know there was an error. We're just\n  // generating info so it seems okay it's not perfect. This format will\n  // be used to generate weights by drawing with a texture of this format\n  // with a specific pixel set to [1, 1, 1, 1]. As such, if the result\n  // is > 0 then that pixel was sampled and the results are the weights.\n  //\n  // Ideally, this texture with a single pixel set to [1, 1, 1, 1] would\n  // be the same format we were originally testing, the one we already\n  // detected an error for. This way, whatever subtle issues there are\n  // from that format will affect the weight values we're computing. But,\n  // if that format is not encodable, for example if it's a compressed\n  // texture format, then we have no way to build a texture so we use\n  // rgba8unorm instead.\n  const format =\n  kEncodableTextureFormats.includes(info.format) ?\n  info.format :\n  isDepthTextureFormat(info.format) ?\n  'depth16unorm' :\n  'rgba8unorm';\n\n  const rep = kTexelRepresentationInfo[format];\n\n  const components = isBuiltinGather(callForSamples.builtin) ? kRGBAComponents : rep.componentOrder;\n  const convertResultAsAppropriate = isBuiltinGather(callForSamples.builtin) ?\n  (v) => v :\n  convertResultFormatToTexelViewFormat;\n\n  // Identify all the texels that are sampled, and their weights.\n  const sampledTexelWeights = new Map();\n  const unclassifiedStack = [new Set(range(numTexels, (v) => v))];\n  while (unclassifiedStack.length > 0) {\n    // Pop the an unclassified texels stack\n    const unclassified = unclassifiedStack.pop();\n\n    // Split unclassified texels evenly into two new sets\n    const setA = new Set();\n    const setB = new Set();\n    [...unclassified.keys()].forEach((t, i) => ((i & 1) === 0 ? setA : setB).add(t));\n\n    // Push setB to the unclassified texels stack\n    if (setB.size > 0) {\n      unclassifiedStack.push(setB);\n    }\n\n    // See if any of the texels in setA were sampled.0\n    const results = convertResultAsAppropriate(\n      await run(\n        range(mipLevelCount, (mipLevel) =>\n        TexelView.fromTexelsAsColors(\n          format,\n          (coords) => {\n            const size = mipLevelSize[mipLevel];\n            const texelsPerSlice = size[0] * size[1];\n            const texelsPerRow = size[0];\n            const texelId =\n            numTexelsOfPrecedingLevels[mipLevel] +\n            coords.x +\n            coords.y * texelsPerRow +\n            coords.z * texelsPerSlice;\n            const isCandidate = setA.has(texelId);\n            const texel = {};\n            for (const component of rep.componentOrder) {\n              texel[component] = isCandidate ? 1 : 0;\n            }\n            return texel;\n          }\n        )\n        )\n      ),\n      format\n    );\n    if (components.some((c) => results[c] !== 0)) {\n      // One or more texels of setA were sampled.\n      if (setA.size === 1) {\n        // We identified a specific texel was sampled.\n        // As there was only one texel in the set, results holds the sampling weights.\n        setA.forEach((texel) => sampledTexelWeights.set(texel, results));\n      } else {\n        // More than one texel in the set. Needs splitting.\n        unclassifiedStack.push(setA);\n      }\n    }\n  }\n\n  // separate the sampledTexelWeights by mipLevel, then by layer, within a layer the texelId only includes x and y\n  const levels = [];\n  for (const [texelId, weight] of sampledTexelWeights.entries()) {\n    const { xyId, z, mipLevel } = getTexelCoordFromTexelId(texelId);\n    const level = levels[mipLevel] ?? [];\n    levels[mipLevel] = level;\n    const layerEntries = level[z] ?? new Map();\n    level[z] = layerEntries;\n    layerEntries.set(xyId, weight);\n  }\n\n  // example when blockWidth = 2, blockHeight = 2\n  //\n  //     0   1   2   3\n  //   +===+===+===+===+\n  // 0 # a |   #   |   #\n  //   +---+---+---+---+\n  // 1 #   |   #   |   #\n  //   +===+===+===+===+\n  // 2 #   |   #   |   #\n  //   +---+---+---+---+\n  // 3 #   |   #   | b #\n  //   +===+===+===+===+\n\n  const lines = [];\n  const letter = (idx) => String.fromCodePoint(idx < 30 ? 97 + idx : idx + 9600 - 30); // 97: 'a'\n  let idCount = 0;\n\n  const { blockWidth, blockHeight } = kTextureFormatInfo[texture.descriptor.format];\n  const [blockHChar, blockVChar] = Math.max(blockWidth, blockHeight) > 1 ? ['=', '#'] : ['-', '|'];\n  const blockHCell = '+'.padStart(4, blockHChar); // generates ---+ or ===+\n  // range + concatenate results.\n  const rangeCat = (num, fn) => range(num, fn).join('');\n\n  for (let mipLevel = 0; mipLevel < mipLevelCount; ++mipLevel) {\n    const level = levels[mipLevel];\n    if (!level) {\n      continue;\n    }\n\n    const [width, height, depthOrArrayLayers] = mipLevelSize[mipLevel];\n    const texelsPerRow = width;\n\n    for (let layer = 0; layer < depthOrArrayLayers; ++layer) {\n      const layerEntries = level[layer];\n\n      const orderedTexelIndices = [];\n      lines.push('');\n      const unSampled = layerEntries ? '' : 'un-sampled';\n      if (isCube) {\n        const face = kFaceNames[layer % 6];\n        lines.push(\n          `layer: ${layer} mip(${mipLevel}), cube-layer: ${layer / 6 | 0} (${face}) ${unSampled}`\n        );\n      } else {\n        lines.push(`layer: ${layer} mip(${mipLevel}) ${unSampled}`);\n      }\n\n      if (!layerEntries) {\n        continue;\n      }\n\n      lines.push(`   ${rangeCat(width, (x) => `  ${x.toString().padEnd(2)}`)}`);\n      lines.push(`   +${rangeCat(width, () => blockHCell)}`);\n      for (let y = 0; y < height; y++) {\n        {\n          let line = `${y.toString().padStart(2)} ${blockVChar}`;\n          for (let x = 0; x < width; x++) {\n            const colChar = (x + 1) % blockWidth === 0 ? blockVChar : '|';\n            const texelIdx = x + y * texelsPerRow;\n            const weight = layerEntries.get(texelIdx);\n            if (weight !== undefined) {\n              line += ` ${letter(idCount + orderedTexelIndices.length)} ${colChar}`;\n              orderedTexelIndices.push(texelIdx);\n            } else {\n              line += `   ${colChar}`;\n            }\n          }\n          lines.push(line);\n        }\n        if (y < height - 1) {\n          lines.push(\n            `   +${rangeCat(width, () => (y + 1) % blockHeight === 0 ? blockHCell : '---+')}`\n          );\n        }\n      }\n      lines.push(`   +${range(width, () => blockHCell).join('')}`);\n\n      const pad2 = (n) => n.toString().padStart(2);\n      const pad3 = (n) => n.toString().padStart(3);\n      const fix5 = (n) => {\n        const s = n.toFixed(5);\n        return s === '0.00000' && n !== 0 ? n.toString() : s;\n      };\n      const formatValue = isSintOrUintFormat(format) ? pad3 : fix5;\n      const formatTexel = (texel) =>\n      texel ?\n      Object.entries(texel).\n      map(([k, v]) => `${k}: ${formatValue(v)}`).\n      join(', ') :\n      '*texel values unavailable*';\n\n      const colorLines = [];\n      const compareLines = [];\n      let levelWeight = 0;\n      orderedTexelIndices.forEach((texelIdx, i) => {\n        const weights = layerEntries.get(texelIdx);\n        const y = Math.floor(texelIdx / texelsPerRow);\n        const x = texelIdx % texelsPerRow;\n        const singleWeight = valueIfAllComponentsAreEqual(weights, components);\n        levelWeight += singleWeight;\n        const w =\n        singleWeight !== undefined ?\n        `weight: ${fix5(singleWeight)}` :\n        `weights: [${components.map((c) => `${c}: ${fix5(weights[c])}`).join(', ')}]`;\n        const coord = `${pad2(x)}, ${pad2(y)}, ${pad2(layer)}`;\n        const texel =\n        texels &&\n        convertToTexelViewFormat(\n          texels[mipLevel].color({ x, y, z: layer }),\n          texture.descriptor.format\n        );\n\n        const texelStr = formatTexel(texel);\n        const id = letter(idCount + i);\n        lines.push(`${id}: mip(${mipLevel}) at: [${coord}], ${w}`);\n        colorLines.push(`${id}: value: ${texelStr}`);\n        if (isBuiltinComparison(originalCall.builtin)) {\n          assert(!!texel);\n          const compareTexel = applyCompare(originalCall, sampler, [TexelComponent.Depth], texel);\n          compareLines.push(\n            `${id}: compare(${sampler.compare}) result with depthRef(${fix5(\n              originalCall.depthRef\n            )}): ${fix5(compareTexel.Depth)}`\n          );\n        }\n      });\n      lines.push(...colorLines);\n      lines.push(...compareLines);\n      if (!isNaN(levelWeight)) {\n        lines.push(`mip level (${mipLevel}) weight: ${fix5(levelWeight)}`);\n      }\n      idCount += orderedTexelIndices.length;\n    }\n  }\n\n  return lines;\n}\n\nfunction layoutTwoColumns(columnA, columnB) {\n  const widthA = Math.max(...columnA.map((l) => l.length));\n  const lines = Math.max(columnA.length, columnB.length);\n  const out = new Array(lines);\n  for (let line = 0; line < lines; line++) {\n    const a = columnA[line] ?? '';\n    const b = columnB[line] ?? '';\n    out[line] = `${a}${' '.repeat(widthA - a.length)} | ${b}`;\n  }\n  return out;\n}\n\n/**\n * Returns the number of layers ot test for a given view dimension\n */\nexport function getDepthOrArrayLayersForViewDimension(viewDimension) {\n  switch (viewDimension) {\n    case '1d':\n      return 1;\n    case undefined:\n    case '2d':\n      return 1;\n    case '2d-array':\n      return 4;\n    case '3d':\n      return 8;\n    case 'cube':\n      return 6;\n    default:\n      unreachable();\n  }\n}\n\n/**\n * Choose a texture size based on the given parameters.\n * The size will be in a multiple of blocks. If it's a cube\n * map the size will so be square.\n */\nexport function chooseTextureSize({\n  minSize,\n  minBlocks,\n  format,\n  viewDimension\n\n\n\n\n\n}) {\n  const { blockWidth, blockHeight } = kTextureFormatInfo[format];\n  const width = align(Math.max(minSize, blockWidth * minBlocks), blockWidth);\n  const height =\n  viewDimension === '1d' ? 1 : align(Math.max(minSize, blockHeight * minBlocks), blockHeight);\n  if (viewDimension === 'cube' || viewDimension === 'cube-array') {\n    const blockLCM = lcm(blockWidth, blockHeight);\n    const largest = Math.max(width, height);\n    const size = align(largest, blockLCM);\n    return [size, size, viewDimension === 'cube-array' ? 24 : 6];\n  }\n  const depthOrArrayLayers = getDepthOrArrayLayersForViewDimension(viewDimension);\n  return [width, height, depthOrArrayLayers];\n}\n\nexport const kSamplePointMethods = ['texel-centre', 'spiral'];\n\n\nexport const kCubeSamplePointMethods = ['cube-edges', 'texel-centre', 'spiral'];\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Generates an array of coordinates at which to sample a texture.\n */\nfunction generateTextureBuiltinInputsImpl(\nmakeValue,\nn,\nargs)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n{\n  const { method, descriptor } = args;\n  const dimension = descriptor.dimension ?? '2d';\n  const mipLevelCount = descriptor.mipLevelCount ?? 1;\n  const size = virtualMipSize(dimension, descriptor.size, 0);\n  const coords = [];\n  switch (method) {\n    case 'texel-centre':{\n        for (let i = 0; i < n; i++) {\n          const r = hashU32(i);\n          const x = Math.floor(lerp(0, size[0] - 1, (r & 0xff) / 0xff)) + 0.5;\n          const y = Math.floor(lerp(0, size[1] - 1, (r >> 8 & 0xff) / 0xff)) + 0.5;\n          const z = Math.floor(lerp(0, size[2] - 1, (r >> 16 & 0xff) / 0xff)) + 0.5;\n          coords.push(makeValue(x / size[0], y / size[1], z / size[2]));\n        }\n        break;\n      }\n    case 'spiral':{\n        const { radius = 1.5, loops = 2 } = args;\n        for (let i = 0; i < n; i++) {\n          const f = i / (Math.max(n, 2) - 1);\n          const r = radius * f;\n          const a = loops * 2 * Math.PI * f;\n          coords.push(makeValue(0.5 + r * Math.cos(a), 0.5 + r * Math.sin(a), 0));\n        }\n        break;\n      }\n  }\n\n  const _hashInputs = args.hashInputs.map((v) =>\n  typeof v === 'string' ? sumOfCharCodesOfString(v) : typeof v === 'boolean' ? v ? 1 : 0 : v\n  );\n\n  // returns a number between [0 and N)\n  const makeRandValue = ({ num, type }, ...hashInputs) => {\n    const range = num;\n    const number = hashU32(..._hashInputs, ...hashInputs) / 0x1_0000_0000 * range;\n    return type === 'f32' ? number : Math.floor(number);\n  };\n\n  // for signed and float values returns [-1 to num]\n  // for unsigned values returns [0 to num]\n  const makeRangeValue = ({ num, type }, ...hashInputs) => {\n    const range = num + (type === 'u32' ? 1 : 2);\n    const number =\n    hashU32(..._hashInputs, ...hashInputs) / 0x1_0000_0000 * range - (type === 'u32' ? 0 : 1);\n    return type === 'f32' ? number : Math.floor(number);\n  };\n\n  // Generates the same values per coord instead of using all the extra `_hashInputs`.\n  const makeIntHashValueRepeatable = (min, max, ...hashInputs) => {\n    const range = max - min;\n    return min + Math.floor(hashU32(...hashInputs) / 0x1_0000_0000 * range);\n  };\n\n  // Samplers across devices use different methods to interpolate.\n  // Quantizing the texture coordinates seems to hit coords that produce\n  // comparable results to our computed results.\n  // Note: This value works with 8x8 textures. Other sizes have not been tested.\n  // Values that worked for reference:\n  // Win 11, NVidia 2070 Super: 16\n  // Linux, AMD Radeon Pro WX 3200: 256\n  // MacOS, M1 Mac: 256\n  const kSubdivisionsPerTexel = 4;\n\n  // When filtering is nearest then we want to avoid edges of texels\n  //\n  //             U\n  //             |\n  //     +---+---+---+---+---+---+---+---+\n  //     |   | A | B |   |   |   |   |   |\n  //     +---+---+---+---+---+---+---+---+\n  //\n  // Above, coordinate U could sample either A or B\n  //\n  //               U\n  //               |\n  //     +---+---+---+---+---+---+---+---+\n  //     |   | A | B | C |   |   |   |   |\n  //     +---+---+---+---+---+---+---+---+\n  //\n  // For textureGather we want to avoid texel centers\n  // as for coordinate U could either gather A,B or B,C.\n\n  const avoidEdgeCase =\n  !args.sampler || args.sampler.minFilter === 'nearest' || isBuiltinGather(args.textureBuiltin);\n  const edgeRemainder = isBuiltinGather(args.textureBuiltin) ? kSubdivisionsPerTexel / 2 : 0;\n\n  // textureGather issues for 2d/3d textures\n  //\n  // If addressModeU is repeat, then on an 8x1 texture, u = 0.01 or u = 0.99\n  // would gather these texels\n  //\n  //     +---+---+---+---+---+---+---+---+\n  //     | * |   |   |   |   |   |   | * |\n  //     +---+---+---+---+---+---+---+---+\n  //\n  // If addressModeU is clamp-to-edge or mirror-repeat,\n  // then on an 8x1 texture, u = 0.01 would gather this texel\n  //\n  //     +---+---+---+---+---+---+---+---+\n  //     | * |   |   |   |   |   |   |   |\n  //     +---+---+---+---+---+---+---+---+\n  //\n  // and 0.99 would gather this texel\n  //\n  //     +---+---+---+---+---+---+---+---+\n  //     |   |   |   |   |   |   |   | * |\n  //     +---+---+---+---+---+---+---+---+\n  //\n  // This means we have to if addressMode is not `repeat`, we\n  // need to avoid the edge of the texture.\n  //\n  // Note: we don't have these specific issues with cube maps\n  // as they ignore addressMode\n  const euclideanModulo = (n, m) => (n % m + m) % m;\n  const addressMode =\n  args.textureBuiltin === 'textureSampleBaseClampToEdge' ?\n  ['clamp-to-edge', 'clamp-to-edge', 'clamp-to-edge'] :\n  [\n  args.sampler?.addressModeU ?? 'clamp-to-edge',\n  args.sampler?.addressModeV ?? 'clamp-to-edge',\n  args.sampler?.addressModeW ?? 'clamp-to-edge'];\n\n  const avoidTextureEdge = (axis, textureDimensionUnits, v) => {\n    assert(isBuiltinGather(args.textureBuiltin));\n    if (addressMode[axis] === 'repeat') {\n      return v;\n    }\n    const inside = euclideanModulo(v, textureDimensionUnits);\n    const outside = v - inside;\n    return outside + clamp(inside, { min: 1, max: textureDimensionUnits - 1 });\n  };\n\n  const numComponents = isDepthOrStencilTextureFormat(descriptor.format) ? 1 : 4;\n  return coords.map((c, i) => {\n    const mipLevel = args.mipLevel ?\n    quantizeMipLevel(makeRangeValue(args.mipLevel, i), args.sampler?.mipmapFilter ?? 'nearest') :\n    0;\n    const clampedMipLevel = clamp(mipLevel, { min: 0, max: mipLevelCount - 1 });\n    const mipSize = virtualMipSize(dimension, size, clampedMipLevel);\n    const q = mipSize.map((v) => v * kSubdivisionsPerTexel);\n\n    const coords = c.map((v, i) => {\n      // Quantize to kSubdivisionsPerPixel\n      const v1 = Math.floor(v * q[i]);\n      // If it's nearest or textureGather and we're on the edge of a texel then move us off the edge\n      // since the edge could choose one texel or another.\n      const isTexelEdgeCase = Math.abs(v1 % kSubdivisionsPerTexel) === edgeRemainder;\n      const v2 = isTexelEdgeCase && avoidEdgeCase ? v1 + 1 : v1;\n      const v3 = isBuiltinGather(args.textureBuiltin) ? avoidTextureEdge(i, q[i], v2) : v2;\n      // Convert back to texture coords\n      return v3 / q[i];\n    });\n\n    const makeGradient = (hashInput) => {\n      return coords.map((_, i) => {\n        // a value between -4 and 4 integer then add +/- 0.25\n        // We want to be able to choose levels but we want to avoid the area where the\n        // gpu might choose 2 different levels than the software renderer.\n        const intPart = makeRangeValue({ num: 8, type: 'u32' }, i, hashInput) - 4;\n        const fractPart = makeRangeValue({ num: 0, type: 'f32' }, i, hashInput + 1) * 0.25;\n        assert(fractPart >= -0.25 && fractPart <= 0.25);\n        return intPart + fractPart;\n      });\n    };\n\n    // choose a derivative value that will select a mipLevel.\n    const makeDerivativeMult = (coords, mipLevel) => {\n      // Make an identity vec (all 1s).\n      const mult = new Array(coords.length).fill(0);\n      // choose one axis to set\n      const ndx = makeRangeValue({ num: coords.length - 1, type: 'u32' }, i, 8);\n      assert(ndx < coords.length);\n      mult[ndx] = Math.pow(2, mipLevel);\n      return mult;\n    };\n\n    // Choose a mip level. If mipmapFilter is 'nearest' then avoid centers of levels\n    // else avoid edges.\n    const chooseMipLevel = () => {\n      const innerLevelR = makeRandValue({ num: 9, type: 'u32' }, i, 11);\n      const innerLevel =\n      args?.sampler?.mipmapFilter === 'linear' ?\n      innerLevelR + 1 :\n      innerLevelR < 5 ?\n      innerLevelR :\n      innerLevelR + 1;\n      const outerLevel = makeRangeValue({ num: mipLevelCount - 1, type: 'i32' }, i, 11);\n      return outerLevel + innerLevel / 10;\n    };\n\n    // for textureSample, choose a derivative value that will select a mipLevel near\n    // the range of mip levels.\n    const makeDerivativeMultForTextureSample = (coords) => {\n      const mipLevel = chooseMipLevel();\n      return makeDerivativeMult(coords, mipLevel);\n    };\n\n    // for textureSampleBias we choose a mipLevel we want to sample, then a bias between -17 and 17.\n    // and then a derivative that, given the chosen bias will arrive at the chosen mipLevel.\n    // The GPU is supposed to clamp between -16.0 and 15.99.\n    const makeBiasAndDerivativeMult = (coords) => {\n      const mipLevel = chooseMipLevel();\n      const bias = makeRangeValue({ num: 34, type: 'f32' }, i, 9) - 17;\n      const clampedBias = clamp(bias, { min: -16, max: 15.99 });\n      const derivativeBasedMipLevel = mipLevel - clampedBias;\n      const derivativeMult = makeDerivativeMult(coords, derivativeBasedMipLevel);\n      return [bias, derivativeMult];\n    };\n\n    // If bias is set this is textureSampleBias. If bias is not set but derivatives\n    // is then this is one of the other functions that needs implicit derivatives.\n    const [bias, derivativeMult] = args.bias ?\n    makeBiasAndDerivativeMult(coords) :\n    args.derivatives ?\n    [undefined, makeDerivativeMultForTextureSample(coords)] :\n    [];\n\n    return {\n      coords,\n      derivativeMult,\n      mipLevel,\n      sampleIndex: args.sampleIndex ? makeRangeValue(args.sampleIndex, i, 1) : undefined,\n      arrayIndex: args.arrayIndex ? makeRangeValue(args.arrayIndex, i, 2) : undefined,\n      // use 0.0, 0.5, or 1.0 for depthRef. We can't test for equality except for values 0 and 1\n      // The texture will be filled with random values unless our comparison is 'equal' or 'not-equal'\n      // in which case the texture will be filled with only 0, 0.6, 1. Choosing 0.0, 0.5, 1.0 here\n      // means we can test 'equal' and 'not-equal'. For other comparisons, the fact that the texture's\n      // contents is random seems enough to test all the comparison modes.\n      depthRef: args.depthRef ? makeRandValue({ num: 3, type: 'u32' }, i, 5) / 2 : undefined,\n      ddx: args.grad ? makeGradient(7) : undefined,\n      ddy: args.grad ? makeGradient(8) : undefined,\n      bias,\n      offset: args.offset ?\n      coords.map((_, j) => makeIntHashValueRepeatable(-8, 8, i, 3 + j)) :\n      undefined,\n      component: args.component ? makeIntHashValueRepeatable(0, numComponents, i, 4) : undefined\n    };\n  });\n}\n\n/**\n * When mipmapFilter === 'nearest' we need to stay away from 0.5\n * because the GPU could decide to choose one mip or the other.\n *\n * Some example transition values, the value at which the GPU chooses\n * mip level 1 over mip level 0:\n *\n * M1 Mac: 0.515381\n * Intel Mac: 0.49999\n * AMD Mac: 0.5\n */\nconst kMipEpsilon = 0.02;\nfunction quantizeMipLevel(mipLevel, mipmapFilter) {\n  if (mipmapFilter === 'linear') {\n    return mipLevel;\n  }\n  const intMip = Math.floor(mipLevel);\n  const fractionalMip = mipLevel - intMip;\n  if (fractionalMip < 0.5 - kMipEpsilon || fractionalMip > 0.5 + kMipEpsilon) {\n    return mipLevel;\n  } else {\n    return intMip + 0.5 + (fractionalMip < 0.5 ? -kMipEpsilon : +kMipEpsilon);\n  }\n}\n\n// Removes the first element from an array of types\n\n\n\n\n\n\nexport function generateTextureBuiltinInputs1D(...args) {\n  return generateTextureBuiltinInputsImpl((x) => [x], ...args);\n}\n\nexport function generateTextureBuiltinInputs2D(...args) {\n  return generateTextureBuiltinInputsImpl((x, y) => [x, y], ...args);\n}\n\nexport function generateTextureBuiltinInputs3D(...args) {\n  return generateTextureBuiltinInputsImpl(\n    (x, y, z) => [x, y, z],\n    ...args\n  );\n}\n\n\n\n\n\n\n\n\nconst kFaceUVMatrices =\n[\n[0, 0, -2, 0, -2, 0, 1, 1, 1], // pos-x\n[0, 0, 2, 0, -2, 0, -1, 1, -1], // neg-x\n[2, 0, 0, 0, 0, 2, -1, 1, -1], // pos-y\n[2, 0, 0, 0, 0, -2, -1, -1, 1], // neg-y\n[2, 0, 0, 0, -2, 0, -1, 1, 1], // pos-z\n[-2, 0, 0, 0, -2, 0, 1, 1, -1] // neg-z\n];\n\n/** multiply a vec3 by mat3 */\nfunction transformMat3(v, m) {\n  const x = v[0];\n  const y = v[1];\n  const z = v[2];\n\n  return [\n  x * m[0] + y * m[3] + z * m[6],\n  x * m[1] + y * m[4] + z * m[7],\n  x * m[2] + y * m[5] + z * m[8]];\n\n}\n\n/** normalize a vec3 */\nfunction normalize(v) {\n  const length = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);\n  assert(length > 0);\n  return v.map((v) => v / length);\n}\n\n/**\n * Converts a cube map coordinate to a uv coordinate (0 to 1) and layer (0.5/6.0 to 5.5/6.0).\n */\nfunction convertCubeCoordToNormalized3DTextureCoord(v) {\n  let uvw;\n  let layer;\n  // normalize the coord.\n  // MAINTENANCE_TODO: handle(0, 0, 0)\n  const r = normalize(v);\n  const absR = r.map((v) => Math.abs(v));\n  if (absR[0] > absR[1] && absR[0] > absR[2]) {\n    // x major\n    const negX = r[0] < 0.0 ? 1 : 0;\n    uvw = [negX ? r[2] : -r[2], -r[1], absR[0]];\n    layer = negX;\n  } else if (absR[1] > absR[2]) {\n    // y major\n    const negY = r[1] < 0.0 ? 1 : 0;\n    uvw = [r[0], negY ? -r[2] : r[2], absR[1]];\n    layer = 2 + negY;\n  } else {\n    // z major\n    const negZ = r[2] < 0.0 ? 1 : 0;\n    uvw = [negZ ? -r[0] : r[0], -r[1], absR[2]];\n    layer = 4 + negZ;\n  }\n  return [(uvw[0] / uvw[2] + 1) * 0.5, (uvw[1] / uvw[2] + 1) * 0.5, (layer + 0.5) / 6];\n}\n\n/**\n * Convert a 3d texcoord into a cube map coordinate.\n */\nfunction convertNormalized3DTexCoordToCubeCoord(uvLayer) {\n  const [u, v, faceLayer] = uvLayer;\n  return normalize(transformMat3([u, v, 1], kFaceUVMatrices[Math.min(5, faceLayer * 6) | 0]));\n}\n\n/**\n * Wrap a texel based face coord across cube faces\n *\n * We have a face texture in texels coord where U/V choose a texel and W chooses the face.\n * If U/V are outside the size of the texture then, when normalized and converted\n * to a cube map coordinate, they'll end up pointing to a different face.\n *\n * addressMode is effectively ignored for cube\n *\n * By converting from a texel based coord to a normalized coord and then to a cube map coord,\n * if the texel was outside of the face, the cube map coord will end up pointing to a different\n * face. We then convert back cube coord -> normalized face coord -> texel based coord\n */\nfunction wrapFaceCoordToCubeFaceAtEdgeBoundaries(textureSize, faceCoord) {\n  // convert texel based face coord to normalized 2d-array coord\n  const nc0 = [\n  (faceCoord[0] + 0.5) / textureSize,\n  (faceCoord[1] + 0.5) / textureSize,\n  (faceCoord[2] + 0.5) / 6];\n\n  const cc = convertNormalized3DTexCoordToCubeCoord(nc0);\n  const nc1 = convertCubeCoordToNormalized3DTextureCoord(cc);\n  // convert normalized 2d-array coord back texel based face coord\n  const fc = [\n  Math.floor(nc1[0] * textureSize),\n  Math.floor(nc1[1] * textureSize),\n  Math.floor(nc1[2] * 6)];\n\n\n  return fc;\n}\n\nfunction applyAddressModesToCoords(\naddressMode,\ntextureSize,\ncoord)\n{\n  return coord.map((v, i) => {\n    switch (addressMode[i]) {\n      case 'clamp-to-edge':\n        return clamp(v, { min: 0, max: textureSize[i] - 1 });\n      case 'mirror-repeat':{\n          const n = Math.floor(v / textureSize[i]);\n          v = v - n * textureSize[i];\n          return (n & 1) !== 0 ? textureSize[i] - v - 1 : v;\n        }\n      case 'repeat':\n        return v - Math.floor(v / textureSize[i]) * textureSize[i];\n      default:\n        unreachable();\n    }\n  });\n}\n\n/**\n * Generates an array of coordinates at which to sample a texture for a cubemap\n */\nexport function generateSamplePointsCube(\nn,\nargs)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n{\n  const { method, descriptor } = args;\n  const mipLevelCount = descriptor.mipLevelCount ?? 1;\n  const size = virtualMipSize('2d', descriptor.size, 0);\n  const textureWidth = size[0];\n  const coords = [];\n  switch (method) {\n    case 'texel-centre':{\n        for (let i = 0; i < n; i++) {\n          const r = hashU32(i);\n          const u = (Math.floor(lerp(0, textureWidth - 1, (r & 0xff) / 0xff)) + 0.5) / textureWidth;\n          const v =\n          (Math.floor(lerp(0, textureWidth - 1, (r >> 8 & 0xff) / 0xff)) + 0.5) / textureWidth;\n          const face = Math.floor(lerp(0, 6, (r >> 16 & 0xff) / 0x100));\n          coords.push(convertNormalized3DTexCoordToCubeCoord([u, v, face]));\n        }\n        break;\n      }\n    case 'spiral':{\n        const { radius = 1.5, loops = 2 } = args;\n        for (let i = 0; i < n; i++) {\n          const f = (i + 1) / (Math.max(n, 2) - 1);\n          const r = radius * f;\n          const theta = loops * 2 * Math.PI * f;\n          const phi = loops * 1.3 * Math.PI * f;\n          const sinTheta = Math.sin(theta);\n          const cosTheta = Math.cos(theta);\n          const sinPhi = Math.sin(phi);\n          const cosPhi = Math.cos(phi);\n          const ux = cosTheta * sinPhi;\n          const uy = cosPhi;\n          const uz = sinTheta * sinPhi;\n          coords.push([ux * r, uy * r, uz * r]);\n        }\n        break;\n      }\n    case 'cube-edges':{\n\n        coords.push(\n          // between edges\n          // +x\n          [1, -1.01, 0], // wrap -y\n          [1, +1.01, 0], // wrap +y\n          [1, 0, -1.01], // wrap -z\n          [1, 0, +1.01], // wrap +z\n          // -x\n          [-1, -1.01, 0], // wrap -y\n          [-1, +1.01, 0], // wrap +y\n          [-1, 0, -1.01], // wrap -z\n          [-1, 0, +1.01], // wrap +z\n\n          // +y\n          [-1.01, 1, 0], // wrap -x\n          [+1.01, 1, 0], // wrap +x\n          [0, 1, -1.01], // wrap -z\n          [0, 1, +1.01], // wrap +z\n          // -y\n          [-1.01, -1, 0], // wrap -x\n          [+1.01, -1, 0], // wrap +x\n          [0, -1, -1.01], // wrap -z\n          [0, -1, +1.01], // wrap +z\n\n          // +z\n          [-1.01, 0, 1], // wrap -x\n          [+1.01, 0, 1], // wrap +x\n          [0, -1.01, 1], // wrap -y\n          [0, +1.01, 1], // wrap +y\n          // -z\n          [-1.01, 0, -1], // wrap -x\n          [+1.01, 0, -1], // wrap +x\n          [0, -1.01, -1], // wrap -y\n          [0, +1.01, -1] // wrap +y\n\n          // corners (see comment \"Issues with corners of cubemaps\")\n          // for why these are commented out.\n          // [-1.01, -1.02, -1.03],\n          // [ 1.01, -1.02, -1.03],\n          // [-1.01,  1.02, -1.03],\n          // [ 1.01,  1.02, -1.03],\n          // [-1.01, -1.02,  1.03],\n          // [ 1.01, -1.02,  1.03],\n          // [-1.01,  1.02,  1.03],\n          // [ 1.01,  1.02,  1.03],\n        );\n        break;\n      }\n  }\n\n  const _hashInputs = args.hashInputs.map((v) =>\n  typeof v === 'string' ? sumOfCharCodesOfString(v) : typeof v === 'boolean' ? v ? 1 : 0 : v\n  );\n\n  // returns a number between [0 and N)\n  const makeRandValue = ({ num, type }, ...hashInputs) => {\n    const range = num;\n    const number = hashU32(..._hashInputs, ...hashInputs) / 0x1_0000_0000 * range;\n    return type === 'f32' ? number : Math.floor(number);\n  };\n\n  // for signed and float values returns [-1 to num]\n  // for unsigned values returns [0 to num]\n  const makeRangeValue = ({ num, type }, ...hashInputs) => {\n    const range = num + (type === 'u32' ? 1 : 2);\n    const number =\n    hashU32(..._hashInputs, ...hashInputs) / 0x1_0000_0000 * range - (type === 'u32' ? 0 : 1);\n    return type === 'f32' ? number : Math.floor(number);\n  };\n\n  const makeIntHashValue = (min, max, ...hashInputs) => {\n    const range = max - min;\n    return min + Math.floor(hashU32(..._hashInputs, ...hashInputs) / 0x1_0000_0000 * range);\n  };\n\n  // Samplers across devices use different methods to interpolate.\n  // Quantizing the texture coordinates seems to hit coords that produce\n  // comparable results to our computed results.\n  // Note: This value works with 8x8 textures. Other sizes have not been tested.\n  // Values that worked for reference:\n  // Win 11, NVidia 2070 Super: 16\n  // Linux, AMD Radeon Pro WX 3200: 256\n  // MacOS, M1 Mac: 256\n  //\n  // Note: When doing `textureGather...` we can't use texel centers\n  // because which 4 pixels will be gathered jumps if we're slightly under\n  // or slightly over the center\n  //\n  // Similarly, if we're using 'nearest' filtering then we don't want texel\n  // edges for the same reason.\n  //\n  // Also note that for textureGather. The way it works for cube maps is to\n  // first convert from cube map coordinate to a 2D texture coordinate and\n  // a face. Then, choose 4 texels just like normal 2D texture coordinates.\n  // If one of the 4 texels is outside the current face, wrap it to the correct\n  // face.\n  //\n  // An issue this brings up though. Imagine a 2D texture with addressMode = 'repeat'\n  //\n  //       2d texture   (same texture repeated to show 'repeat')\n  //     ┌───┬───┬───┐     ┌───┬───┬───┐\n  //     │   │   │   │     │   │   │   │\n  //     ├───┼───┼───┤     ├───┼───┼───┤\n  //     │   │   │  a│     │c  │   │   │\n  //     ├───┼───┼───┤     ├───┼───┼───┤\n  //     │   │   │  b│     │d  │   │   │\n  //     └───┴───┴───┘     └───┴───┴───┘\n  //\n  // Assume the texture coordinate is at the bottom right corner of a.\n  // Then textureGather will grab c, d, b, a (no idea why that order).\n  // but think of it as top-right, bottom-right, bottom-left, top-left.\n  // Similarly, if the texture coordinate is at the top left of d it\n  // will select the same 4 texels.\n  //\n  // But, in the case of a cubemap, each face is in different direction\n  // relative to the face next to it.\n  //\n  //             +-----------+\n  //             |0->u       |\n  //             |↓          |\n  //             |v   +y     |\n  //             |    (2)    |\n  //             |           |\n  // +-----------+-----------+-----------+-----------+\n  // |0->u       |0->u       |0->u       |0->u       |\n  // |↓          |↓          |↓          |↓          |\n  // |v   -x     |v   +z     |v   +x     |v   -z     |\n  // |    (1)    |    (4)    |    (0)    |    (5)    |\n  // |           |           |           |           |\n  // +-----------+-----------+-----------+-----------+\n  //             |0->u       |\n  //             |↓          |\n  //             |v   -y     |\n  //             |    (3)    |\n  //             |           |\n  //             +-----------+\n  //\n  // As an example, imagine going from the +y to the +x face.\n  // See diagram above, the right edge of the +y face wraps\n  // to the top edge of the +x face.\n  //\n  //                             +---+---+\n  //                             |  a|c  |\n  //     ┌───┬───┬───┐           ┌───┬───┬───┐\n  //     │   │   │   │           │  b│d  │   │\n  //     ├───┼───┼───┤---+       ├───┼───┼───┤\n  //     │   │   │  a│ c |       │   │   │   │\n  //     ├───┼───┼───┤---+       ├───┼───┼───┤\n  //     │   │   │  b│ d |       │   │   │   │\n  //     └───┴───┴───┘---+       └───┴───┴───┘\n  //        +y face                 +x face\n  //\n  // If the texture coordinate is in the bottom right corner of a,\n  // the rectangle of texels we read are a,b,c,d and, if we the\n  // texture coordinate is in the top left corner of d we also\n  // read a,b,c,d according to the 2 diagrams above.\n  //\n  // But, notice that when reading from the POV of +y vs +x,\n  // which actual a,b,c,d texels are different.\n  //\n  // From the POV of face +x: a,b are in face +x and c,d are in face +y\n  // From the POV of face +y: a,c are in face +x and b,d are in face +y\n  //\n  // This is all the long way of saying that if we're on the edge of a cube\n  // face we could get drastically different results because the orientation\n  // of the rectangle of the 4 texels we use, rotates. So, we need to avoid\n  // any values too close to the edge just in case our math is different than\n  // the GPU's.\n  //\n  const kSubdivisionsPerTexel = 4;\n  const avoidEdgeCase =\n  !args.sampler || args.sampler.minFilter === 'nearest' || isBuiltinGather(args.textureBuiltin);\n  const edgeRemainder = isBuiltinGather(args.textureBuiltin) ? kSubdivisionsPerTexel / 2 : 0;\n  return coords.map((c, i) => {\n    const mipLevel = args.mipLevel ?\n    quantizeMipLevel(makeRangeValue(args.mipLevel, i), args.sampler?.mipmapFilter ?? 'nearest') :\n    0;\n    const clampedMipLevel = clamp(mipLevel, { min: 0, max: mipLevelCount - 1 });\n    const mipSize = virtualMipSize('2d', size, Math.ceil(clampedMipLevel));\n    const q = [\n    mipSize[0] * kSubdivisionsPerTexel,\n    mipSize[0] * kSubdivisionsPerTexel,\n    6 * kSubdivisionsPerTexel];\n\n\n    const uvw = convertCubeCoordToNormalized3DTextureCoord(c);\n\n    // If this is a corner, move to in so it's not\n    // (see comment \"Issues with corners of cubemaps\")\n    const ndx = getUnusedCubeCornerSampleIndex(mipSize[0], uvw);\n    if (ndx >= 0) {\n      const halfTexel = 0.5 / mipSize[0];\n      uvw[0] = clamp(uvw[0], { min: halfTexel, max: 1 - halfTexel });\n    }\n\n    const quantizedUVW = uvw.map((v, i) => {\n      // Quantize to kSubdivisionsPerPixel\n      const v1 = Math.floor(v * q[i]);\n      // If it's nearest or textureGather and we're on the edge of a texel then move us off the edge\n      // since the edge could choose one texel or another.\n      const isEdgeCase = Math.abs(v1 % kSubdivisionsPerTexel) === edgeRemainder;\n      const v2 = isEdgeCase && avoidEdgeCase ? v1 + 1 : v1;\n      // Convert back to texture coords slightly off\n      return (v2 + 1 / 16) / q[i];\n    });\n\n    const quantize = (v, units) => Math.floor(v * units) * units;\n\n    const makeGradient = (hashInput) => {\n      return coords.map((_, i) =>\n      // a value between -4 and 4, quantized to 1/3rd.\n      quantize(makeRangeValue({ num: 8, type: 'f32' }, i, hashInput) - 4, 1 / 3)\n      );\n    };\n\n    const coords = convertNormalized3DTexCoordToCubeCoord(quantizedUVW);\n\n    // choose a derivative value that will select a mipLevel.\n    const makeDerivativeMult = (coords, mipLevel) => {\n      // Make an identity vec (all 1s).\n      const mult = new Array(coords.length).fill(0);\n      // choose one axis to set\n      const ndx = makeRangeValue({ num: coords.length - 1, type: 'u32' }, i, 8);\n      assert(ndx < coords.length);\n      mult[ndx] = Math.pow(2, mipLevel);\n      return mult;\n    };\n\n    // Choose a mip level. If mipmapFilter is 'nearest' then avoid centers of levels\n    // else avoid edges.\n    const chooseMipLevel = () => {\n      const innerLevelR = makeRandValue({ num: 9, type: 'u32' }, i, 11);\n      const innerLevel =\n      args?.sampler?.mipmapFilter === 'linear' ?\n      innerLevelR + 1 :\n      innerLevelR < 4 ?\n      innerLevelR :\n      innerLevelR + 1;\n      const outerLevel = makeRangeValue({ num: mipLevelCount - 1, type: 'i32' }, i, 11);\n      return outerLevel + innerLevel / 10;\n    };\n\n    // for textureSample, choose a derivative value that will select a mipLevel near\n    // the range of mip levels.\n    const makeDerivativeMultForTextureSample = (coords) => {\n      const mipLevel = chooseMipLevel();\n      return makeDerivativeMult(coords, mipLevel);\n    };\n\n    // for textureSampleBias we choose a mipLevel we want to sample, then a bias between -17 and 17.\n    // and then a derivative that, given the chosen bias will arrive at the chosen mipLevel.\n    // The GPU is supposed to clamp between -16.0 and 15.99.\n    const makeBiasAndDerivativeMult = (coords) => {\n      const mipLevel = chooseMipLevel();\n      const bias = makeRangeValue({ num: 34, type: 'f32' }, i, 9) - 17;\n      const clampedBias = clamp(bias, { min: -16, max: 15.99 });\n      const derivativeBasedMipLevel = mipLevel - clampedBias;\n      const derivativeMult = makeDerivativeMult(coords, derivativeBasedMipLevel);\n      return [bias, derivativeMult];\n    };\n\n    // If bias is set this is textureSampleBias. If bias is not set but derivatives\n    // is then this is one of the other functions that needs implicit derivatives.\n    const [bias, derivativeMult] = args.bias ?\n    makeBiasAndDerivativeMult(coords) :\n    args.derivatives ?\n    [undefined, makeDerivativeMultForTextureSample(coords)] :\n    [];\n\n    return {\n      coords,\n      derivativeMult,\n      ddx: args.grad ? makeGradient(7) : undefined,\n      ddy: args.grad ? makeGradient(8) : undefined,\n      mipLevel,\n      arrayIndex: args.arrayIndex ? makeRangeValue(args.arrayIndex, i, 2) : undefined,\n      bias,\n      // use 0.0, 0.5, or 1.0 for depthRef. We can't test for equality except for values 0 and 1\n      // The texture will be filled with random values unless our comparison is 'equal' or 'not-equal'\n      // in which case the texture will be filled with only 0, 0.6, 1. Choosing 0.0, 0.5, 1.0 here\n      // means we can test 'equal' and 'not-equal'. For other comparisons, the fact that the texture's\n      // contents is random seems enough to test all the comparison modes.\n      depthRef: args.depthRef ? makeRandValue({ num: 3, type: 'u32' }, i, 5) / 2 : undefined,\n      component: args.component ? makeIntHashValue(0, 4, i, 4) : undefined\n    };\n  });\n}\n\nfunction wgslTypeFor(data, type) {\n  if (Array.isArray(data)) {\n    switch (data.length) {\n      case 1:\n        return `${type}32`;\n      case 2:\n        return `vec2${type}`;\n      case 3:\n        return `vec3${type}`;\n      default:\n        unreachable();\n    }\n  }\n  return `${type}32`;\n}\n\nfunction wgslExpr(\ndata)\n{\n  if (Array.isArray(data)) {\n    switch (data.length) {\n      case 1:\n        return data[0].toString();\n      case 2:\n        return `vec2(${data.map((v) => v.toString()).join(', ')})`;\n      case 3:\n        return `vec3(${data.map((v) => v.toString()).join(', ')})`;\n      default:\n        unreachable();\n    }\n  }\n  return data.toString();\n}\n\nfunction wgslExprFor(data, type) {\n  if (Array.isArray(data)) {\n    switch (data.length) {\n      case 1:\n        return `${type}(${data[0].toString()})`;\n      case 2:\n        return `vec2${type}(${data.map((v) => v.toString()).join(', ')})`;\n      case 3:\n        return `vec3${type}(${data.map((v) => v.toString()).join(', ')})`;\n      default:\n        unreachable();\n    }\n  }\n  return `${type}32(${data.toString()})`;\n}\n\nfunction binKey(call) {\n  const keys = [];\n  for (const name of kTextureCallArgNames) {\n    const value = call[name];\n    if (value !== undefined) {\n      if (name === 'offset' || name === 'component') {\n        // offset and component must be constant expressions\n        keys.push(`${name}: ${wgslExpr(value)}`);\n      } else {\n        keys.push(`${name}: ${wgslTypeFor(value, call.coordType)}`);\n      }\n    }\n  }\n  return `${call.builtin}(${keys.join(', ')})`;\n}\n\nfunction buildBinnedCalls(calls) {\n  const args = [];\n  const fields = [];\n  const data = [];\n  const prototype = calls[0];\n\n  if (isBuiltinGather(prototype.builtin) && prototype['componentType']) {\n    args.push(`/* component */ ${wgslExpr(prototype['component'])}`);\n  }\n\n  // All texture builtins take a Texture\n  args.push('T');\n\n  if (builtinNeedsSampler(prototype.builtin)) {\n    // textureSample*() builtins take a sampler as the second argument\n    args.push('S');\n  }\n\n  for (const name of kTextureCallArgNames) {\n    const value = prototype[name];\n    if (value !== undefined) {\n      if (name === 'offset') {\n        args.push(`/* offset */ ${wgslExpr(value)}`);\n      } else if (name === 'component') {\n\n        // was handled above\n      } else {const type =\n        name === 'mipLevel' ?\n        prototype.levelType :\n        name === 'arrayIndex' ?\n        prototype.arrayIndexType :\n        name === 'sampleIndex' ?\n        prototype.sampleIndexType :\n        name === 'bias' || name === 'depthRef' || name === 'ddx' || name === 'ddy' ?\n        'f' :\n        prototype.coordType;\n        if (name !== 'derivativeMult') {\n          args.push(\n            `args.${name}${\n            name === 'coords' && builtinNeedsDerivatives(prototype.builtin) ?\n            ' + derivativeBase * args.derivativeMult' :\n            ''}`\n\n          );\n        }\n        fields.push(`@align(16) ${name} : ${wgslTypeFor(value, type)}`);\n      }\n    }\n  }\n\n  for (const call of calls) {\n    for (const name of kTextureCallArgNames) {\n      const value = call[name];\n      assert(\n        prototype[name] === undefined === (value === undefined),\n        'texture calls are not binned correctly'\n      );\n      if (value !== undefined && name !== 'offset' && name !== 'component') {\n        const type = getCallArgType(call, name);\n        const bitcastToU32 = kBitCastFunctions[type];\n        if (value instanceof Array) {\n          for (const c of value) {\n            data.push(bitcastToU32(c));\n          }\n        } else {\n          data.push(bitcastToU32(value));\n        }\n        // All fields are aligned to 16 bytes.\n        while ((data.length & 3) !== 0) {\n          data.push(0);\n        }\n      }\n    }\n  }\n\n  const expr = `${prototype.builtin}(${args.join(', ')})`;\n\n  return { expr, fields, data };\n}\n\nfunction binCalls(calls) {\n  const map = new Map(); // key to bin index\n  const bins = [];\n  calls.forEach((call, callIdx) => {\n    const key = binKey(call);\n    const binIdx = map.get(key);\n    if (binIdx === undefined) {\n      map.set(key, bins.length);\n      bins.push([callIdx]);\n    } else {\n      bins[binIdx].push(callIdx);\n    }\n  });\n  return bins;\n}\n\nfunction describeTextureCall(call) {\n  const args = [];\n  if (isBuiltinGather(call.builtin) && call.componentType) {\n    args.push(`component: ${wgslExprFor(call.component, call.componentType)}`);\n  }\n  args.push('texture: T');\n  if (builtinNeedsSampler(call.builtin)) {\n    args.push('sampler: S');\n  }\n  for (const name of kTextureCallArgNames) {\n    const value = call[name];\n    if (value !== undefined && name !== 'component') {\n      if (name === 'coords') {\n        const derivativeWGSL = builtinNeedsDerivatives(call.builtin) ?\n        ` + derivativeBase * derivativeMult(${\n        call.derivativeMult ? wgslExprFor(call.derivativeMult, call.coordType) : '1'})` :\n\n        '';\n        args.push(`${name}: ${wgslExprFor(value, call.coordType)}${derivativeWGSL}`);\n      } else if (name === 'derivativeMult') {\n\n        // skip this - it's covered in 'coords'\n      } else if (name === 'ddx' || name === 'ddy') {args.push(`${name}: ${wgslExprFor(value, call.coordType)}`);\n      } else if (name === 'mipLevel') {\n        args.push(`${name}: ${wgslExprFor(value, call.levelType)}`);\n      } else if (name === 'arrayIndex') {\n        args.push(`${name}: ${wgslExprFor(value, call.arrayIndexType)}`);\n      } else if (name === 'bias') {\n        args.push(`${name}: ${wgslExprFor(value, 'f')}`);\n      } else if (name === 'sampleIndex') {\n        args.push(`${name}: ${wgslExprFor(value, call.sampleIndexType)}`);\n      } else if (name === 'depthRef') {\n        args.push(`${name}: ${wgslExprFor(value, 'f')}`);\n      } else {\n        args.push(`${name}: ${wgslExpr(value)}`);\n      }\n    }\n  }\n  return `${call.builtin}(${args.join(', ')})`;\n}\n\nconst getAspectForTexture = (texture) =>\ntexture instanceof GPUExternalTexture ?\n'all' :\nisDepthTextureFormat(texture.format) ?\n'depth-only' :\nisStencilTextureFormat(texture.format) ?\n'stencil-only' :\n'all';\n\nconst s_deviceToPipelines = new WeakMap(\n\n\n);\n\n/**\n * Given a list of \"calls\", each one of which has a texture coordinate,\n * generates a fragment shader that uses the instance_index as an index. That\n * index is then used to look up a coordinate from a storage buffer which is\n * used to call the WGSL texture function to read/sample the texture, and then\n * write to a storage buffer. We then read the storage buffer for the per \"call\"\n * results.\n *\n * We use a 1x1 target and use instance drawing, once instance per call.\n * This allows use to more easily adjust derivatives per call.\n *\n * An issue we ran into before this \"one draw call per instance\" change;\n * Before we had a single draw call and wrote the result of one call per\n * pixel rendered.\n *\n * Imagine we have code like this:\n *\n * ```\n * @group(0) @binding(0) var T: texture_2d<f32>;\n * @group(0) @binding(1) var S: sampler;\n * @group(0) @binding(2) var<storage> coords: array<vec4f>;\n * @fragment fn fs(@builtin(position) pos: vec4f) -> vec4f {\n *   let ndx = u32(pos.x) * u32(pos.y) * targetWidth;\n *   return textureSample(T, S, coords[ndx].xy);\n * }\n * ```\n *\n * T points to 8x8 pixel texture with 3 mip levels\n * S is 'nearest'\n * coords: is a storage buffer, 16 bytes long [0,0,0,0], one vec4f.\n * our render target is 1x1 pixels\n *\n * Looking above it appears `ndx` will only ever be 0 but that's\n * not what happens. Instead, the GPU will run the fragment shader for\n * a 2x2 area. It does this to compute derivatives by running the code\n * above and looking at what values it gets passed as coords to\n * textureSample. When it does this it ends up with\n *\n * ndx = 0 for invocation 0\n * ndx = 1 for invocation 1\n * ndx = 0 + 1 * targetWidth for invocation 2\n * ndx = 1 + 1 * targetWidth for invocation 3\n *\n * In 3 of those cases `ndx` is out of bounds with respect to `coords`.\n * Out of bounds access is indeterminate. That means the derivatives are\n * indeterminate so what lod it tries to read is indeterminate.\n *\n * By using instance_index for ndx we avoid this issue. ndx is the same\n * on all 4 executions.\n *\n * Calls are \"binned\" by call parameters. Each bin has its own structure and\n * field in the storage buffer. This allows the calls to be non-homogenous and\n * each have their own data type for coordinates.\n *\n * Note: this function returns:\n *\n * 'results': an array of results, one for each call.\n *\n * 'run': a function that accepts a texture and runs the same class pipeline with\n *        that texture as input, returning an array of results. This can be used by\n *        identifySamplePoints to query the mix-weights used. We do this so we're\n *        using the same shader that generated the original results when querying\n *        the weights.\n *\n * 'destroy': a function that cleans up the buffers used by `run`.\n */\nfunction createTextureCallsRunner(\nt,\n{\n  format,\n  dimension,\n  sampleCount,\n  depthOrArrayLayers\n\n\n\n\n\n},\nviewDescriptor,\ntextureType,\nsampler,\ncalls,\nstage)\n{\n  let structs = '';\n  let body = '';\n  let dataFields = '';\n  const data = [];\n  let callCount = 0;\n  const binned = binCalls(calls);\n  binned.forEach((binCalls, binIdx) => {\n    const b = buildBinnedCalls(binCalls.map((callIdx) => calls[callIdx]));\n    structs += `struct Args${binIdx} {\n  ${b.fields.join(',\\n  ')}\n}\n`;\n    dataFields += `  args${binIdx} : array<Args${binIdx}, ${binCalls.length}>,\n`;\n    body += `\n  {\n    let is_active = (idx >= ${callCount}) & (idx < ${callCount + binCalls.length});\n    let args = data.args${binIdx}[idx - ${callCount}];\n    let call = ${b.expr};\n    result = select(result, call, is_active);\n  }\n`;\n    callCount += binCalls.length;\n    data.push(...b.data);\n  });\n\n  const dataBuffer = t.createBufferTracked({\n    size: data.length * 4,\n    usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM\n  });\n  t.device.queue.writeBuffer(dataBuffer, 0, new Uint32Array(data));\n\n  const builtin = calls[0].builtin;\n  const isCompare = isBuiltinComparison(builtin);\n\n  const { resultType, resultFormat, componentType } = isBuiltinGather(builtin) ?\n  getTextureFormatTypeInfo(format) :\n  textureType === 'texture_external' ?\n  { resultType: 'vec4f', resultFormat: 'rgba32float', componentType: 'f32' } :\n  textureType.includes('depth') ?\n  { resultType: 'f32', resultFormat: 'rgba32float', componentType: 'f32' } :\n  getTextureFormatTypeInfo(format);\n  const returnType = `vec4<${componentType}>`;\n\n  const samplerType = isCompare ? 'sampler_comparison' : 'sampler';\n\n  const renderTarget = t.createTextureTracked({\n    format: 'rgba32uint',\n    size: [calls.length, 1],\n    usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT\n  });\n\n  // derivativeBase is a number that starts at (0, 0, 0) and advances by 1 in x, y\n  // for each fragment shader iteration in texel space. It is then converted to normalized\n  // texture space by dividing by the textureDimensions.\n  // Since it's moving by 1 texel unit we can multiply it to get any specific lod value we want.\n  // Because it starts at (0, 0, 0) it will not affect our texture coordinate.\n  const derivativeBaseWGSL = `\n  let derivativeBase = ${\n  isCubeViewDimension(viewDescriptor) ?\n  '(v.pos.xyx - 0.5 - vec3f(f32(v.ndx), 0, f32(v.ndx))) / vec3f(vec2f(textureDimensions(T)), 1.0)' :\n  dimension === '1d' ?\n  'f32(v.pos.x - 0.5 - f32(v.ndx)) / f32(textureDimensions(T))' :\n  dimension === '3d' ?\n  'vec3f(v.pos.xy - 0.5 - vec2f(f32(v.ndx), 0), 0) / vec3f(textureDimensions(T))' :\n  '(v.pos.xy - 0.5 - vec2f(f32(v.ndx), 0)) / vec2f(textureDimensions(T))'};`;\n\n  const derivativeType =\n  isCubeViewDimension(viewDescriptor) || dimension === '3d' ?\n  'vec3f' :\n  dimension === '1d' ?\n  'f32' :\n  'vec2f';\n\n  const stageWGSL =\n  stage === 'vertex' ?\n  `\n// --------------------------- vertex stage shaders --------------------------------\n@vertex fn vsVertex(\n    @builtin(vertex_index) vertex_index : u32,\n    @builtin(instance_index) instance_index : u32) -> VOut {\n  let positions = array(vec2f(-1, 3), vec2f(3, -1), vec2f(-1, -1));\n  return VOut(vec4f(positions[vertex_index], 0, 1),\n              instance_index,\n              getResult(instance_index, ${derivativeType}(0)));\n}\n\n@fragment fn fsVertex(v: VOut) -> @location(0) vec4u {\n  return bitcast<vec4u>(v.result);\n}\n` :\n  stage === 'fragment' ?\n  `\n// --------------------------- fragment stage shaders --------------------------------\n@vertex fn vsFragment(\n    @builtin(vertex_index) vertex_index : u32,\n    @builtin(instance_index) instance_index : u32) -> VOut {\n  let positions = array(vec2f(-1, 3), vec2f(3, -1), vec2f(-1, -1));\n  return VOut(vec4f(positions[vertex_index], 0, 1), instance_index, ${returnType}(0));\n}\n\n@fragment fn fsFragment(v: VOut) -> @location(0) vec4u {\n  ${derivativeBaseWGSL}\n  return bitcast<vec4u>(getResult(v.ndx, derivativeBase));\n}\n` :\n  `\n// --------------------------- compute stage shaders --------------------------------\n@group(1) @binding(0) var<storage, read_write> results: array<${returnType}>;\n\n@compute @workgroup_size(1) fn csCompute(@builtin(global_invocation_id) id: vec3u) {\n  results[id.x] = getResult(id.x, ${derivativeType}(0));\n}\n`;\n\n  const code = `\n${structs}\n\nstruct Data {\n${dataFields}\n}\n\nstruct VOut {\n  @builtin(position) pos: vec4f,\n  @location(0) @interpolate(flat, either) ndx: u32,\n  @location(1) @interpolate(flat, either) result: ${returnType},\n};\n\n@group(0) @binding(0) var          T    : ${textureType};\n${sampler ? `@group(0) @binding(1) var          S    : ${samplerType}` : ''};\n@group(0) @binding(2) var<uniform> data : Data;\n\nfn getResult(idx: u32, derivativeBase: ${derivativeType}) -> ${returnType} {\n  var result : ${resultType};\n${body}\n  return ${returnType}(result);\n}\n\n${stageWGSL}\n`;\n\n  const pipelines =\n  s_deviceToPipelines.get(t.device) ?? new Map();\n  s_deviceToPipelines.set(t.device, pipelines);\n\n  // unfilterable-float textures can only be used with manually created bindGroupLayouts\n  // since the default 'auto' layout requires filterable textures/samplers.\n  // So, if we don't need filtering, don't request a filtering sampler. If we require\n  // filtering then check if the format is 32float format and if float32-filterable\n  // is enabled.\n  const info = kTextureFormatInfo[format ?? 'rgba8unorm'];\n  const isFiltering =\n  !!sampler && (\n  sampler.minFilter === 'linear' ||\n  sampler.magFilter === 'linear' ||\n  sampler.mipmapFilter === 'linear');\n  let sampleType = textureType.startsWith('texture_depth') ?\n  'depth' :\n  isDepthTextureFormat(format) ?\n  'unfilterable-float' :\n  isStencilTextureFormat(format) ?\n  'uint' :\n  info.color?.type ?? 'float';\n  if (isFiltering && sampleType === 'unfilterable-float') {\n    assert(is32Float(format));\n    assert(t.device.features.has('float32-filterable'));\n    sampleType = 'float';\n  }\n  if (sampleCount > 1 && sampleType === 'float') {\n    sampleType = 'unfilterable-float';\n  }\n\n  const visibility =\n  stage === 'compute' ?\n  GPUShaderStage.COMPUTE :\n  stage === 'fragment' ?\n  GPUShaderStage.FRAGMENT :\n  GPUShaderStage.VERTEX;\n\n  const entries = [\n  {\n    binding: 2,\n    visibility,\n    buffer: {\n      type: 'uniform'\n    }\n  }];\n\n\n  const viewDimension = effectiveViewDimensionForDimension(\n    viewDescriptor.dimension,\n    dimension,\n    depthOrArrayLayers\n  );\n\n  if (textureType.includes('storage')) {\n    entries.push({\n      binding: 0,\n      visibility,\n      storageTexture: {\n        access: 'read-only',\n        viewDimension,\n        format\n      }\n    });\n  } else if (textureType === 'texture_external') {\n    entries.push({\n      binding: 0,\n      visibility,\n      externalTexture: {}\n    });\n  } else {\n    entries.push({\n      binding: 0,\n      visibility,\n      texture: {\n        sampleType,\n        viewDimension,\n        multisampled: sampleCount > 1\n      }\n    });\n  }\n\n  if (sampler) {\n    const type = isCompare ? 'comparison' : isFiltering ? 'filtering' : 'non-filtering';\n    entries.push({\n      binding: 1,\n      visibility,\n      sampler: { type }\n    });\n  }\n\n  const id = `${resultType}:${stage}:${JSON.stringify(entries)}:${code}`;\n  let pipeline = pipelines.get(id);\n  if (!pipeline) {\n    const module = t.device.createShaderModule({ code });\n    const bindGroupLayout0 = t.device.createBindGroupLayout({ entries });\n    const bindGroupLayouts = [bindGroupLayout0];\n\n    if (stage === 'compute') {\n      const bindGroupLayout1 = t.device.createBindGroupLayout({\n        entries: [\n        {\n          binding: 0,\n          visibility: GPUShaderStage.FRAGMENT | GPUShaderStage.COMPUTE,\n          buffer: {\n            type: 'storage'\n          }\n        }]\n\n      });\n      bindGroupLayouts.push(bindGroupLayout1);\n    }\n\n    const layout = t.device.createPipelineLayout({\n      bindGroupLayouts\n    });\n\n    switch (stage) {\n      case 'compute':\n        pipeline = t.device.createComputePipeline({\n          layout,\n          compute: { module }\n        });\n        break;\n      case 'fragment':\n      case 'vertex':\n        pipeline = t.device.createRenderPipeline({\n          layout,\n          vertex: { module },\n          fragment: {\n            module,\n            targets: [{ format: 'rgba32uint' }]\n          }\n        });\n        break;\n    }\n    pipelines.set(id, pipeline);\n  }\n\n  const gpuSampler = sampler ? t.device.createSampler(sampler) : undefined;\n\n  const run = async (gpuTexture) => {\n    const resultBuffer = t.createBufferTracked({\n      size: align(calls.length * 16, 256),\n      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ\n    });\n\n    const aspect = getAspectForTexture(gpuTexture);\n    const runViewDescriptor = {\n      ...viewDescriptor,\n      aspect\n    };\n\n    const bindGroup0 = t.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [\n      {\n        binding: 0,\n        resource:\n        gpuTexture instanceof GPUExternalTexture ?\n        gpuTexture :\n        gpuTexture.createView(runViewDescriptor)\n      },\n      ...(sampler ? [{ binding: 1, resource: gpuSampler }] : []),\n      { binding: 2, resource: { buffer: dataBuffer } }]\n\n    });\n\n    let storageBuffer;\n    const encoder = globalThis._TRAMPOLINE_(\"createCommandEncoder\", t.device, t.device.createCommandEncoder, [], () => t.device.createCommandEncoder());\n\n    if (stage === 'compute') {\n      storageBuffer = t.createBufferTracked({\n        size: resultBuffer.size,\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC\n      });\n\n      const bindGroup1 = t.device.createBindGroup({\n        layout: pipeline.getBindGroupLayout(1),\n        entries: [{ binding: 0, resource: { buffer: storageBuffer } }]\n      });\n\n      const pass = encoder.beginComputePass();\n      pass.setPipeline(pipeline);\n      pass.setBindGroup(0, bindGroup0);\n      pass.setBindGroup(1, bindGroup1);\n      pass.dispatchWorkgroups(calls.length);\n      pass.end();\n      encoder.copyBufferToBuffer(storageBuffer, 0, resultBuffer, 0, storageBuffer.size);\n    } else {\n      const pass = encoder.beginRenderPass({\n        colorAttachments: [\n        {\n          view: renderTarget.createView(),\n          loadOp: 'clear',\n          storeOp: 'store'\n        }]\n\n      });\n\n      pass.setPipeline(pipeline);\n      pass.setBindGroup(0, bindGroup0);\n      for (let i = 0; i < calls.length; ++i) {\n        pass.setViewport(i, 0, 1, 1, 0, 1);\n        pass.draw(3, 1, 0, i);\n      }\n      pass.end();\n      encoder.copyTextureToBuffer(\n        { texture: renderTarget },\n        {\n          buffer: resultBuffer,\n          bytesPerRow: resultBuffer.size\n        },\n        [renderTarget.width, 1]\n      );\n    }\n    globalThis._TRAMPOLINE_(\"submit\", t.device, t.device.queue.submit, [[encoder.finish()]], () => t.device.queue.submit([encoder.finish()]));\n\n    await globalThis._TRAMPOLINE_(\"mapAsync\", resultBuffer, resultBuffer.mapAsync, [GPUMapMode.READ], () => resultBuffer.mapAsync(GPUMapMode.READ));\n\n    const view = TexelView.fromTextureDataByReference(\n      resultFormat,\n      new Uint8Array(resultBuffer.getMappedRange()),\n      {\n        bytesPerRow: calls.length * 16,\n        rowsPerImage: 1,\n        subrectOrigin: [0, 0, 0],\n        subrectSize: [calls.length, 1]\n      }\n    );\n\n    let outIdx = 0;\n    const out = new Array(calls.length);\n    for (const bin of binned) {\n      for (const callIdx of bin) {\n        const x = outIdx;\n        out[callIdx] = view.color({ x, y: 0, z: 0 });\n        outIdx++;\n      }\n    }\n\n    storageBuffer?.destroy();\n    globalThis._TRAMPOLINE_(\"destroy\", resultBuffer, resultBuffer.destroy, [], () => resultBuffer.destroy());\n\n    return out;\n  };\n\n  return {\n    run,\n    destroy() {\n      globalThis._TRAMPOLINE_(\"destroy\", dataBuffer, dataBuffer.destroy, [], () => dataBuffer.destroy());\n      globalThis._TRAMPOLINE_(\"destroy\", renderTarget, renderTarget.destroy, [], () => renderTarget.destroy());\n    }\n  };\n}\n\nexport async function doTextureCalls(\nt,\ngpuTexture,\nviewDescriptor,\ntextureType,\nsampler,\ncalls,\nshortShaderStage)\n{\n  const stage = kShortShaderStageToShaderStage[shortShaderStage];\n  const runner = createTextureCallsRunner(\n    t,\n    gpuTexture instanceof GPUExternalTexture ?\n    { format: 'rgba8unorm', dimension: '2d', depthOrArrayLayers: 1, sampleCount: 1 } :\n    gpuTexture,\n    viewDescriptor,\n    textureType,\n    sampler,\n    calls,\n    stage\n  );\n  const results = await runner.run(gpuTexture);\n\n  return {\n    runner,\n    results\n  };\n}"],"mappings":"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O,CAAC;AAC3B,CAAC;EACC,MAAM,EAAE;;EAER;EACAlH,MAAM;IACJkH,OAAO,CAAC,CAAC,CAAC,KAAK,CAAC;IAChB,UAAUG,KAAK,iCAAiCH,OAAO,CAAC,CAAC,CAAC,KAAKI,WAAW,CAAC,CAAC;EAC9E,CAAC;EACDtH,MAAM;IACJkH,OAAO,CAACQ,oBAAoB,CAAC,KAAK,CAAC;IACnC,UAAUL,KAAK;IACfH,OAAO,CAACQ,oBAAoB,CAAC;IAC7BJ,WAAW,CAAC,CAAC;EACf,CAAC;;EAED;EACA;EACA;EACA;EACA,MAAMK,wBAAwB,GAAG,EAAE;EACnC3H,MAAM;IACJ,IAAIsD,GAAG,CAAC4D,OAAO,CAAC,CAACtD,IAAI,KAAKsD,OAAO,CAAC5B,MAAM,GAAGqC,wBAAwB,GAAG,IAAI,GAAG,CAAC,CAAC;IAC/E,UAAUN,KAAK,wBAAwBM,wBAAwB,qBAAqBL,WAAW,CAAC,CAAC;EACnG,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,eAAeM,gCAAgCA,CAACzE,CAAC,EAAEkE,KAAK,EAAE;EAC/D,MAAM,EAAEQ,MAAM,CAAC,CAAC,GAAG1E,CAAC;EACpB,MAAM2E,eAAe,GAAG,CAAC;EACzB9H,MAAM,CAAC8H,eAAe,IAAI,CAAC,C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A,OAAO,CAACS,OAAO,CAAC;IACxC,MAAM5B,UAAU,GAAGX,mBAAmB,CAAC1Z,CAAC,EAAEkE,KAAK,EAAEkP,IAAI,EAAErO,OAAO,EAAEW,OAAO,CAAC;IACxE;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,MAAMwW,6BAA6B;IACnC9I,IAAI,CAAC+F,IAAI,IAAI,EAAE,GAAGY,iBAAiB,IAAI,CAAC,GAAG3G,IAAI,CAAC+F,IAAI,GAAG,EAAE,CAAC,GAAGY,iBAAiB;;IAE9E;IACA;IACA;IACA3c,6BAA6B,CAACoC,MAAM,CAAC;IACrCgT,eAAe,CAACY,IAAI,CAAC3R,OAAO,CAAC;IAC7B2R,IAAI,CAACxE,SAAS,GAAG,CAAC;IAClB;MACE;IACF;;IAEA;IACAqL,wBAAwB;MACtBH,OAAO;MACP/U,OAAO,CAACkR,UAAU,CAACzW,MAAM;MACzB6a,UAAU;MACV7a,MAAM;MACN0c;IACF,CAAC;IACD;MACE;IACF;;IAEA,IAAI,CAACxW,OAAO,IAAIwU,oBAAoB,CAACnV,OAAO,EAAEqO,IAAI,EAAE0G,OAAO,EAAEoC,6BAA6B,CAAC,EAAE;MAC3F;IACF;;IAEA,MAAMzB,IAAI,GAAGQ,2BAA2B,CAACnB,OAAO,EAAEta,MAAM,EAAE4T,IAAI,CAAC3R,OAAO,EAAE2R,IAAI,CAACxE,SAAS,CAAC;IACvF,MAAMgM,IAAI,GAAGK,2BAA2B,CAACZ,UAAU,EAAE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f,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE;UACf,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE;UACf;UACA,CAAC,CAAC,CAAC,EAAE,CAAC,IAAI,EAAE,CAAC,CAAC,EAAE;UAChB,CAAC,CAAC,CAAC,EAAE,CAAC,IAAI,EAAE,CAAC,CAAC,EAAE;UAChB,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE;UAChB,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE;;UAEhB;UACA,CAAC,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE;UACf,CAAC,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE;UACf,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE;UACf,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE;UACf;UACA,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE;UAChB,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE;UAChB,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE;UAChB,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE;;UAEhB;UACA,CAAC,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE;UACf,CAAC,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE;UACf,CAAC,CAAC,EAAE,CAAC,IAAI,EAAE,CAAC,CAAC,EAAE;UACf,CAAC,CAAC,EAAE,CAAC,IAAI,EAAE,CAAC,CAAC,EAAE;UACf;UACA,CAAC,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE;UAChB,CAAC,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE;UAChB,CAAC,CAAC,EAAE,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC,EAAE;UAChB,CAAC,CAAC,EAAE,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC,CAAC;;UAEf;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;QACF,CAAC;QACD;MACF;EACJ;;EAEA,MAAMgkB,WAAW,GAAGP,IAAI,CAACQ,UAAU,CAAC7iB,GAAG,CAAC,CAAC1E,CAAC;EAC1C,OAAOA,CAAC,KAAK,QAAQ,GAAG2S,sBAAsB,CAAC3S,CAAC,CAAC,GAAG,OAAOA,CAAC,KAAK,SAAS,GAAGA,CAAC,GAAG,CAAC,GAAG,CAAC,GAAGA;EACzF,CAAC;;EAED;EACA,MAAMwnB,aAAa,GAAGA,CAAC,EAAE5kB,GAAG,EAAErB,IAAI,CAAC,CAAC,EAAE,GAAGgmB,UAAU,KAAK;IACtD,MAAMzpB,KAAK,GAAG8E,GAAG;IACjB,MAAM6kB,MAAM,GAAG1oB,OAAO,CAAC,GAAGuoB,WAAW,EAAE,GAAGC,UAAU,CAAC,GAAG,aAAa,GAAGzpB,KAAK;IAC7E,OAAOyD,IAAI,KAAK,KAAK,GAAGkmB,MAAM,GAAGxkB,IAAI,CAACe,KAAK,CAACyjB,MAAM,CAAC;EACrD,CAAC;;EAED;EACA;EACA,MAAMC,cAAc,GAAGA,CAAC,EAAE9kB,GAAG,EAAErB,IAAI,CAAC,CAAC,EAAE,GAAGgmB,UAAU,KAAK;IACvD,MAAMzpB,KAAK,GAAG8E,GAAG,IAAIrB,IAAI,KAAK,KAAK,GAAG,CAAC,GAAG,CAAC,CAAC;IAC5C,MAAMkmB,MAAM;IACZ1oB,OAAO,CAAC,GAAGuoB,WAAW,EAAE,GAAGC,UAAU,CAAC,GAAG,aAAa,GAAGzpB,KAAK,IAAIyD,IAAI,KAAK,KAAK,GAAG,CAAC,GAAG,CAAC,CAAC;IACzF,OAAOA,IAAI,KAAK,KAAK,GAAGkmB,MAAM,GAAGxkB,IAAI,CAACe,KAAK,CAACyjB,MAAM,CAAC;EACrD,CAAC;;EAED,MAAMsE,gBAAgB,GAAGA,CAAC9nB,GAAG,EAAEC,GAAG,EAAE,GAAGqjB,UAAU,KAAK;IACpD,MAAMzpB,KAAK,GAAGoG,GAAG,GAAGD,GAAG;IACvB,OAAOA,GAAG,GAAGhB,IAAI,CAACe,KAAK,CAACjF,OAAO,CAAC,GAAGuoB,WAAW,EAAE,GAAGC,UAAU,CAAC,GAAG,aAAa,GAAGzpB,KAAK,CAAC;EACzF,CAAC;;EAED;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,MAAM8pB,qBAAqB,GAAG,CAAC;EAC/B,MAAMC,aAAa;EACnB,CAACd,IAAI,CAACrgB,OAAO,IAAIqgB,IAAI,CAACrgB,OAAO,CAACE,SAAS,KAAK,SAAS,IAAI4M,eAAe,CAACuT,IAAI,CAACe,cAAc,CAAC;EAC7F,MAAMC,aAAa,GAAGvU,eAAe,CAACuT,IAAI,CAACe,cAAc,CAAC,GAAGF,qBAAqB,GAAG,CAAC,GAAG,CAAC;EAC1F,OAAO3W,MAAM,CAACvM,GAAG,CAAC,CAAC5E,CAAC,EAAEsD,CAAC,KAAK;IAC1B,MAAMoD,QAAQ,GAAGugB,IAAI,CAACvgB,QAAQ;IAC9B8hB,gBAAgB,CAACZ,cAAc,CAACX,IAAI,CAACvgB,QAAQ,EAAEpD,CAAC,CAAC,EAAE2jB,IAAI,CAACrgB,OAAO,EAAEI,YAAY,IAAI,SAAS,CAAC;IAC3F,CAAC;IACD,MAAMqS,eAAe,GAAGta,KAAK,CAAC2H,QAAQ,EAAE,EAAEvC,GAAG,EAAE,CAAC,EAAEC,GAAG,EAAEmC,aAAa,GAAG,CAAC,CAAC,CAAC,CAAC;IAC3E,MAAM2X,OAAO,GAAGze,cAAc,CAAC,IAAI,EAAEkC,IAAI,EAAEwB,IAAI,CAACC,IAAI,CAACiW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","ignoreList":[]}