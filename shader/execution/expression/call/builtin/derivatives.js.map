{"version":3,"file":"derivatives.js","names":["Type","toComparator","packScalarsToVector","runDerivativeTest","t","cases","builtin","non_uniform_discard","vectorize","type","f32","undefined","packed","resultType","dir","valueStride","wgslType","code","module","device","createShaderModule","pipeline","createRenderPipeline","layout","vertex","fragment","targets","format","writeMask","bufferSize","length","inputBuffer","createBufferTracked","size","usage","GPUBufferUsage","STORAGE","mappedAtCreation","outputBuffer","COPY_SRC","valuesData","Uint8Array","getMappedRange","i","inputs","input","copyTo","unmap","group","createBindGroup","entries","binding","resource","buffer","getBindGroupLayout","colorAttachment","createTextureTracked","width","height","GPUTextureUsage","RENDER_ATTACHMENT","encoder","globalThis","_TRAMPOLINE_","createCommandEncoder","pass","beginRenderPass","colorAttachments","view","createView","loadOp","storeOp","setPipeline","setBindGroup","quad","draw","end","queue","submit","finish","expectGPUBufferValuesPassCheck","outputData","c","d","index","result","read","cmp","expected","compare","matched","endsWith","c0","cmp0","Error","join","typedLength"],"sources":["../../../../../../../src/webgpu/shader/execution/expression/call/builtin/derivatives.ts"],"sourcesContent":["/**\n* AUTO-GENERATED - DO NOT EDIT. Source: https://github.com/gpuweb/cts\n**/import { Type } from '../../../../../util/conversion.js';\nimport { toComparator } from '../../expectation.js';\nimport { packScalarsToVector } from '../../expression.js';\n\n/**\n * Run a test for a derivative builtin function.\n * @param t the GPUTest\n * @param cases list of test cases to run\n * @param builtin the builtin function to test\n * @param non_uniform_discard if true, one of each pair of invocations will discard\n * @param vectorize if defined, the vector width to use (2, 3, or 4)\n */\nexport function runDerivativeTest(\nt,\ncases,\nbuiltin,\nnon_uniform_discard,\nvectorize)\n{\n  // If the 'vectorize' config option was provided, pack the cases into vectors.\n  let type = Type.f32;\n  if (vectorize !== undefined) {\n    const packed = packScalarsToVector([type, type], type, cases, vectorize);\n    cases = packed.cases;\n    type = packed.resultType;\n  }\n\n  ////////////////////////////////////////////////////////////////\n  // The two input values for a given case are distributed to two different invocations in a quad.\n  // We will populate a storage buffer with these input values laid out sequentially:\n  // [ case_0_input_1, case_0_input_0, case_1_input_1, case_1_input_0, ...]\n  //\n  // The render pipeline will be launched several times over a viewport size of (2, 2). Each draw\n  // call will execute a single quad (four fragment invocation), which will exercise two test cases.\n  // Each of these draw calls will use a different instance index, which is forwarded to the\n  // fragment shader. Each invocation will determine its index into the storage buffer using its\n  // fragment position and the instance index for that draw call.\n  //\n  // Consider two draw calls that test 4 cases (c_0, c_1, c_2, c_3).\n  //\n  // For derivatives along the 'x' direction, the mapping from fragment position to case input is:\n  // Quad 0: | c_0_i_1 | c_0_i_0 |     Quad 1: | c_2_i_1 | c_2_i_0 |\n  //         | c_1_i_1 | c_1_i_0 |             | c_3_i_1 | c_3_i_0 |\n  //\n  // For derivatives along the 'y' direction, the mapping from fragment position to case input is:\n  // Quad 0: | c_0_i_1 | c_1_i_1 |     Quad 1: | c_2_i_1 | c_3_i_1 |\n  //         | c_0_i_0 | c_1_i_0 |             | c_2_i_0 | c_3_i_0 |\n  //\n  ////////////////////////////////////////////////////////////////\n\n  // Determine the direction of the derivative ('x' or 'y') from the builtin name.\n  const dir = builtin[3];\n\n  // Determine the WGSL type to use in the shader, and the stride in bytes between values.\n  let valueStride = 4;\n  let wgslType = 'f32';\n  if (vectorize) {\n    wgslType = `vec${vectorize}f`;\n    valueStride = vectorize * 4;\n    if (vectorize === 3) {\n      valueStride = 16;\n    }\n  }\n\n  // Define a vertex shader that draws a triangle over the full viewport, and a fragment shader that\n  // calls the derivative builtin with a value loaded from that fragment's index into the storage\n  // buffer (determined using the quad index and fragment position, as described above).\n  const code = `\nstruct CaseInfo {\n  @builtin(position) position: vec4f,\n  @location(0) @interpolate(flat, either) quad_idx: u32,\n}\n\n@vertex\nfn vert(@builtin(vertex_index) vertex_idx: u32,\n        @builtin(instance_index) instance_idx: u32) -> CaseInfo {\n  const kVertices = array(\n    vec2f(-2, -2),\n    vec2f( 2, -2),\n    vec2f( 0,  2),\n  );\n  return CaseInfo(vec4(kVertices[vertex_idx], 0, 1), instance_idx);\n}\n\n@group(0) @binding(0) var<storage, read> inputs : array<${wgslType}>;\n@group(0) @binding(1) var<storage, read_write> outputs : array<${wgslType}>;\n\n@fragment\nfn frag(info : CaseInfo) {\n  let case_idx = u32(info.position.${dir === 'x' ? 'y' : 'x'});\n  let inv_idx = u32(info.position.${dir});\n  let index = info.quad_idx*4 + case_idx*2 + inv_idx;\n  let input = inputs[index];\n  ${non_uniform_discard ? 'if inv_idx == 0 { discard; }' : ''}\n  outputs[index] = ${builtin}(input);\n}\n`;\n\n  // Create the render pipeline.\n  const module = t.device.createShaderModule({ code });\n  const pipeline = t.device.createRenderPipeline({\n    layout: 'auto',\n    vertex: { module },\n    fragment: { module, targets: [{ format: 'rgba8unorm', writeMask: 0 }] }\n  });\n\n  // Create storage buffers to hold the inputs and outputs.\n  const bufferSize = cases.length * 2 * valueStride;\n  const inputBuffer = t.createBufferTracked({\n    size: bufferSize,\n    usage: GPUBufferUsage.STORAGE,\n    mappedAtCreation: true\n  });\n  const outputBuffer = t.createBufferTracked({\n    size: bufferSize,\n    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC\n  });\n\n  // Populate the input storage buffer with case input values.\n  const valuesData = new Uint8Array(inputBuffer.getMappedRange());\n  for (let i = 0; i < cases.length; i++) {\n    const inputs = cases[i].input;\n    inputs[0].copyTo(valuesData, (i * 2 + 1) * valueStride);\n    inputs[1].copyTo(valuesData, i * 2 * valueStride);\n  }\n  inputBuffer.unmap();\n\n  // Create a bind group for the storage buffers.\n  const group = t.device.createBindGroup({\n    entries: [\n    { binding: 0, resource: { buffer: inputBuffer } },\n    { binding: 1, resource: { buffer: outputBuffer } }],\n\n    layout: pipeline.getBindGroupLayout(0)\n  });\n\n  // Create a texture to use as a color attachment.\n  // We only need this for launching the desired number of fragment invocations.\n  const colorAttachment = t.createTextureTracked({\n    size: { width: 2, height: 2 },\n    format: 'rgba8unorm',\n    usage: GPUTextureUsage.RENDER_ATTACHMENT\n  });\n\n  // Submit the render pass to the device.\n  const encoder = globalThis._TRAMPOLINE_(\"createCommandEncoder\", t.device, t.device.createCommandEncoder, [], () => t.device.createCommandEncoder());\n  const pass = encoder.beginRenderPass({\n    colorAttachments: [\n    {\n      view: colorAttachment.createView(),\n      loadOp: 'clear',\n      storeOp: 'discard'\n    }]\n\n  });\n  pass.setPipeline(pipeline);\n  pass.setBindGroup(0, group);\n  for (let quad = 0; quad < cases.length / 2; quad++) {\n    pass.draw(3, 1, undefined, quad);\n  }\n  pass.end();\n  globalThis._TRAMPOLINE_(\"submit\", t, t.queue.submit, [[encoder.finish()]], () => t.queue.submit([encoder.finish()]));\n\n  // Check the outputs match the expected results.\n  t.expectGPUBufferValuesPassCheck(\n    outputBuffer,\n    (outputData) => {\n      for (let i = 0; i < cases.length; i++) {\n        const c = cases[i];\n\n        // Both invocations involved in the derivative should get the same result.\n        for (let d = 0; d < 2; d++) {\n          if (non_uniform_discard && d === 0) {\n            continue;\n          }\n\n          const index = (i * 2 + d) * valueStride;\n          const result = type.read(outputData, index);\n          const cmp = toComparator(c.expected).compare(result);\n          if (!cmp.matched) {\n            // If this is a coarse derivative, the implementation is also allowed to calculate only\n            // one of the two derivatives and return that result to all of the invocations.\n            if (!builtin.endsWith('Fine')) {\n              const c0 = cases[i % 2 === 0 ? i + 1 : i - 1];\n              const cmp0 = toComparator(c0.expected).compare(result);\n              if (!cmp0.matched) {\n                return new Error(`\n  1st pair: (${c.input.join(', ')})\n  expected: ${cmp.expected}\n\n  2nd pair: (${c0.input.join(', ')})\n  expected: ${cmp0.expected}\n\n  returned: ${result}`);\n              }\n            } else {\n              return new Error(`\n    inputs: (${c.input.join(', ')})\n  expected: ${cmp.expected}\n\n  returned: ${result}`);\n            }\n          }\n        }\n      }\n      return undefined;\n    },\n    {\n      type: Uint8Array,\n      typedLength: bufferSize\n    }\n  );\n}"],"mappings":"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","ignoreList":[]}