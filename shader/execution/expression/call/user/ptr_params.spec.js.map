{"version":3,"file":"ptr_params.spec.js","names":["description","makeTestGroup","GPUTest","g","wgslTypeDecl","kind","valuesForType","Uint32Array","Float32Array","run","t","wgsl","inputUsage","input","expected","pipeline","device","createComputePipeline","layout","compute","module","createShaderModule","code","entryPoint","inputBuffer","makeBufferWithContents","GPUBufferUsage","UNIFORM","STORAGE","outputBuffer","createBufferTracked","size","buffer","byteLength","usage","COPY_SRC","bindGroup","createBindGroup","getBindGroupLayout","entries","binding","resource","encoder","globalThis","_TRAMPOLINE_","createCommandEncoder","pass","beginComputePass","setPipeline","setBindGroup","dispatchWorkgroups","end","queue","submit","finish","expectGPUBufferValuesEqual","test","desc","params","u","combine","fn","address_space","skipIfLanguageFeatureNotSupported","main","function","private","workgroup","storage","uniform","call_chain","i","call_indirection","inputVar","type","values","ptr","ty"],"sources":["../../../../../../../src/webgpu/shader/execution/expression/call/user/ptr_params.spec.ts"],"sourcesContent":["/**\n* AUTO-GENERATED - DO NOT EDIT. Source: https://github.com/gpuweb/cts\n**/export const description = `\nUser function call tests for pointer parameters.\n`;import { makeTestGroup } from '../../../../../../common/framework/test_group.js';\nimport { GPUTest } from '../../../../../gpu_test.js';\n\nexport const g = makeTestGroup(GPUTest);\n\nfunction wgslTypeDecl(kind) {\n  switch (kind) {\n    case 'vec4i':\n      return `\nalias T = vec4i;\n`;\n    case 'array':\n      return `\nalias T = array<vec4f, 3>;\n`;\n    case 'struct':\n      return `\nstruct S {\na : i32,\nb : u32,\nc : i32,\nd : u32,\n}\nalias T = S;\n`;\n  }\n}\n\nfunction valuesForType(kind) {\n  switch (kind) {\n    case 'vec4i':\n      return new Uint32Array([1, 2, 3, 4]);\n    case 'array':\n      return new Float32Array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]);\n    case 'struct':\n      return new Uint32Array([1, 2, 3, 4]);\n  }\n}\n\nfunction run(\nt,\nwgsl,\ninputUsage,\ninput,\nexpected)\n{\n  const pipeline = t.device.createComputePipeline({\n    layout: 'auto',\n    compute: {\n      module: t.device.createShaderModule({ code: wgsl }),\n      entryPoint: 'main'\n    }\n  });\n\n  const inputBuffer = t.makeBufferWithContents(\n    input,\n    inputUsage === 'uniform' ? GPUBufferUsage.UNIFORM : GPUBufferUsage.STORAGE\n  );\n\n  const outputBuffer = t.createBufferTracked({\n    size: expected.buffer.byteLength,\n    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC\n  });\n\n  const bindGroup = t.device.createBindGroup({\n    layout: pipeline.getBindGroupLayout(0),\n    entries: [\n    { binding: 0, resource: { buffer: inputBuffer } },\n    { binding: 1, resource: { buffer: outputBuffer } }]\n\n  });\n\n  const encoder = globalThis._TRAMPOLINE_(\"createCommandEncoder\", t.device, t.device.createCommandEncoder, [], () => t.device.createCommandEncoder());\n  const pass = encoder.beginComputePass();\n  pass.setPipeline(pipeline);\n  pass.setBindGroup(0, bindGroup);\n  pass.dispatchWorkgroups(1);\n  pass.end();\n  globalThis._TRAMPOLINE_(\"submit\", t, t.queue.submit, [[encoder.finish()]], () => t.queue.submit([encoder.finish()]));\n\n  t.expectGPUBufferValuesEqual(outputBuffer, expected);\n}\n\ng.test('read_full_object').\ndesc('Test a pointer parameter can be read by a callee function').\nparams((u) =>\nu.\ncombine('address_space', ['function', 'private', 'workgroup', 'storage', 'uniform']).\ncombine('call_indirection', [0, 1, 2]).\ncombine('type', ['vec4i', 'array', 'struct'])\n).\nfn((t) => {\n  switch (t.params.address_space) {\n    case 'workgroup':\n    case 'storage':\n    case 'uniform':\n      t.skipIfLanguageFeatureNotSupported('unrestricted_pointer_parameters');\n  }\n\n  const main = {\n    function: `\n@compute @workgroup_size(1)\nfn main() {\n  var F : T = input;\n  f0(&F);\n}\n`,\n    private: `\nvar<private> P : T;\n@compute @workgroup_size(1)\nfn main() {\n  P = input;\n  f0(&P);\n}\n`,\n    workgroup: `\nvar<workgroup> W : T;\n@compute @workgroup_size(1)\nfn main() {\n  W = input;\n  f0(&W);\n}\n`,\n    storage: `\n@compute @workgroup_size(1)\nfn main() {\n  f0(&input);\n}\n`,\n    uniform: `\n@compute @workgroup_size(1)\nfn main() {\n  f0(&input);\n}\n`\n  }[t.params.address_space];\n\n  let call_chain = '';\n  for (let i = 0; i < t.params.call_indirection; i++) {\n    call_chain += `\nfn f${i}(p : ptr<${t.params.address_space}, T>) {\n  f${i + 1}(p);\n}\n`;\n  }\n\n  const inputVar =\n  t.params.address_space === 'uniform' ?\n  `@binding(0) @group(0) var<uniform> input : T;` :\n  `@binding(0) @group(0) var<storage, read> input : T;`;\n\n  const wgsl = `\n${wgslTypeDecl(t.params.type)}\n\n${inputVar}\n\n@binding(1) @group(0) var<storage, read_write> output : T;\n\nfn f${t.params.call_indirection}(p : ptr<${t.params.address_space}, T>) {\n    output = *p;\n}\n\n${call_chain}\n\n${main}\n`;\n\n  const values = valuesForType(t.params.type);\n\n  run(t, wgsl, t.params.address_space === 'uniform' ? 'uniform' : 'storage', values, values);\n});\n\ng.test('read_ptr_to_member').\ndesc('Test a pointer parameter to a member of a structure can be read by a callee function').\nparams((u) =>\nu.combine('address_space', ['function', 'private', 'workgroup', 'storage', 'uniform'])\n).\nfn((t) => {\n  t.skipIfLanguageFeatureNotSupported('unrestricted_pointer_parameters');\n\n  const main = {\n    function: `\n@compute @workgroup_size(1)\nfn main() {\n  var v : S = input;\n  output = f0(&v);\n}\n`,\n    private: `\nvar<private> P : S;\n@compute @workgroup_size(1)\nfn main() {\n  P = input;\n  output = f0(&P);\n}\n`,\n    workgroup: `\nvar<workgroup> W : S;\n@compute @workgroup_size(1)\nfn main() {\n  W = input;\n  output = f0(&W);\n}\n`,\n    storage: `\n@compute @workgroup_size(1)\nfn main() {\n  output = f0(&input);\n}\n`,\n    uniform: `\n@compute @workgroup_size(1)\nfn main() {\n  output = f0(&input);\n}\n`\n  }[t.params.address_space];\n\n  const inputVar =\n  t.params.address_space === 'uniform' ?\n  `@binding(0) @group(0) var<uniform> input : S;` :\n  `@binding(0) @group(0) var<storage, read> input : S;`;\n\n  const wgsl = `\nstruct S {\n  a : vec4i,\n  b : T,\n  c : vec4i,\n}\n\nstruct T {\n  a : vec4i,\n  b : vec4i,\n}\n\n\n${inputVar}\n@binding(1) @group(0) var<storage, read_write> output : T;\n\nfn f2(p : ptr<${t.params.address_space}, T>) -> T {\n  return *p;\n}\n\nfn f1(p : ptr<${t.params.address_space}, S>) -> T {\n  return f2(&(*p).b);\n}\n\nfn f0(p : ptr<${t.params.address_space}, S>) -> T {\n  return f1(p);\n}\n\n${main}\n`;\n\n\n  const input = new Uint32Array([\n  /* S.a */1, 2, 3, 4,\n  /* S.b.a */5, 6, 7, 8,\n  /* S.b.b */9, 10, 11, 12,\n  /* S.c */13, 14, 15, 16]\n  );\n\n\n  const expected = new Uint32Array([\n  /* S.b.a */5, 6, 7, 8,\n  /* S.b.b */9, 10, 11, 12]\n  );\n\n  run(t, wgsl, t.params.address_space === 'uniform' ? 'uniform' : 'storage', input, expected);\n});\n\ng.test('read_ptr_to_element').\ndesc('Test a pointer parameter to an element of an array can be read by a callee function').\nparams((u) =>\nu.combine('address_space', ['function', 'private', 'workgroup', 'storage', 'uniform'])\n).\nfn((t) => {\n  t.skipIfLanguageFeatureNotSupported('unrestricted_pointer_parameters');\n\n  const main = {\n    function: `\n@compute @workgroup_size(1)\nfn main() {\n  var v : T = input;\n  output = f0(&v);\n}\n`,\n    private: `\nvar<private> P : T;\n@compute @workgroup_size(1)\nfn main() {\n  P = input;\n  output = f0(&P);\n}\n`,\n    workgroup: `\nvar<workgroup> W : T;\n@compute @workgroup_size(1)\nfn main() {\n  W = input;\n  output = f0(&W);\n}\n`,\n    storage: `\n@compute @workgroup_size(1)\nfn main() {\n  output = f0(&input);\n}\n`,\n    uniform: `\n@compute @workgroup_size(1)\nfn main() {\n  output = f0(&input);\n}\n`\n  }[t.params.address_space];\n\n  const inputVar =\n  t.params.address_space === 'uniform' ?\n  `@binding(0) @group(0) var<uniform> input : T;` :\n  `@binding(0) @group(0) var<storage, read> input : T;`;\n\n  const wgsl = `\nalias T3 = vec4i;\nalias T2 = array<T3, 2>;\nalias T1 = array<T2, 3>;\nalias T = array<T1, 2>;\n\n${inputVar}\n@binding(1) @group(0) var<storage, read_write> output : T3;\n\nfn f2(p : ptr<${t.params.address_space}, T2>) -> T3 {\n  return (*p)[1];\n}\n\nfn f1(p : ptr<${t.params.address_space}, T1>) -> T3 {\n  return f2(&(*p)[0]) + f2(&(*p)[2]);\n}\n\nfn f0(p : ptr<${t.params.address_space}, T>) -> T3 {\n  return f1(&(*p)[0]);\n}\n\n${main}\n`;\n\n\n  const input = new Uint32Array([\n  /* [0][0][0] */1, 2, 3, 4,\n  /* [0][0][1] */5, 6, 7, 8,\n  /* [0][1][0] */9, 10, 11, 12,\n  /* [0][1][1] */13, 14, 15, 16,\n  /* [0][2][0] */17, 18, 19, 20,\n  /* [0][2][1] */21, 22, 23, 24,\n  /* [1][0][0] */25, 26, 27, 28,\n  /* [1][0][1] */29, 30, 31, 32,\n  /* [1][1][0] */33, 34, 35, 36,\n  /* [1][1][1] */37, 38, 39, 40,\n  /* [1][2][0] */41, 42, 43, 44,\n  /* [1][2][1] */45, 46, 47, 48]\n  );\n  const expected = new Uint32Array([/* [0][0][1] + [0][2][1] */5 + 21, 6 + 22, 7 + 23, 8 + 24]);\n\n  run(t, wgsl, t.params.address_space === 'uniform' ? 'uniform' : 'storage', input, expected);\n});\n\ng.test('write_full_object').\ndesc('Test a pointer parameter can be written to by a callee function').\nparams((u) =>\nu.\ncombine('address_space', ['function', 'private', 'workgroup', 'storage']).\ncombine('call_indirection', [0, 1, 2]).\ncombine('type', ['vec4i', 'array', 'struct'])\n).\nfn((t) => {\n  switch (t.params.address_space) {\n    case 'workgroup':\n    case 'storage':\n      t.skipIfLanguageFeatureNotSupported('unrestricted_pointer_parameters');\n  }\n\n  const ptr =\n  t.params.address_space === 'storage' ?\n  `ptr<storage, T, read_write>` :\n  `ptr<${t.params.address_space}, T>`;\n\n  const main = {\n    function: `\n@compute @workgroup_size(1)\nfn main() {\n  var F : T;\n  f0(&F);\n  output = F;\n}\n`,\n    private: `\nvar<private> P : T;\n@compute @workgroup_size(1)\nfn main() {\n  f0(&P);\n  output = P;\n}\n`,\n    workgroup: `\nvar<workgroup> W : T;\n@compute @workgroup_size(1)\nfn main() {\n  f0(&W);\n  output = W;\n}\n`,\n    storage: `\n@compute @workgroup_size(1)\nfn main() {\n  f0(&output);\n}\n`\n  }[t.params.address_space];\n\n  let call_chain = '';\n  for (let i = 0; i < t.params.call_indirection; i++) {\n    call_chain += `\nfn f${i}(p : ${ptr}) {\n  f${i + 1}(p);\n}\n`;\n  }\n\n  const wgsl = `\n${wgslTypeDecl(t.params.type)}\n\n@binding(0) @group(0) var<uniform> input : T;\n@binding(1) @group(0) var<storage, read_write> output : T;\n\nfn f${t.params.call_indirection}(p : ${ptr}) {\n  *p = input;\n}\n\n${call_chain}\n\n${main}\n`;\n\n  const values = valuesForType(t.params.type);\n\n  run(t, wgsl, 'uniform', values, values);\n});\n\ng.test('write_ptr_to_member').\ndesc(\n  'Test a pointer parameter to a member of a structure can be written to by a callee function'\n).\nparams((u) => u.combine('address_space', ['function', 'private', 'workgroup', 'storage'])).\nfn((t) => {\n  t.skipIfLanguageFeatureNotSupported('unrestricted_pointer_parameters');\n\n  const main = {\n    function: `\n@compute @workgroup_size(1)\nfn main() {\n  var v : S;\n  f0(&v);\n  output = v;\n}\n`,\n    private: `\nvar<private> P : S;\n@compute @workgroup_size(1)\nfn main() {\n  f0(&P);\n  output = P;\n}\n`,\n    workgroup: `\nvar<workgroup> W : S;\n@compute @workgroup_size(1)\nfn main() {\n  f0(&W);\n  output = W;\n}\n`,\n    storage: `\n@compute @workgroup_size(1)\nfn main() {\n  f1(&output);\n}\n`\n  }[t.params.address_space];\n\n  const ptr = (ty) =>\n  t.params.address_space === 'storage' ?\n  `ptr<storage, ${ty}, read_write>` :\n  `ptr<${t.params.address_space}, ${ty}>`;\n\n  const wgsl = `\nstruct S {\n  a : vec4i,\n  b : T,\n  c : vec4i,\n}\n\nstruct T {\n  a : vec4i,\n  b : vec4i,\n}\n\n\n@binding(0) @group(0) var<storage> input : T;\n@binding(1) @group(0) var<storage, read_write> output : S;\n\nfn f2(p : ${ptr('T')}) {\n  *p = input;\n}\n\nfn f1(p : ${ptr('S')}) {\n  f2(&(*p).b);\n}\n\nfn f0(p : ${ptr('S')}) {\n  f1(p);\n}\n\n${main}\n`;\n\n\n  const input = new Uint32Array([\n  /* S.b.a */5, 6, 7, 8,\n  /* S.b.b */9, 10, 11, 12]\n  );\n\n\n  const expected = new Uint32Array([\n  /* S.a   */0, 0, 0, 0,\n  /* S.b.a */5, 6, 7, 8,\n  /* S.b.b */9, 10, 11, 12,\n  /* S.c   */0, 0, 0, 0]\n  );\n\n  run(t, wgsl, 'storage', input, expected);\n});\n\ng.test('write_ptr_to_element').\ndesc('Test a pointer parameter to an element of an array can be written to by a callee function').\nparams((u) => u.combine('address_space', ['function', 'private', 'workgroup', 'storage'])).\nfn((t) => {\n  t.skipIfLanguageFeatureNotSupported('unrestricted_pointer_parameters');\n\n  const main = {\n    function: `\n@compute @workgroup_size(1)\nfn main() {\n  var v : T;\n  f0(&v);\n  output = v;\n}\n`,\n    private: `\nvar<private> P : T;\n@compute @workgroup_size(1)\nfn main() {\n  f0(&P);\n  output = P;\n}\n`,\n    workgroup: `\nvar<workgroup> W : T;\n@compute @workgroup_size(1)\nfn main() {\n  f0(&W);\n  output = W;\n}\n`,\n    storage: `\n@compute @workgroup_size(1)\nfn main() {\n  f0(&output);\n}\n`\n  }[t.params.address_space];\n\n  const ptr = (ty) =>\n  t.params.address_space === 'storage' ?\n  `ptr<storage, ${ty}, read_write>` :\n  `ptr<${t.params.address_space}, ${ty}>`;\n\n  const wgsl = `\nalias T3 = vec4i;\nalias T2 = array<T3, 2>;\nalias T1 = array<T2, 3>;\nalias T = array<T1, 2>;\n\n@binding(0) @group(0) var<storage, read> input : T3;\n@binding(1) @group(0) var<storage, read_write> output : T;\n\nfn f2(p : ${ptr('T2')}) {\n  (*p)[1] = input;\n}\n\nfn f1(p : ${ptr('T1')}) {\n  f2(&(*p)[0]);\n  f2(&(*p)[2]);\n}\n\nfn f0(p : ${ptr('T')}) {\n  f1(&(*p)[0]);\n}\n\n${main}\n`;\n\n  const input = new Uint32Array([1, 2, 3, 4]);\n\n\n  const expected = new Uint32Array([\n  /* [0][0][0] */0, 0, 0, 0,\n  /* [0][0][1] */1, 2, 3, 4,\n  /* [0][1][0] */0, 0, 0, 0,\n  /* [0][1][1] */0, 0, 0, 0,\n  /* [0][2][0] */0, 0, 0, 0,\n  /* [0][2][1] */1, 2, 3, 4,\n  /* [1][0][0] */0, 0, 0, 0,\n  /* [1][0][1] */0, 0, 0, 0,\n  /* [1][1][0] */0, 0, 0, 0,\n  /* [1][1][1] */0, 0, 0, 0,\n  /* [1][2][0] */0, 0, 0, 0,\n  /* [1][2][1] */0, 0, 0, 0]\n  );\n\n  run(t, wgsl, 'storage', input, expected);\n});\n\ng.test('atomic_ptr_to_element').\ndesc(\n  'Test a pointer parameter to an atomic<i32> of an array can be read from and written to by a callee function'\n).\nparams((u) => u.combine('address_space', ['workgroup', 'storage'])).\nfn((t) => {\n  t.skipIfLanguageFeatureNotSupported('unrestricted_pointer_parameters');\n\n  const main = {\n    workgroup: `\nvar<workgroup> W_input : T;\nvar<workgroup> W_output : T;\n@compute @workgroup_size(1)\nfn main() {\n  // Copy input -> W_input\n  for (var i = 0; i < 2; i++) {\n    for (var j = 0; j < 3; j++) {\n      for (var k = 0; k < 2; k++) {\n        atomicStore(&W_input[k][j][i], atomicLoad(&input[k][j][i]));\n      }\n    }\n  }\n\n  f0(&W_input, &W_output);\n\n  // Copy W_output -> output\n  for (var i = 0; i < 2; i++) {\n    for (var j = 0; j < 3; j++) {\n      for (var k = 0; k < 2; k++) {\n        atomicStore(&output[k][j][i], atomicLoad(&W_output[k][j][i]));\n      }\n    }\n  }\n}\n`,\n    storage: `\n@compute @workgroup_size(1)\nfn main() {\n  f0(&input, &output);\n}\n`\n  }[t.params.address_space];\n\n  const ptr = (ty) =>\n  t.params.address_space === 'storage' ?\n  `ptr<storage, ${ty}, read_write>` :\n  `ptr<${t.params.address_space}, ${ty}>`;\n\n  const wgsl = `\nalias T3 = atomic<i32>;\nalias T2 = array<T3, 2>;\nalias T1 = array<T2, 3>;\nalias T = array<T1, 2>;\n\n@binding(0) @group(0) var<storage, read_write> input : T;\n@binding(1) @group(0) var<storage, read_write> output : T;\n\nfn f2(in : ${ptr('T2')}, out : ${ptr('T2')}) {\n  let v = atomicLoad(&(*in)[0]);\n  atomicStore(&(*out)[1], v);\n}\n\nfn f1(in : ${ptr('T1')}, out : ${ptr('T1')}) {\n  f2(&(*in)[0], &(*out)[1]);\n  f2(&(*in)[2], &(*out)[0]);\n}\n\nfn f0(in : ${ptr('T')}, out : ${ptr('T')}) {\n  f1(&(*in)[1], &(*out)[0]);\n}\n\n${main}\n`;\n\n\n  const input = new Uint32Array([\n  /* [0][0][0] */1,\n  /* [0][0][1] */2,\n  /* [0][1][0] */3,\n  /* [0][1][1] */4,\n  /* [0][2][0] */5,\n  /* [0][2][1] */6,\n  /* [1][0][0] */7, // -> [0][1][1]\n  /* [1][0][1] */8,\n  /* [1][1][0] */9,\n  /* [1][1][1] */10,\n  /* [1][2][0] */11, // -> [0][0][1]\n  /* [1][2][1] */12]\n  );\n\n\n  const expected = new Uint32Array([\n  /* [0][0][0] */0,\n  /* [0][0][1] */11,\n  /* [0][1][0] */0,\n  /* [0][1][1] */7,\n  /* [0][2][0] */0,\n  /* [0][2][1] */0,\n  /* [1][0][0] */0,\n  /* [1][0][1] */0,\n  /* [1][1][0] */0,\n  /* [1][1][1] */0,\n  /* [1][2][0] */0,\n  /* [1][2][1] */0]\n  );\n\n  run(t, wgsl, 'storage', input, expected);\n});\n\ng.test('array_length').\ndesc(\n  'Test a pointer parameter to a runtime sized array can be used by arrayLength() in a callee function'\n).\nfn((t) => {\n  t.skipIfLanguageFeatureNotSupported('unrestricted_pointer_parameters');\n\n  const wgsl = `\n@binding(0) @group(0) var<storage, read> arr : array<u32>;\n@binding(1) @group(0) var<storage, read_write> output : u32;\n\nfn f2(p : ptr<storage, array<u32>, read>) -> u32 {\n  return arrayLength(p);\n}\n\nfn f1(p : ptr<storage, array<u32>, read>) -> u32 {\n  return f2(p);\n}\n\nfn f0(p : ptr<storage, array<u32>, read>) -> u32 {\n  return f1(p);\n}\n\n@compute @workgroup_size(1)\nfn main() {\n  output = f0(&arr);\n}\n`;\n\n  const input = new Uint32Array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]);\n  const expected = new Uint32Array([12]);\n\n  run(t, wgsl, 'storage', input, expected);\n});\n\ng.test('mixed_ptr_parameters').\ndesc('Test that functions can accept multiple, mixed pointer parameters').\nfn((t) => {\n  t.skipIfLanguageFeatureNotSupported('unrestricted_pointer_parameters');\n\n  const wgsl = `\n@binding(0) @group(0) var<uniform> input : array<vec4i, 4>;\n@binding(1) @group(0) var<storage, read_write> output : array<vec4i, 4>;\n\nfn sum(f : ptr<function, i32>,\n       w : ptr<workgroup, atomic<i32>>,\n       p : ptr<private, i32>,\n       u : ptr<uniform, vec4i>) -> vec4i {\n\n  return vec4(*f + atomicLoad(w) + *p) + *u;\n}\n\nstruct S {\n  i : i32,\n}\n\nvar<private> P0 = S(0);\nvar<private> P1 = S(10);\nvar<private> P2 = 20;\nvar<private> P3 = 30;\n\nstruct T {\n  i : atomic<i32>,\n}\n\nvar<workgroup> W0 : T;\nvar<workgroup> W1 : atomic<i32>;\nvar<workgroup> W2 : T;\nvar<workgroup> W3 : atomic<i32>;\n\n@compute @workgroup_size(1)\nfn main() {\n  atomicStore(&W0.i, 0);\n  atomicStore(&W1,   100);\n  atomicStore(&W2.i, 200);\n  atomicStore(&W3,   300);\n\n  var F = array(0, 1000, 2000, 3000);\n\n  output[0] = sum(&F[2], &W3,   &P1.i, &input[0]); // vec4(2310) + vec4(1, 2, 3, 4)\n  output[1] = sum(&F[1], &W2.i, &P0.i, &input[1]); // vec4(1200) + vec4(4, 3, 2, 1)\n  output[2] = sum(&F[3], &W0.i, &P3,   &input[2]); // vec4(3030) + vec4(2, 4, 1, 3)\n  output[3] = sum(&F[2], &W1,   &P2,   &input[3]); // vec4(2120) + vec4(4, 1, 2, 3)\n}\n`;\n\n\n  const input = new Uint32Array([\n  /* [0] */1, 2, 3, 4,\n  /* [1] */4, 3, 2, 1,\n  /* [2] */2, 4, 1, 3,\n  /* [3] */4, 1, 2, 3]\n  );\n\n\n  const expected = new Uint32Array([\n  /* [0] */2311, 2312, 2313, 2314,\n  /* [1] */1204, 1203, 1202, 1201,\n  /* [2] */3032, 3034, 3031, 3033,\n  /* [3] */2124, 2121, 2122, 2123]\n  );\n\n  run(t, wgsl, 'uniform', input, expected);\n});"],"mappings":"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","ignoreList":[]}