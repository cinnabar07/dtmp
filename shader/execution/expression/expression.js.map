{"version":3,"file":"expression.js","names":["globalTestConfig","assert","objectEquals","unreachable","kValue","MatrixType","ScalarType","Type","VectorType","VectorValue","isAbstractType","scalarTypeOf","ArrayType","elementTypeOf","align","toComparator","allInputSources","onlyConstInputSource","allButConstInputSource","sizeAndAlignmentOf","ty","source","kind","size","alignment","out","elementType","n","width","rows","cols","count","strideOf","sizeAndAlign","structLayout","members","callback","offset","i","length","member","index","type","Math","max","stride","structStride","wgslMembers","memberName","lines","layout","m","push","padding","join","storageType","u32","vec","array","fromStorage","expr","helpers","bool","conv","uniqueID","inTy","wgsl","toStorage","outTy","getOrCreate","map","key","create","existing","get","undefined","value","set","run","t","shaderBuilder","parameterTypes","resultType","cfg","inputSource","cases","batch_size","vectorize","packed","packScalarsToVector","casesPerBatch","floor","min","device","limits","maxUniformBufferBindingSize","maxStorageBufferBindingSize","pipelineCache","Map","maxBatchesInFlight","batchesInFlight","resolvePromiseBlockingBatch","batchFinishedCallback","processBatch","batchCases","shaderBuilderParams","constEvaluationMode","checkBatch","submitBatch","queue","onSubmittedWorkDone","pendingBatches","slice","Promise","resolve","catch","err","GPUPipelineError","fail","reason","message","finally","all","outputStride","outputBufferSize","outputBuffer","createBufferTracked","usage","GPUBufferUsage","COPY_SRC","COPY_DST","STORAGE","pipeline","group","buildPipeline","encoder","globalThis","_TRAMPOLINE_","createCommandEncoder","pass","beginComputePass","setPipeline","setBindGroup","dispatchWorkgroups","end","testHeartbeatCallback","submit","finish","checkExpectation","outputData","outputs","Array","read","errs","caseIdx","c","got","cmp","expected","compare","matched","input","Error","expectGPUBufferValuesPassCheck","Uint8Array","typedLength","v","fn","wgslOutputs","output_struct","dim","wgslValuesArray","expressionBuilder","wgslInputVar","wgslHeader","usedF16","some","header","basicExpressionShaderBody","params","nextUniqueIDSuffix","convHelpers","unrollConstEvalLoops","body","valuesArray","_","paramExpr","basicExpressionBuilder","basicExpressionWithPredeclarationBuilder","predeclaration","compoundAssignmentBuilder","op","lhsType","rhsType","values","operation","abstractFloatSnippet","case_idx","accessor","f64","positive","subnormal","negative","abstractFloatCaseBody","keys","idx","results","r","abstractFloatShaderBuilder","abstractIntSnippet","abstractIntCaseBody","abstractIntShaderBuilder","forEach","inputTypes","input_str","param_str","module","createShaderModule","code","createComputePipelineAsync","compute","entryPoint","createBindGroup","getBindGroupLayout","entries","binding","resource","buffer","caseStride","inputSize","inputData","arg","copyTo","createComputePipeline","inputBuffer","makeBufferWithContents","UNIFORM","vectorWidth","packedCases","packedParameterTypes","p","packedResultType","clampCaseIdx","packedInputs","paramIdx","inputElements","cmp_impls","comparators","gElements","eElements","d","elements"],"sources":["../../../../../src/webgpu/shader/execution/expression/expression.ts"],"sourcesContent":["/**\n* AUTO-GENERATED - DO NOT EDIT. Source: https://github.com/gpuweb/cts\n**/import { globalTestConfig } from '../../../../common/framework/test_config.js';import { assert, objectEquals, unreachable } from '../../../../common/util/util.js';\n\nimport { kValue } from '../../../util/constants.js';\nimport {\n  MatrixType,\n\n  ScalarType,\n  Type,\n  VectorType,\n\n  VectorValue,\n  isAbstractType,\n  scalarTypeOf,\n  ArrayType,\n  elementTypeOf } from\n'../../../util/conversion.js';\nimport { align } from '../../../util/math.js';\n\n\nimport { toComparator } from './expectation.js';\n\n/** The input value source */\n\n\n\n\n// Read-write storage buffer\n\n/** All possible input sources */\nexport const allInputSources = ['const', 'uniform', 'storage_r', 'storage_rw'];\n\n/** Just constant input source */\nexport const onlyConstInputSource = ['const'];\n\n/** All input sources except const */\nexport const allButConstInputSource = ['uniform', 'storage_r', 'storage_rw'];\n\n/**\n * An enumerator of methods the const-expression is evaluated and assigned to the output.\n * direct:   Each case has a separate assignment statement to the output buffer, where the RHS of\n *           the assignment holds the case's evaluated expression.\n * unrolled: The case expressions are all evaluated and stored in a module-scope 'const' array.\n *           This array is indexed and the value is copied to the output buffer using an unrolled\n *           sequence of assignment statements.\n * loop:     The case expressions are all evaluated and stored in a module-scope 'const' array.\n *           This array is indexed and the value is copied to the output buffer using a for loop.\n */\n\n\n/** Configuration for running a expression test */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @returns the size and alignment in bytes of the type 'ty', taking into\n * consideration storage alignment constraints and abstract numerics, which are\n * encoded as a struct of holding two u32s.\n */\nfunction sizeAndAlignmentOf(ty, source) {\n  if (ty instanceof ScalarType) {\n    if (ty.kind === 'abstract-float' || ty.kind === 'abstract-int') {\n      // AbstractFloats and AbstractInts are passed out of the shader via structs of\n      // 2x u32s and unpacking containers as arrays\n      return { size: 8, alignment: 8 };\n    }\n    return { size: ty.size, alignment: ty.alignment };\n  }\n\n  if (ty instanceof VectorType) {\n    const out = sizeAndAlignmentOf(ty.elementType, source);\n    const n = ty.width === 3 ? 4 : ty.width;\n    out.size *= n;\n    out.alignment *= n;\n    return out;\n  }\n\n  if (ty instanceof MatrixType) {\n    const out = sizeAndAlignmentOf(ty.elementType, source);\n    const n = ty.rows === 3 ? 4 : ty.rows;\n    out.size *= n * ty.cols;\n    out.alignment *= n;\n    return out;\n  }\n\n  if (ty instanceof ArrayType) {\n    const out = sizeAndAlignmentOf(ty.elementType, source);\n    if (source === 'uniform') {\n      out.alignment = align(out.alignment, 16);\n    }\n    out.size *= ty.count;\n    return out;\n  }\n\n  unreachable(`unhandled type: ${ty}`);\n}\n\n/**\n * @returns the stride in bytes of the type 'ty', taking into consideration abstract numerics,\n * which are encoded as a struct of 2 x u32.\n */\nfunction strideOf(ty, source) {\n  const sizeAndAlign = sizeAndAlignmentOf(ty, source);\n  return align(sizeAndAlign.size, sizeAndAlign.alignment);\n}\n\n/**\n * Calls 'callback' with the layout information of each structure member with the types 'members'.\n * @returns the byte size, stride and alignment of the structure.\n */\nexport function structLayout(\nmembers,\nsource,\ncallback)\n\n\n\n\n\n\n{\n  let offset = 0;\n  let alignment = 1;\n  for (let i = 0; i < members.length; i++) {\n    const member = members[i];\n    const sizeAndAlign = sizeAndAlignmentOf(member, source);\n    offset = align(offset, sizeAndAlign.alignment);\n    if (callback) {\n      callback({\n        index: i,\n        type: member,\n        size: sizeAndAlign.size,\n        alignment: sizeAndAlign.alignment,\n        offset\n      });\n    }\n    offset += sizeAndAlign.size;\n    alignment = Math.max(alignment, sizeAndAlign.alignment);\n  }\n\n  if (source === 'uniform') {\n    alignment = align(alignment, 16);\n  }\n\n  const size = offset;\n  const stride = align(size, alignment);\n  return { size, stride, alignment };\n}\n\n/** @returns the stride in bytes between two consecutive structures with the given members */\nexport function structStride(members, source) {\n  return structLayout(members, source).stride;\n}\n\n/** @returns the WGSL to describe the structure members in 'members' */\nfunction wgslMembers(members, source, memberName) {\n  const lines = [];\n  const layout = structLayout(members, source, (m) => {\n    lines.push(`  @size(${m.size}) ${memberName(lines.length)} : ${m.type},`);\n  });\n  const padding = layout.stride - layout.size;\n  if (padding > 0) {\n    // Pad with a 'f16' if the padding requires an odd multiple of 2 bytes.\n    // This is required as 'i32' has an alignment and size of 4 bytes.\n    const ty = (padding & 2) !== 0 ? 'f16' : 'i32';\n    lines.push(`  @size(${padding}) padding : ${ty},`);\n  }\n  return lines.join('\\n');\n}\n\n// Helper for returning the WGSL storage type for the given Type.\nfunction storageType(ty) {\n  if (ty instanceof ScalarType) {\n    assert(ty.kind !== 'f64', `No storage type defined for 'f64' values`);\n    assert(ty.kind !== 'abstract-int', `Custom handling is implemented for 'abstract-int' values`);\n    assert(\n      ty.kind !== 'abstract-float',\n      `Custom handling is implemented for 'abstract-float' values`\n    );\n    if (ty.kind === 'bool') {\n      return Type.u32;\n    }\n  }\n  if (ty instanceof VectorType) {\n    return Type.vec(ty.width, storageType(ty.elementType));\n  }\n  if (ty instanceof ArrayType) {\n    return Type.array(ty.count, storageType(ty.elementType));\n  }\n  return ty;\n}\n\n/** Structure used to hold [from|to]Storage conversion helpers  */\n\n\n\n\n\n\n\n// Helper for converting a value of the type 'ty' from the storage type.\nfunction fromStorage(ty, expr, helpers) {\n  if (ty instanceof ScalarType) {\n    assert(ty.kind !== 'abstract-int', `'abstract-int' values should not be in input storage`);\n    assert(ty.kind !== 'abstract-float', `'abstract-float' values should not be in input storage`);\n    assert(ty.kind !== 'f64', `'No storage type defined for 'f64' values`);\n    if (ty.kind === 'bool') {\n      return `${expr} != 0u`;\n    }\n  }\n  if (ty instanceof VectorType) {\n    assert(\n      ty.elementType.kind !== 'abstract-int',\n      `'abstract-int' values cannot appear in input storage`\n    );\n    assert(\n      ty.elementType.kind !== 'abstract-float',\n      `'abstract-float' values cannot appear in input storage`\n    );\n    assert(ty.elementType.kind !== 'f64', `'No storage type defined for 'f64' values`);\n    if (ty.elementType.kind === 'bool') {\n      return `(${expr} != vec${ty.width}<u32>(0u))`;\n    }\n  }\n  if (ty instanceof ArrayType && elementTypeOf(ty) === Type.bool) {\n    // array<u32, N> -> array<bool, N>\n    const conv = helpers.uniqueID();\n    const inTy = Type.array(ty.count, Type.u32);\n    helpers.wgsl += `\nfn ${conv}(in : ${inTy}) -> ${ty} {\n  var out : ${ty};\n  for (var i = 0; i < ${ty.count}; i++) {\n    out[i] = in[i] != 0;\n  }\n  return out;\n}\n`;\n    return `${conv}(${expr})`;\n  }\n  return expr;\n}\n\n// Helper for converting a value of the type 'ty' to the storage type.\nfunction toStorage(ty, expr, helpers) {\n  if (ty instanceof ScalarType) {\n    assert(\n      ty.kind !== 'abstract-int',\n      `'abstract-int' values have custom code for writing to storage`\n    );\n    assert(\n      ty.kind !== 'abstract-float',\n      `'abstract-float' values have custom code for writing to storage`\n    );\n    assert(ty.kind !== 'f64', `No storage type defined for 'f64' values`);\n    if (ty.kind === 'bool') {\n      return `select(0u, 1u, ${expr})`;\n    }\n  }\n  if (ty instanceof VectorType) {\n    assert(\n      ty.elementType.kind !== 'abstract-int',\n      `'abstract-int' values have custom code for writing to storage`\n    );\n    assert(\n      ty.elementType.kind !== 'abstract-float',\n      `'abstract-float' values have custom code for writing to storage`\n    );\n    assert(ty.elementType.kind !== 'f64', `'No storage type defined for 'f64' values`);\n    if (ty.elementType.kind === 'bool') {\n      return `select(vec${ty.width}<u32>(0u), vec${ty.width}<u32>(1u), ${expr})`;\n    }\n  }\n  if (ty instanceof ArrayType && elementTypeOf(ty) === Type.bool) {\n    // array<bool, N> -> array<u32, N>\n    const conv = helpers.uniqueID();\n    const outTy = Type.array(ty.count, Type.u32);\n    helpers.wgsl += `\nfn ${conv}(in : ${ty}) -> ${outTy} {\n  var out : ${outTy};\n  for (var i = 0; i < ${ty.count}; i++) {\n    out[i] = select(0u, 1u, in[i]);\n  }\n  return out;\n}\n`;\n    return `${conv}(${expr})`;\n  }\n  return expr;\n}\n\n// A Pipeline is a map of WGSL shader source to a built pipeline\n\n\n/**\n * Searches for an entry with the given key, adding and returning the result of calling\n * `create` if the entry was not found.\n * @param map the cache map\n * @param key the entry's key\n * @param create the function used to construct a value, if not found in the cache\n * @returns the value, either fetched from the cache, or newly built.\n */\nfunction getOrCreate(map, key, create) {\n  const existing = map.get(key);\n  if (existing !== undefined) {\n    return existing;\n  }\n  const value = create();\n  map.set(key, value);\n  return value;\n}\n\n/**\n * Runs the list of expression tests, possibly splitting the tests into multiple\n * dispatches to keep the input data within the buffer binding limits.\n * run() will pack the scalar test cases into smaller set of vectorized tests\n * if `cfg.vectorize` is defined.\n * @param t the GPUTest\n * @param shaderBuilder the shader builder function\n * @param parameterTypes the list of expression parameter types\n * @param resultType the return type for the expression overload\n * @param cfg test configuration values\n * @param cases list of test cases\n * @param batch_size override the calculated casesPerBatch.\n */\nexport async function run(\nt,\nshaderBuilder,\nparameterTypes,\nresultType,\ncfg = { inputSource: 'storage_r' },\ncases,\nbatch_size)\n{\n  // If the 'vectorize' config option was provided, pack the cases into vectors.\n  if (cfg.vectorize !== undefined) {\n    const packed = packScalarsToVector(parameterTypes, resultType, cases, cfg.vectorize);\n    cases = packed.cases;\n    parameterTypes = packed.parameterTypes;\n    resultType = packed.resultType;\n  }\n\n  // The size of the input buffer may exceed the maximum buffer binding size,\n  // so chunk the tests up into batches that fit into the limits. We also split\n  // the cases into smaller batches to help with shader compilation performance.\n  const casesPerBatch = function () {\n    if (batch_size) {\n      return batch_size;\n    }\n    switch (cfg.inputSource) {\n      case 'const':\n        // Some drivers are slow to optimize shaders with many constant values,\n        // or statements. 32 is an empirically picked number of cases that works\n        // well for most drivers.\n        return 32;\n      case 'uniform':\n        // Some drivers are slow to build pipelines with large uniform buffers.\n        // 2k appears to be a sweet-spot when benchmarking.\n        return Math.floor(\n          Math.min(1024 * 2, t.device.limits.maxUniformBufferBindingSize) /\n          structStride(parameterTypes, cfg.inputSource)\n        );\n      case 'storage_r':\n      case 'storage_rw':\n        return Math.floor(\n          t.device.limits.maxStorageBufferBindingSize /\n          structStride(parameterTypes, cfg.inputSource)\n        );\n    }\n  }();\n\n  // A cache to hold built shader pipelines.\n  const pipelineCache = new Map();\n\n  // Submit all the cases in batches, rate-limiting to ensure not too many\n  // batches are in flight simultaneously.\n  const maxBatchesInFlight = 5;\n  let batchesInFlight = 0;\n  let resolvePromiseBlockingBatch = undefined;\n  const batchFinishedCallback = () => {\n    batchesInFlight -= 1;\n    // If there is any batch waiting on a previous batch to finish,\n    // unblock it now, and clear the resolve callback.\n    if (resolvePromiseBlockingBatch) {\n      resolvePromiseBlockingBatch();\n      resolvePromiseBlockingBatch = undefined;\n    }\n  };\n\n  const processBatch = async (batchCases) => {\n    const shaderBuilderParams = {\n      parameterTypes,\n      resultType,\n      cases: batchCases,\n      inputSource: cfg.inputSource,\n      constEvaluationMode: cfg.constEvaluationMode\n    };\n    const checkBatch = await submitBatch(t, shaderBuilder, shaderBuilderParams, pipelineCache);\n    checkBatch();\n    await t.queue.onSubmittedWorkDone();\n  };\n\n  const pendingBatches = [];\n\n  for (let i = 0; i < cases.length; i += casesPerBatch) {\n    const batchCases = cases.slice(i, Math.min(i + casesPerBatch, cases.length));\n\n    if (batchesInFlight > maxBatchesInFlight) {\n      await new Promise((resolve) => {\n        // There should only be one batch waiting at a time.\n        assert(resolvePromiseBlockingBatch === undefined);\n        resolvePromiseBlockingBatch = resolve;\n      });\n    }\n    batchesInFlight += 1;\n\n    pendingBatches.push(\n      processBatch(batchCases).\n      catch((err) => {\n        if (err instanceof GPUPipelineError) {\n          t.fail(`Pipeline Creation Error, ${err.reason}: ${err.message}`);\n        } else {\n          throw err;\n        }\n      }).\n      finally(batchFinishedCallback)\n    );\n  }\n\n  await Promise.all(pendingBatches);\n}\n\n/**\n * Submits the list of expression tests. The input data must fit within the\n * buffer binding limits of the given inputSource.\n * @param t the GPUTest\n * @param shaderBuilder the shader builder function\n * @param shaderBuilderParams the shader builder parameters\n * @param pipelineCache the cache of compute pipelines, shared between batches\n * @returns a function that checks the results are as expected\n */\nasync function submitBatch(\nt,\nshaderBuilder,\nshaderBuilderParams,\npipelineCache)\n{\n  const { resultType, cases } = shaderBuilderParams;\n\n  // Construct a buffer to hold the results of the expression tests\n  const outputStride = structStride([resultType], 'storage_rw');\n  const outputBufferSize = align(cases.length * outputStride, 4);\n  const outputBuffer = t.createBufferTracked({\n    size: outputBufferSize,\n    usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE\n  });\n\n  const [pipeline, group] = await buildPipeline(\n    t,\n    shaderBuilder,\n    shaderBuilderParams,\n    outputBuffer,\n    pipelineCache\n  );\n\n  const encoder = globalThis._TRAMPOLINE_(\"createCommandEncoder\", t.device, t.device.createCommandEncoder, [], () => t.device.createCommandEncoder());\n  const pass = encoder.beginComputePass();\n  pass.setPipeline(pipeline);\n  pass.setBindGroup(0, group);\n  pass.dispatchWorkgroups(1);\n  pass.end();\n\n  // Heartbeat to ensure CTS runners know we're alive.\n  globalTestConfig.testHeartbeatCallback();\n\n  globalThis._TRAMPOLINE_(\"submit\", t, t.queue.submit, [[encoder.finish()]], () => t.queue.submit([encoder.finish()]));\n\n  // Return a function that can check the results of the shader\n  return () => {\n    const checkExpectation = (outputData) => {\n      // Read the outputs from the output buffer\n      const outputs = new Array(cases.length);\n      for (let i = 0; i < cases.length; i++) {\n        outputs[i] = resultType.read(outputData, i * outputStride);\n      }\n\n      // The list of expectation failures\n      const errs = [];\n\n      // For each case...\n      for (let caseIdx = 0; caseIdx < cases.length; caseIdx++) {\n        const c = cases[caseIdx];\n        const got = outputs[caseIdx];\n        const cmp = toComparator(c.expected).compare(got);\n        if (!cmp.matched) {\n          errs.push(`(${c.input instanceof Array ? c.input.join(', ') : c.input})\n    returned: ${cmp.got}\n    expected: ${cmp.expected}`);\n        }\n      }\n\n      return errs.length > 0 ? new Error(errs.join('\\n\\n')) : undefined;\n    };\n\n    // Heartbeat to ensure CTS runners know we're alive.\n    globalTestConfig.testHeartbeatCallback();\n\n    t.expectGPUBufferValuesPassCheck(outputBuffer, checkExpectation, {\n      type: Uint8Array,\n      typedLength: outputBufferSize\n    });\n  };\n}\n\n/**\n * map is a helper for returning a new array with each element of `v`\n * transformed with `fn`.\n * If `v` is not an array, then `fn` is called with (v, 0).\n */\nfunction map(v, fn) {\n  if (v instanceof Array) {\n    return v.map(fn);\n  }\n  return [fn(v, 0)];\n}\n\n/** The structured arguments for a ShaderBuilder function */\n\n\n\n\n\n\n\n\n\n\n\n\n\n/** ShaderBuilder is a function used to construct the WGSL shader used by an expression test. */\n\n\n/**\n * Helper that returns the WGSL to declare the output storage buffer for a shader\n */\nfunction wgslOutputs(resultType, count) {\n  let output_struct = undefined;\n  if (\n  scalarTypeOf(resultType).kind !== 'abstract-float' &&\n  scalarTypeOf(resultType).kind !== 'abstract-int')\n  {\n    output_struct = `\nstruct Output {\n  @size(${strideOf(resultType, 'storage_rw')}) value : ${storageType(resultType)}\n};`;\n  } else {\n    if (resultType instanceof ScalarType) {\n      output_struct = `struct AF {\n  low: u32,\n  high: u32,\n};\n\nstruct Output {\n  @size(${strideOf(resultType, 'storage_rw')}) value: AF,\n};`;\n    }\n    if (resultType instanceof VectorType) {\n      const dim = resultType.width;\n      output_struct = `struct AF {\n  low: u32,\n  high: u32,\n};\n\nstruct Output {\n  @size(${strideOf(resultType, 'storage_rw')}) value: array<AF, ${dim}>,\n};`;\n    }\n\n    if (resultType instanceof MatrixType) {\n      const cols = resultType.cols;\n      const rows = resultType.rows === 2 ? 2 : 4; // 3 element rows have a padding element\n      output_struct = `struct AF {\n  low: u32,\n  high: u32,\n};\n\nstruct Output {\n   @size(${strideOf(resultType, 'storage_rw')}) value: array<array<AF, ${rows}>, ${cols}>,\n};`;\n    }\n\n    assert(output_struct !== undefined, `No implementation for result type '${resultType}'`);\n  }\n\n  return `${output_struct}\n@group(0) @binding(0) var<storage, read_write> outputs : array<Output, ${count}>;\n`;\n}\n\n/**\n * Helper that returns the WGSL to declare the values array for a shader\n */\nfunction wgslValuesArray(cases, expressionBuilder) {\n  return `\nconst values = array(\n  ${cases.map((c) => expressionBuilder(map(c.input, (v) => v.wgsl()))).join(',\\n  ')}\n);`;\n}\n\n/**\n * Helper that returns the WGSL 'var' declaration for the given input source\n */\nfunction wgslInputVar(inputSource, count) {\n  switch (inputSource) {\n    case 'storage_r':\n      return `@group(0) @binding(1) var<storage, read> inputs : array<Input, ${count}>;`;\n    case 'storage_rw':\n      return `@group(0) @binding(1) var<storage, read_write> inputs : array<Input, ${count}>;`;\n    case 'uniform':\n      return `@group(0) @binding(1) var<uniform> inputs : array<Input, ${count}>;`;\n  }\n  throw new Error(`InputSource ${inputSource} does not use an input var`);\n}\n\n/**\n * Helper that returns the WGSL header before any other declaration, currently include f16\n * enable directive if necessary.\n */\nfunction wgslHeader(parameterTypes, resultType) {\n  const usedF16 =\n  scalarTypeOf(resultType).kind === 'f16' ||\n  parameterTypes.some((ty) => scalarTypeOf(ty).kind === 'f16');\n  const header = usedF16 ? 'enable f16;\\n' : '';\n  return header;\n}\n\n/**\n * ExpressionBuilder returns the WGSL used to evaluate an expression with the\n * given input values.\n */\n\n\n/**\n * @returns the WGSL for a basic expression test shader.\n * @param expressionBuilder the expression builder\n */\nfunction basicExpressionShaderBody(\nexpressionBuilder,\nparams)\n{\n  const { parameterTypes, resultType, cases, inputSource } = params;\n\n  assert(\n    scalarTypeOf(resultType).kind !== 'abstract-int',\n    `abstractIntShaderBuilder should be used when result type is 'abstract-int'`\n  );\n  assert(\n    scalarTypeOf(resultType).kind !== 'abstract-float',\n    `abstractFloatShaderBuilder should be used when result type is 'abstract-float'`\n  );\n  let nextUniqueIDSuffix = 0;\n  const convHelpers = {\n    wgsl: '',\n    uniqueID: () => `cts_symbol_${nextUniqueIDSuffix++}`\n  };\n  if (inputSource === 'const') {\n    let constEvaluationMode = params.constEvaluationMode;\n    if (constEvaluationMode === undefined) {\n      if (parameterTypes.some((ty) => isAbstractType(scalarTypeOf(ty)))) {\n        // Directly assign the expression to the output, to avoid an\n        // intermediate store, which will concretize the value early\n        constEvaluationMode = 'direct';\n      } else {\n        constEvaluationMode = globalTestConfig.unrollConstEvalLoops ? 'unrolled' : 'loop';\n      }\n    }\n    //////////////////////////////////////////////////////////////////////////\n    // Constant eval\n    //////////////////////////////////////////////////////////////////////////\n    let body = '';\n    let valuesArray = '';\n    switch (constEvaluationMode) {\n      case 'direct':{\n          body = cases.\n          map(\n            (c, i) =>\n            `  outputs[${i}].value = ${toStorage(\n              resultType,\n              expressionBuilder(map(c.input, (v) => v.wgsl())),\n              convHelpers\n            )};`\n          ).\n          join('\\n  ');\n          break;\n        }\n      case 'unrolled':{\n          body = cases.\n          map((_, i) => {\n            const value = `values[${i}]`;\n            return `  outputs[${i}].value = ${toStorage(resultType, value, convHelpers)};`;\n          }).\n          join('\\n  ');\n          valuesArray = wgslValuesArray(cases, expressionBuilder);\n          break;\n        }\n      case 'loop':{\n          body = `\n  for (var i = 0u; i < ${cases.length}; i++) {\n    outputs[i].value = ${toStorage(resultType, `values[i]`, convHelpers)};\n  }`;\n          valuesArray = wgslValuesArray(cases, expressionBuilder);\n          break;\n        }\n    }\n\n    return `\n${wgslOutputs(resultType, cases.length)}\n\n${valuesArray}\n\n${convHelpers.wgsl}\n\n@compute @workgroup_size(1)\nfn main() {\n${body}\n}\n`;\n  } else {\n    //////////////////////////////////////////////////////////////////////////\n    // Runtime eval\n    //////////////////////////////////////////////////////////////////////////\n\n    // returns the WGSL expression to load the ith parameter of the given type from the input buffer\n    const paramExpr = (ty, i) => fromStorage(ty, `inputs[i].param${i}`, convHelpers);\n\n    // resolves to the expression that calls the builtin\n    const expr = toStorage(\n      resultType,\n      expressionBuilder(parameterTypes.map(paramExpr)),\n      convHelpers\n    );\n\n    return `\nstruct Input {\n${wgslMembers(parameterTypes.map(storageType), inputSource, (i) => `param${i}`)}\n}\n\n${wgslOutputs(resultType, cases.length)}\n\n${wgslInputVar(inputSource, cases.length)}\n\n${convHelpers.wgsl}\n\n@compute @workgroup_size(1)\nfn main() {\n  for (var i = 0; i < ${cases.length}; i++) {\n    outputs[i].value = ${expr};\n  }\n}\n`;\n  }\n}\n\n/**\n * Returns a ShaderBuilder that builds a basic expression test shader.\n * @param expressionBuilder the expression builder\n */\nexport function basicExpressionBuilder(expressionBuilder) {\n  return (params) => {\n    return `\\\n${wgslHeader(params.parameterTypes, params.resultType)}\n\n${basicExpressionShaderBody(expressionBuilder, params)}`;\n  };\n}\n\n/**\n * Returns a ShaderBuilder that builds a basic expression test shader with given predeclaration\n * string goes after WGSL header (i.e. enable directives) if any but before anything else.\n * @param expressionBuilder the expression builder\n * @param predeclaration the predeclaration string\n */\nexport function basicExpressionWithPredeclarationBuilder(\nexpressionBuilder,\npredeclaration)\n{\n  return (params) => {\n    return `\\\n${wgslHeader(params.parameterTypes, params.resultType)}\n\n${predeclaration}\n\n${basicExpressionShaderBody(expressionBuilder, params)}`;\n  };\n}\n\n/**\n * Returns a ShaderBuilder that builds a compound assignment operator test shader.\n * @param op the compound operator\n */\nexport function compoundAssignmentBuilder(op) {\n  return (params) => {\n    const { parameterTypes, resultType, cases, inputSource } = params;\n\n    //////////////////////////////////////////////////////////////////////////\n    // Input validation\n    //////////////////////////////////////////////////////////////////////////\n    if (parameterTypes.length !== 2) {\n      throw new Error(`compoundBinaryOp() requires exactly two parameters values per case`);\n    }\n    const lhsType = parameterTypes[0];\n    const rhsType = parameterTypes[1];\n    if (!objectEquals(lhsType, resultType)) {\n      throw new Error(\n        `compoundBinaryOp() requires result type (${resultType}) to be equal to the LHS type (${lhsType})`\n      );\n    }\n    if (inputSource === 'const') {\n      //////////////////////////////////////////////////////////////////////////\n      // Constant eval\n      //////////////////////////////////////////////////////////////////////////\n      let body = '';\n      if (globalTestConfig.unrollConstEvalLoops) {\n        body = cases.\n        map((_, i) => {\n          return `\n  var ret_${i} = lhs[${i}];\n  ret_${i} ${op} rhs[${i}];\n  outputs[${i}].value = ${storageType(resultType)}(ret_${i});`;\n        }).\n        join('\\n  ');\n      } else {\n        body = `\n  for (var i = 0u; i < ${cases.length}; i++) {\n    var ret = lhs[i];\n    ret ${op} rhs[i];\n    outputs[i].value = ${storageType(resultType)}(ret);\n  }`;\n      }\n\n      const values = cases.map((c) => c.input.map((v) => v.wgsl()));\n\n      return `\n${wgslHeader(parameterTypes, resultType)}\n${wgslOutputs(resultType, cases.length)}\n\nconst lhs = array(\n${values.map((c) => `${c[0]}`).join(',\\n  ')}\n      );\nconst rhs = array(\n${values.map((c) => `${c[1]}`).join(',\\n  ')}\n);\n\n@compute @workgroup_size(1)\nfn main() {\n${body}\n}`;\n    } else {\n      //////////////////////////////////////////////////////////////////////////\n      // Runtime eval\n      //////////////////////////////////////////////////////////////////////////\n      let operation = '';\n      if (inputSource === 'storage_rw' && objectEquals(resultType, storageType(resultType))) {\n        operation = `\n        outputs[i].value = ${storageType(resultType)}(inputs[i].lhs);\n        outputs[i].value ${op} ${rhsType}(inputs[i].rhs);`;\n      } else {\n        operation = `\n        var ret = ${lhsType}(inputs[i].lhs);\n        ret ${op} ${rhsType}(inputs[i].rhs);\n        outputs[i].value = ${storageType(resultType)}(ret);`;\n      }\n      return `\n${wgslHeader(parameterTypes, resultType)}\n${wgslOutputs(resultType, cases.length)}\n\nstruct Input {\n${wgslMembers([lhsType, rhsType].map(storageType), inputSource, (i) => ['lhs', 'rhs'][i])}\n}\n\n${wgslInputVar(inputSource, cases.length)}\n\n@compute @workgroup_size(1)\nfn main() {\n  for (var i = 0; i < ${cases.length}; i++) {\n    ${operation}\n  }\n}\n`;\n    }\n  };\n}\n\n/**\n * @returns a string that extracts the value of an AbstractFloat into an output\n *          destination\n * @param expr expression for an AbstractFloat value, if working with vectors or\n *             matrices, this string needs to include indexing into the\n *             container.\n * @param case_idx index in the case output array to assign the result\n * @param accessor string representing how access to the AF that needs to be\n *                 operated on.\n *                 For scalars this should be left as ''.\n *                 For vectors this will be an indexing operation,\n *                 i.e. '[i]'\n *                 For matrices this will double indexing operation,\n *                 i.e. '[c][r]'\n */\nfunction abstractFloatSnippet(expr, case_idx, accessor = '') {\n  // AbstractFloats are f64s under the hood. WebGPU does not support\n  // putting f64s in buffers, so the result needs to be split up into u32s\n  // and rebuilt in the test framework.\n  //\n  // Since there is no 64-bit data type that can be used as an element for a\n  // vector or a matrix in WGSL, the testing framework needs to pass the u32s\n  // via a struct with two u32s, and deconstruct vectors and matrices into\n  // arrays.\n  //\n  // This is complicated by the fact that user defined functions cannot\n  // take/return AbstractFloats, and AbstractFloats cannot be stored in\n  // variables, so the code cannot just inject a simple utility function\n  // at the top of the shader, instead this snippet needs to be inlined\n  // everywhere the test needs to return an AbstractFloat.\n  //\n  // select is used below, since ifs are not available during constant\n  // eval. This has the side effect of short-circuiting doesn't occur, so\n  // both sides of the select have to evaluate and be valid.\n  //\n  // This snippet implements FTZ for subnormals to bypass the need for\n  // complex subnormal specific logic.\n  //\n  // Expressions resulting in subnormals can still be reasonably tested,\n  // since this snippet will return 0 with the correct sign, which is\n  // always in the acceptance interval for a subnormal result, since an\n  // implementation may FTZ.\n  //\n  // Documentation for the snippet working with scalar results is included here\n  // in this code block, since shader length affects compilation time\n  // significantly on some backends. The code for vectors and matrices basically\n  // the same thing, with extra indexing operations.\n  //\n  // Snippet with documentation:\n  //   const kExponentBias = 1022;\n  //\n  //   // Detect if the value is zero or subnormal, so that FTZ behaviour\n  //   // can occur\n  //   const subnormal_or_zero : bool = (${expr} <= ${kValue.f64.positive.subnormal.max}) && (${expr} >= ${kValue.f64.negative.subnormal.min});\n  //\n  //   // MSB of the upper u32 is 1 if the value is negative, otherwise 0\n  //   // Extract the sign bit early, so that abs() can be used with\n  //   // frexp() so negative cases do not need to be handled\n  //   const sign_bit : u32 = select(0, 0x80000000, ${expr} < 0);\n  //\n  //   // Use frexp() to obtain the exponent and fractional parts, and\n  //   // then perform FTZ if needed\n  //   const f = frexp(abs(${expr}));\n  //   const f_fract = select(f.fract, 0, subnormal_or_zero);\n  //   const f_exp = select(f.exp, -kExponentBias, subnormal_or_zero);\n  //\n  //   // Adjust for the exponent bias and shift for storing in bits\n  //   // [20..31] of the upper u32\n  //   const exponent_bits : u32 = (f_exp + kExponentBias) << 20;\n  //\n  //   // Extract the portion of the mantissa that appears in upper u32 as\n  //   // a float for later use\n  //   const high_mantissa = ldexp(f_fract, 21);\n  //\n  //   // Extract the portion of the mantissa that appears in upper u32 as\n  //   // as bits. This value is masked, because normals will explicitly\n  //   // have the implicit leading 1 that should not be in the final\n  //   // result.\n  //   const high_mantissa_bits : u32 = u32(ldexp(f_fract, 21)) & 0x000fffff;\n  //\n  //   // Calculate the mantissa stored in the lower u32 as a float\n  //   const low_mantissa = f_fract - ldexp(floor(high_mantissa), -21);\n  //\n  //   // Convert the lower u32 mantissa to bits\n  //   const low_mantissa_bits = u32(ldexp(low_mantissa, 53));\n  //\n  //   outputs[${i}].value.high = sign_bit | exponent_bits | high_mantissa_bits;\n  //   outputs[${i}].value.low = low_mantissa_bits;\n\n  return `  {\n    const kExponentBias = 1022;\n    const subnormal_or_zero : bool = (${expr}${accessor} <= ${kValue.f64.positive.subnormal.max}) && (${expr}${accessor} >= ${kValue.f64.negative.subnormal.min});\n    const sign_bit : u32 = select(0, 0x80000000, ${expr}${accessor} < 0);\n    const f = frexp(abs(${expr}${accessor}));\n    const f_fract = select(f.fract, 0, subnormal_or_zero);\n    const f_exp = select(f.exp, -kExponentBias, subnormal_or_zero);\n    const exponent_bits : u32 = (f_exp + kExponentBias) << 20;\n    const high_mantissa = ldexp(f_fract, 21);\n    const high_mantissa_bits : u32 = u32(ldexp(f_fract, 21)) & 0x000fffff;\n    const low_mantissa = f_fract - ldexp(floor(high_mantissa), -21);\n    const low_mantissa_bits = u32(ldexp(low_mantissa, 53));\n    outputs[${case_idx}].value${accessor}.high = sign_bit | exponent_bits | high_mantissa_bits;\n    outputs[${case_idx}].value${accessor}.low = low_mantissa_bits;\n  }`;\n}\n\n/** @returns a string for a specific case that has a AbstractFloat result */\nfunction abstractFloatCaseBody(expr, resultType, i) {\n  if (resultType instanceof ScalarType) {\n    return abstractFloatSnippet(expr, i);\n  }\n\n  if (resultType instanceof VectorType) {\n    return [...Array(resultType.width).keys()].\n    map((idx) => abstractFloatSnippet(expr, i, `[${idx}]`)).\n    join('  \\n');\n  }\n\n  if (resultType instanceof MatrixType) {\n    const cols = resultType.cols;\n    const rows = resultType.rows;\n    const results = [...Array(cols * rows)];\n\n    for (let c = 0; c < cols; c++) {\n      for (let r = 0; r < rows; r++) {\n        results[c * rows + r] = abstractFloatSnippet(expr, i, `[${c}][${r}]`);\n      }\n    }\n\n    return results.join('  \\n');\n  }\n\n  unreachable(`Results of type '${resultType}' not yet implemented`);\n}\n\n/**\n * @returns a ShaderBuilder that builds a test shader hands AbstractFloat results.\n * @param expressionBuilder an expression builder that will return AbstractFloats\n */\nexport function abstractFloatShaderBuilder(expressionBuilder) {\n  return (params) => {\n    const { parameterTypes, resultType, cases, inputSource } = params;\n    assert(inputSource === 'const', `'abstract-float' results are only defined for const-eval`);\n    assert(\n      scalarTypeOf(resultType).kind === 'abstract-float',\n      `Expected resultType of 'abstract-float', received '${scalarTypeOf(resultType).kind}' instead`\n    );\n\n    const body = cases.\n    map((c, i) => {\n      const expr = `${expressionBuilder(map(c.input, (v) => v.wgsl()))}`;\n      return abstractFloatCaseBody(expr, resultType, i);\n    }).\n    join('\\n  ');\n\n    return `\n${wgslHeader(parameterTypes, resultType)}\n\n${wgslOutputs(resultType, cases.length)}\n\n@compute @workgroup_size(1)\nfn main() {\n${body}\n}`;\n  };\n}\n\n/**\n * @returns a string that extracts the value of an AbstractInt into an output\n *          destination\n * @param expr expression for an AbstractInt value, if working with vectors,\n *             this string needs to include indexing into the container.\n * @param case_idx index in the case output array to assign the result\n * @param accessor string representing how access to the AbstractInt that needs\n *                 to be operated on.\n *                 For scalars this should be left as ''.\n *                 For vectors this will be an indexing operation,\n *                 i.e. '[i]'\n */\nfunction abstractIntSnippet(expr, case_idx, accessor = '') {\n  // AbstractInts are i64s under the hood. WebGPU does not support\n  // putting i64s in buffers, or any 64-bit simple types, so the result needs to\n  // be split up into u32 bitfields\n  //\n  // Since there is no 64-bit data type that can be used as an element for a\n  // vector or a matrix in WGSL, the testing framework needs to pass the u32s\n  // via a struct with two u32s, and deconstruct vectors into arrays.\n  //\n  // This is complicated by the fact that user defined functions cannot\n  // take/return AbstractInts, and AbstractInts cannot be stored in\n  // variables, so the code cannot just inject a simple utility function\n  // at the top of the shader, instead this snippet needs to be inlined\n  // everywhere the test needs to return an AbstractInt.\n  return `  {\n    outputs[${case_idx}].value${accessor}.high = bitcast<u32>(i32(${expr}${accessor} >> 32)) & 0xFFFFFFFF;\n    const low_sign = (${expr}${accessor} & (1 << 31));\n    outputs[${case_idx}].value${accessor}.low = bitcast<u32>((${expr}${accessor} & 0x7FFFFFFF)) | low_sign;\n  }`;\n}\n\n/** @returns a string for a specific case that has a AbstractInt result */\nfunction abstractIntCaseBody(expr, resultType, i) {\n  if (resultType instanceof ScalarType) {\n    return abstractIntSnippet(expr, i);\n  }\n\n  if (resultType instanceof VectorType) {\n    return [...Array(resultType.width).keys()].\n    map((idx) => abstractIntSnippet(expr, i, `[${idx}]`)).\n    join('  \\n');\n  }\n\n  unreachable(`Results of type '${resultType}' not yet implemented`);\n}\n\n/**\n * @returns a ShaderBuilder that builds a test shader hands AbstractInt results.\n * @param expressionBuilder an expression builder that will return AbstractInts\n */\nexport function abstractIntShaderBuilder(expressionBuilder) {\n  return (params) => {\n    const { parameterTypes, resultType, cases, inputSource } = params;\n\n    assert(inputSource === 'const', `'abstract-int' results are only defined for const-eval`);\n    assert(\n      scalarTypeOf(resultType).kind === 'abstract-int',\n      `Expected resultType of 'abstract-int', received '${scalarTypeOf(resultType).kind}' instead`\n    );\n\n    const body = cases.\n    map((c, i) => {\n      const expr = `${expressionBuilder(map(c.input, (v) => v.wgsl()))}`;\n      return abstractIntCaseBody(expr, resultType, i);\n    }).\n    join('\\n  ');\n\n    return `\n${wgslHeader(parameterTypes, resultType)}\n\n${wgslOutputs(resultType, cases.length)}\n\n@compute @workgroup_size(1)\nfn main() {\n${body}\n}`;\n  };\n}\n\n/**\n * Constructs and returns a GPUComputePipeline and GPUBindGroup for running a\n * batch of test cases. If a pre-created pipeline can be found in\n * `pipelineCache`, then this may be returned instead of creating a new\n * pipeline.\n * @param t the GPUTest\n * @param shaderBuilder the shader builder\n * @param shaderBuilderParams the parameters for the shader builder\n * @param outputBuffer the buffer that will hold the output values of the tests\n * @param pipelineCache the cache of compute pipelines, shared between batches\n */\nasync function buildPipeline(\nt,\nshaderBuilder,\nshaderBuilderParams,\noutputBuffer,\npipelineCache)\n{\n  const { parameterTypes, cases, inputSource } = shaderBuilderParams;\n\n  cases.forEach((c) => {\n    const inputTypes = c.input instanceof Array ? c.input.map((i) => i.type) : [c.input.type];\n    if (!objectEquals(inputTypes, parameterTypes)) {\n      const input_str = `[${inputTypes.join(',')}]`;\n      const param_str = `[${parameterTypes.join(',')}]`;\n      throw new Error(\n        `case input types ${input_str} do not match provided runner parameter types ${param_str}`\n      );\n    }\n  });\n\n  const source = shaderBuilder(shaderBuilderParams);\n\n  switch (inputSource) {\n    case 'const':{\n        // build the shader module\n        const module = t.device.createShaderModule({ code: source });\n\n        // build the pipeline\n        const pipeline = await t.device.createComputePipelineAsync({\n          layout: 'auto',\n          compute: { module, entryPoint: 'main' }\n        });\n\n        // build the bind group\n        const group = t.device.createBindGroup({\n          layout: pipeline.getBindGroupLayout(0),\n          entries: [{ binding: 0, resource: { buffer: outputBuffer } }]\n        });\n\n        return [pipeline, group];\n      }\n\n    case 'uniform':\n    case 'storage_r':\n    case 'storage_rw':{\n        // Input values come from a uniform or storage buffer\n\n        // size in bytes of the input buffer\n        const caseStride = structStride(parameterTypes, inputSource);\n        const inputSize = align(cases.length * caseStride, 4);\n\n        // Holds all the parameter values for all cases\n        const inputData = new Uint8Array(inputSize);\n\n        // Pack all the input parameter values into the inputData buffer\n        for (let caseIdx = 0; caseIdx < cases.length; caseIdx++) {\n          const offset = caseIdx * caseStride;\n          structLayout(parameterTypes, inputSource, (m) => {\n            const arg = cases[caseIdx].input;\n            if (arg instanceof Array) {\n              arg[m.index].copyTo(inputData, offset + m.offset);\n            } else {\n              arg.copyTo(inputData, offset + m.offset);\n            }\n          });\n        }\n\n        // build the compute pipeline, if the shader hasn't been compiled already.\n        const pipeline = getOrCreate(pipelineCache, source, () => {\n          // build the shader module\n          const module = t.device.createShaderModule({ code: source });\n\n          // build the pipeline\n          return t.device.createComputePipeline({\n            layout: 'auto',\n            compute: { module, entryPoint: 'main' }\n          });\n        });\n\n        // build the input buffer\n        const inputBuffer = t.makeBufferWithContents(\n          inputData,\n          GPUBufferUsage.COPY_SRC | (\n          inputSource === 'uniform' ? GPUBufferUsage.UNIFORM : GPUBufferUsage.STORAGE)\n        );\n\n        // build the bind group\n        const group = t.device.createBindGroup({\n          layout: pipeline.getBindGroupLayout(0),\n          entries: [\n          { binding: 0, resource: { buffer: outputBuffer } },\n          { binding: 1, resource: { buffer: inputBuffer } }]\n\n        });\n\n        return [pipeline, group];\n      }\n  }\n}\n\n/**\n * Packs a list of scalar test cases into a smaller list of vector cases.\n * Requires that all parameters of the expression overload are of a scalar type,\n * and the return type of the expression overload is also a scalar type.\n * If `cases.length` is not a multiple of `vectorWidth`, then the last scalar\n * test case value is repeated to fill the vector value.\n */\nexport function packScalarsToVector(\nparameterTypes,\nresultType,\ncases,\nvectorWidth)\n{\n  // Validate that the parameters and return type are all vectorizable\n  for (let i = 0; i < parameterTypes.length; i++) {\n    const ty = parameterTypes[i];\n    if (!(ty instanceof ScalarType)) {\n      throw new Error(\n        `packScalarsToVector() can only be used on scalar parameter types, but the ${i}'th parameter type is a ${ty}'`\n      );\n    }\n  }\n  if (!(resultType instanceof ScalarType)) {\n    throw new Error(\n      `packScalarsToVector() can only be used with a scalar return type, but the return type is a ${resultType}'`\n    );\n  }\n\n  const packedCases = [];\n  const packedParameterTypes = parameterTypes.map((p) => Type.vec(vectorWidth, p));\n  const packedResultType = Type.vec(vectorWidth, resultType);\n\n  const clampCaseIdx = (idx) => Math.min(idx, cases.length - 1);\n\n  let caseIdx = 0;\n  while (caseIdx < cases.length) {\n    // Construct the vectorized inputs from the scalar cases\n    const packedInputs = new Array(parameterTypes.length);\n    for (let paramIdx = 0; paramIdx < parameterTypes.length; paramIdx++) {\n      const inputElements = new Array(vectorWidth);\n      for (let i = 0; i < vectorWidth; i++) {\n        const input = cases[clampCaseIdx(caseIdx + i)].input;\n        inputElements[i] = input instanceof Array ? input[paramIdx] : input;\n      }\n      packedInputs[paramIdx] = new VectorValue(inputElements);\n    }\n\n    // Gather the comparators for the packed cases\n    const cmp_impls = new Array(vectorWidth);\n    for (let i = 0; i < vectorWidth; i++) {\n      cmp_impls[i] = toComparator(cases[clampCaseIdx(caseIdx + i)].expected).compare;\n    }\n    const comparators = {\n      compare: (got) => {\n        let matched = true;\n        const gElements = new Array(vectorWidth);\n        const eElements = new Array(vectorWidth);\n        for (let i = 0; i < vectorWidth; i++) {\n          const d = cmp_impls[i](got.elements[i]);\n          matched = matched && d.matched;\n          gElements[i] = d.got;\n          eElements[i] = d.expected;\n        }\n        return {\n          matched,\n          got: `${packedResultType}(${gElements.join(', ')})`,\n          expected: `${packedResultType}(${eElements.join(', ')})`\n        };\n      },\n      kind: 'packed'\n    };\n\n    // Append the new packed case\n    packedCases.push({ input: packedInputs, expected: comparators });\n    caseIdx += vectorWidth;\n  }\n\n  return {\n    cases: packedCases,\n    parameterTypes: packedParameterTypes,\n    resultType: packedResultType\n  };\n}"],"mappings":"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SAAS,GAAG;AACpB,oBAAoBH,OAAO;AAC3B,cAAcD,EAAE,IAAIE,OAAO;AAC3B,6BAA6B1I,WAAW,CAAC2B,UAAU,CAAC,QAAQ;MACtD;MACA,OAAO;AACb,EAAE4F,UAAU,CAAC7F,cAAc,EAAEC,UAAU,CAAC;AACxC,EAAEsF,WAAW,CAACtF,UAAU,EAAEG,KAAK,CAAC9C,MAAM,CAAC;AACvC;AACA;AACA,EAAEQ,WAAW,CAAC,CAACiJ,OAAO,EAAEC,OAAO,CAAC,CAAC3H,GAAG,CAACf,WAAW,CAAC,EAAE6B,WAAW,EAAE,CAAC9C,CAAC,KAAK,CAAC,KAAK,EAAE,KAAK,CAAC,CAACA,CAAC,CAAC,CAAC;AACzF;AACA;AACA,EAAEuI,YAAY,CAACzF,WAAW,EAAEC,KAAK,CAAC9C,MAAM,CAAC;AACzC;AACA;AACA;AACA,wBAAwB8C,KAAK,CAAC9C,MAAM;AACpC,MAAM4J,SAAS;AACf;AACA;AACA,CAAC;IACG;EACF,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,oBAAoBA,CAACxI,IAAI,EAAEyI,QAAQ,EAAEC,QAAQ,GAAG,EAAE,EAAE;EAC3D;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EAEA,OAAO;AACT;AACA,wCAAwC1I,IAAI,GAAG0I,QAAQ,OAAOlM,MAAM,CAACmM,GAAG,CAACC,QAAQ,CAACC,SAAS,CAAC7J,GAAG,SAASgB,IAAI,GAAG0I,QAAQ,OAAOlM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","ignoreList":[]}