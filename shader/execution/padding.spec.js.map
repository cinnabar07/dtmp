{"version":3,"file":"padding.spec.js","names":["description","makeTestGroup","iterRange","GPUTest","g","runShaderTest","t","wgsl","expected","pipeline","device","createComputePipeline","layout","compute","module","createShaderModule","code","entryPoint","outputBuffer","makeBufferWithContents","Uint32Array","length","_i","GPUBufferUsage","STORAGE","COPY_SRC","bindGroup","createBindGroup","getBindGroupLayout","entries","binding","resource","buffer","encoder","globalThis","_TRAMPOLINE_","createCommandEncoder","pass","beginComputePass","setPipeline","setBindGroup","dispatchWorkgroups","end","queue","submit","finish","expectGPUBufferValuesEqual","test","desc","fn","beforeAllSubcases","selectDeviceOrSkipTestCase","params","u","combine","beginSubcases","cols","columns","use_struct","f_values","Float32Array","u_values","c","i"],"sources":["../../../../src/webgpu/shader/execution/padding.spec.ts"],"sourcesContent":["/**\n* AUTO-GENERATED - DO NOT EDIT. Source: https://github.com/gpuweb/cts\n**/export const description = `\nExecution Tests for preservation of padding bytes in structures and arrays.\n`;import { makeTestGroup } from '../../../common/framework/test_group.js';\nimport { iterRange } from '../../../common/util/util.js';\nimport { GPUTest } from '../../gpu_test.js';\n\nexport const g = makeTestGroup(GPUTest);\n\n/**\n * Run a shader and check that the buffer output matches expectations.\n *\n * @param t The test object\n * @param wgsl The shader source\n * @param expected The array of expected values after running the shader\n */\nfunction runShaderTest(t, wgsl, expected) {\n  const pipeline = t.device.createComputePipeline({\n    layout: 'auto',\n    compute: {\n      module: t.device.createShaderModule({ code: wgsl }),\n      entryPoint: 'main'\n    }\n  });\n\n  // Allocate a buffer and fill it with 0xdeadbeef words.\n  const outputBuffer = t.makeBufferWithContents(\n    new Uint32Array([...iterRange(expected.length, (_i) => 0xdeadbeef)]),\n    GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC\n  );\n  const bindGroup = t.device.createBindGroup({\n    layout: pipeline.getBindGroupLayout(0),\n    entries: [{ binding: 0, resource: { buffer: outputBuffer } }]\n  });\n\n  // Run the shader.\n  const encoder = globalThis._TRAMPOLINE_(\"createCommandEncoder\", t.device, t.device.createCommandEncoder, [], () => t.device.createCommandEncoder());\n  const pass = encoder.beginComputePass();\n  pass.setPipeline(pipeline);\n  pass.setBindGroup(0, bindGroup);\n  pass.dispatchWorkgroups(1);\n  pass.end();\n  globalThis._TRAMPOLINE_(\"submit\", t, t.queue.submit, [[encoder.finish()]], () => t.queue.submit([encoder.finish()]));\n\n  // Check that only the non-padding bytes were modified.\n  t.expectGPUBufferValuesEqual(outputBuffer, expected);\n}\n\ng.test('struct_implicit').\ndesc(\n  `Test that padding bytes in between structure members are preserved.\n\n     This test defines a structure that has implicit padding and creates a read-write storage\n     buffer with that structure type. The shader assigns the whole variable at once, and we\n     then test that data in the padding bytes was preserved.\n    `\n).\nfn((t) => {\n  const wgsl = `\n      struct S {\n        a : u32,\n        // 12 bytes of padding\n        b : vec3<u32>,\n        // 4 bytes of padding\n        c : vec2<u32>,\n        // 8 bytes of padding\n      }\n      @group(0) @binding(0) var<storage, read_write> buffer : S;\n\n      @compute @workgroup_size(1)\n      fn main() {\n        buffer = S(0x12345678, vec3(0xabcdef01), vec2(0x98765432));\n      }\n    `;\n  runShaderTest(\n    t,\n    wgsl,\n    new Uint32Array([\n    // a : u32\n    0x12345678, 0xdeadbeef, 0xdeadbeef, 0xdeadbeef,\n    // b : vec3<u32>\n    0xabcdef01, 0xabcdef01, 0xabcdef01, 0xdeadbeef,\n    // c : vec2<u32>\n    0x98765432, 0x98765432, 0xdeadbeef, 0xdeadbeef]\n    )\n  );\n});\n\ng.test('struct_explicit').\ndesc(\n  `Test that padding bytes in between structure members are preserved.\n\n     This test defines a structure with explicit padding attributes and creates a read-write storage\n     buffer with that structure type. The shader assigns the whole variable at once, and we\n     then test that data in the padding bytes was preserved.\n    `\n).\nfn((t) => {\n  const wgsl = `\n      struct S {\n        a : u32,\n        // 12 bytes of padding\n        @align(16) @size(20) b : u32,\n        // 16 bytes of padding\n        @size(12) c : u32,\n        // 8 bytes of padding\n      }\n      @group(0) @binding(0) var<storage, read_write> buffer : S;\n\n      @compute @workgroup_size(1)\n      fn main() {\n        buffer = S(0x12345678, 0xabcdef01, 0x98765432);\n      }\n    `;\n  runShaderTest(\n    t,\n    wgsl,\n    new Uint32Array([\n    // a : u32\n    0x12345678, 0xdeadbeef, 0xdeadbeef, 0xdeadbeef,\n    // @align(16) @size(20) b : u32\n    0xabcdef01, 0xdeadbeef, 0xdeadbeef, 0xdeadbeef, 0xdeadbeef,\n    // @size(12) c : u32\n    0x98765432, 0xdeadbeef, 0xdeadbeef]\n    )\n  );\n});\n\ng.test('struct_nested').\ndesc(\n  `Test that padding bytes in nested structures are preserved.\n\n     This test defines a set of nested structures that have padding and creates a read-write storage\n     buffer with the root structure type. The shader assigns the whole variable at once, and we\n     then test that data in the padding bytes was preserved.\n    `\n).\nfn((t) => {\n  const wgsl = `\n      // Size of S1 is 48 bytes.\n      // Alignment of S1 is 16 bytes.\n      struct S1 {\n        a : u32,\n        // 12 bytes of padding\n        b : vec3<u32>,\n        // 4 bytes of padding\n        c : vec2<u32>,\n        // 8 bytes of padding\n      }\n\n      // Size of S2 is 112 bytes.\n      // Alignment of S2 is 48 bytes.\n      struct S2 {\n        a2 : u32,\n        // 12 bytes of padding\n        b2 : S1,\n        c2 : S1,\n      }\n\n      // Size of S3 is 144 bytes.\n      // Alignment of S3 is 48 bytes.\n      struct S3 {\n        a3 : S1,\n        b3 : S2,\n        c3 : S2,\n      }\n\n      @group(0) @binding(0) var<storage, read_write> buffer : S3;\n\n      @compute @workgroup_size(1)\n      fn main() {\n        buffer = S3();\n      }\n    `;\n  runShaderTest(\n    t,\n    wgsl,\n    new Uint32Array([\n    // a3 : S1\n    // a3.a1 : u32\n    0x00000000, 0xdeadbeef, 0xdeadbeef, 0xdeadbeef,\n    // a3.b1 : vec3<u32>\n    0x00000000, 0x00000000, 0x00000000, 0xdeadbeef,\n    // a3.c1 : vec2<u32>\n    0x00000000, 0x00000000, 0xdeadbeef, 0xdeadbeef,\n\n    // b3 : S2\n    // b3.a2 : u32\n    0x00000000, 0xdeadbeef, 0xdeadbeef, 0xdeadbeef,\n    // b3.b2 : S1\n    // b3.b2.a1 : u32\n    0x00000000, 0xdeadbeef, 0xdeadbeef, 0xdeadbeef,\n    // b3.b2.b1 : vec3<u32>\n    0x00000000, 0x00000000, 0x00000000, 0xdeadbeef,\n    // b3.b2.c1 : vec2<u32>\n    0x00000000, 0x00000000, 0xdeadbeef, 0xdeadbeef,\n    // b3.c2 : S1\n    // b3.c2.a1 : u32\n    0x00000000, 0xdeadbeef, 0xdeadbeef, 0xdeadbeef,\n    // b3.c2.b1 : vec3<u32>\n    0x00000000, 0x00000000, 0x00000000, 0xdeadbeef,\n    // b3.c2.c1 : vec2<u32>\n    0x00000000, 0x00000000, 0xdeadbeef, 0xdeadbeef,\n\n    // c3 : S2\n    // c3.a2 : u32\n    0x00000000, 0xdeadbeef, 0xdeadbeef, 0xdeadbeef,\n    // c3.b2 : S1\n    // c3.b2.a1 : u32\n    0x00000000, 0xdeadbeef, 0xdeadbeef, 0xdeadbeef,\n    // c3.b2.b1 : vec3<u32>\n    0x00000000, 0x00000000, 0x00000000, 0xdeadbeef,\n    // c3.b2.c1 : vec2<u32>\n    0x00000000, 0x00000000, 0xdeadbeef, 0xdeadbeef,\n    // c3.c2 : S1\n    // c3.c2.a1 : u32\n    0x00000000, 0xdeadbeef, 0xdeadbeef, 0xdeadbeef,\n    // c3.c2.b1 : vec3<u32>\n    0x00000000, 0x00000000, 0x00000000, 0xdeadbeef,\n    // c3.c2.c1 : vec2<u32>\n    0x00000000, 0x00000000, 0xdeadbeef, 0xdeadbeef]\n    )\n  );\n});\n\ng.test('array_of_vec3').\ndesc(\n  `Test that padding bytes in between array elements are preserved.\n\n     This test defines creates a read-write storage buffer with type array<vec3, 4>. The shader\n     assigns the whole variable at once, and we then test that data in the padding bytes was\n     preserved.\n    `\n).\nfn((t) => {\n  const wgsl = `\n      @group(0) @binding(0) var<storage, read_write> buffer : array<vec3<u32>, 4>;\n\n      @compute @workgroup_size(1)\n      fn main() {\n        buffer = array<vec3<u32>, 4>(\n          vec3(0x12345678),\n          vec3(0xabcdef01),\n          vec3(0x98765432),\n          vec3(0x0f0f0f0f),\n        );\n      }\n    `;\n  runShaderTest(\n    t,\n    wgsl,\n    new Uint32Array([\n    // buffer[0]\n    0x12345678, 0x12345678, 0x12345678, 0xdeadbeef,\n    // buffer[1]\n    0xabcdef01, 0xabcdef01, 0xabcdef01, 0xdeadbeef,\n    // buffer[2]\n    0x98765432, 0x98765432, 0x98765432, 0xdeadbeef,\n    // buffer[2]\n    0x0f0f0f0f, 0x0f0f0f0f, 0x0f0f0f0f, 0xdeadbeef]\n    )\n  );\n});\n\ng.test('array_of_vec3h').\ndesc(\n  `Test that padding bytes in between array elements are preserved when f16 elements are used.\n\n     This test defines creates a read-write storage buffer with type array<vec3h, 4>. The shader\n     assigns the whole variable at once, and we then test that data in the padding bytes was\n     preserved.\n    `\n).\nbeforeAllSubcases((t) => {\n  t.selectDeviceOrSkipTestCase('shader-f16');\n}).\nfn((t) => {\n  const wgsl = `\n      enable f16;\n      @group(0) @binding(0) var<storage, read_write> buffer : array<vec3<f16>, 4>;\n\n      @compute @workgroup_size(1)\n      fn main() {\n        buffer = array<vec3<f16>, 4>(\n          vec3(1h),\n          vec3(2h),\n          vec3(3h),\n          vec3(4h),\n        );\n      }\n    `;\n  runShaderTest(\n    t,\n    wgsl,\n    new Uint32Array([\n    // buffer[0]\n    0x3c003c00, 0xdead3c00,\n    // buffer[1]\n    0x40004000, 0xdead4000,\n    // buffer[2]\n    0x42004200, 0xdead4200,\n    // buffer[2]\n    0x44004400, 0xdead4400]\n    )\n  );\n});\n\ng.test('array_of_vec3h,elementwise').\ndesc(\n  `Test that padding bytes in between array elements are preserved when f16 elements are used.\n\n     This test defines creates a read-write storage buffer with type array<vec3h, 4>. The shader\n     assigns one element per thread, and we then test that data in the padding bytes was\n     preserved.\n    `\n).\nbeforeAllSubcases((t) => {\n  t.selectDeviceOrSkipTestCase('shader-f16');\n}).\nfn((t) => {\n  const wgsl = `\n      enable f16;\n      @group(0) @binding(0) var<storage, read_write> buffer : array<vec3<f16>>;\n\n      @compute @workgroup_size(4)\n      fn main(@builtin(local_invocation_index) lid : u32) {\n        buffer[lid] = vec3h(f16(lid + 1));\n      }\n    `;\n  runShaderTest(\n    t,\n    wgsl,\n    new Uint32Array([\n    // buffer[0]\n    0x3c003c00, 0xdead3c00,\n    // buffer[1]\n    0x40004000, 0xdead4000,\n    // buffer[2]\n    0x42004200, 0xdead4200,\n    // buffer[2]\n    0x44004400, 0xdead4400]\n    )\n  );\n});\n\ng.test('array_of_struct').\ndesc(\n  `Test that padding bytes in between array elements are preserved.\n\n     This test defines creates a read-write storage buffer with type array<S, 4>, where S is a\n     structure that contains padding bytes. The shader assigns the whole variable at once, and we\n     then test that data in the padding bytes was preserved.\n    `\n).\nfn((t) => {\n  const wgsl = `\n      struct S {\n        a : u32,\n        b : vec3<u32>,\n      }\n      @group(0) @binding(0) var<storage, read_write> buffer : array<S, 3>;\n\n      @compute @workgroup_size(1)\n      fn main() {\n        buffer = array<S, 3>(\n          S(0x12345678, vec3(0x0f0f0f0f)),\n          S(0xabcdef01, vec3(0x7c7c7c7c)),\n          S(0x98765432, vec3(0x18181818)),\n        );\n      }\n    `;\n  runShaderTest(\n    t,\n    wgsl,\n    new Uint32Array([\n    // buffer[0]\n    0x12345678, 0xdeadbeef, 0xdeadbeef, 0xdeadbeef, 0x0f0f0f0f, 0x0f0f0f0f, 0x0f0f0f0f,\n    0xdeadbeef,\n    // buffer[1]\n    0xabcdef01, 0xdeadbeef, 0xdeadbeef, 0xdeadbeef, 0x7c7c7c7c, 0x7c7c7c7c, 0x7c7c7c7c,\n    0xdeadbeef,\n    // buffer[2]\n    0x98765432, 0xdeadbeef, 0xdeadbeef, 0xdeadbeef, 0x18181818, 0x18181818, 0x18181818,\n    0xdeadbeef]\n    )\n  );\n});\n\ng.test('vec3').\ndesc(\n  `Test padding bytes are preserved when assigning to a variable of type vec3 (without a struct).\n    `\n).\nfn((t) => {\n  const wgsl = `\n      @group(0) @binding(0) var<storage, read_write> buffer : vec3<u32>;\n\n      @compute @workgroup_size(1)\n      fn main() {\n        buffer = vec3<u32>(0x12345678, 0xabcdef01, 0x98765432);\n      }\n    `;\n  runShaderTest(t, wgsl, new Uint32Array([0x12345678, 0xabcdef01, 0x98765432, 0xdeadbeef]));\n});\n\ng.test('matCx3').\ndesc(\n  `Test padding bytes are preserved when assigning to a variable of type matCx3.\n    `\n).\nparams((u) =>\nu.\ncombine('columns', [2, 3, 4]).\ncombine('use_struct', [true, false]).\nbeginSubcases()\n).\nfn((t) => {\n  const cols = t.params.columns;\n  const wgsl = `\n      alias Mat = mat${cols}x3<f32>;\n      ${t.params.use_struct ? `struct S { m : Mat } alias Type = S;` : `alias Type = Mat;`}\n      @group(0) @binding(0) var<storage, read_write> buffer : Type;\n\n      @compute @workgroup_size(1)\n      fn main() {\n        var m : Mat;\n        for (var c = 0u; c < ${cols}; c++) {\n          m[c] = vec3(f32(c*3 + 1), f32(c*3 + 2), f32(c*3 + 3));\n        }\n        buffer = Type(m);\n      }\n    `;\n  const f_values = new Float32Array(cols * 4);\n  const u_values = new Uint32Array(f_values.buffer);\n  for (let c = 0; c < cols; c++) {\n    f_values[c * 4 + 0] = c * 3 + 1;\n    f_values[c * 4 + 1] = c * 3 + 2;\n    f_values[c * 4 + 2] = c * 3 + 3;\n    u_values[c * 4 + 3] = 0xdeadbeef;\n  }\n  runShaderTest(t, wgsl, u_values);\n});\n\ng.test('array_of_matCx3').\ndesc(\n  `Test that padding bytes in between array elements are preserved.\n\n     This test defines creates a read-write storage buffer with type array<matCx3<f32>, 4>. The\n     shader assigns the whole variable at once, and we then test that data in the padding bytes was\n     preserved.\n    `\n).\nparams((u) =>\nu.\ncombine('columns', [2, 3, 4]).\ncombine('use_struct', [true, false]).\nbeginSubcases()\n).\nfn((t) => {\n  const cols = t.params.columns;\n  const wgsl = `\n    alias Mat = mat${cols}x3<f32>;\n    ${t.params.use_struct ? `struct S { m : Mat } alias Type = S;` : `alias Type = Mat;`}\n    @group(0) @binding(0) var<storage, read_write> buffer : array<Type, 4>;\n\n    @compute @workgroup_size(1)\n    fn main() {\n      var m : Mat;\n      for (var c = 0u; c < ${cols}; c++) {\n        m[c] = vec3(f32(c*3 + 1), f32(c*3 + 2), f32(c*3 + 3));\n      }\n      buffer = array<Type, 4>(Type(m), Type(m * 2), Type(m * 3), Type(m * 4));\n    }\n  `;\n  const f_values = new Float32Array(cols * 4 * 4);\n  const u_values = new Uint32Array(f_values.buffer);\n  for (let i = 0; i < 4; i++) {\n    for (let c = 0; c < cols; c++) {\n      f_values[i * (cols * 4) + c * 4 + 0] = (c * 3 + 1) * (i + 1);\n      f_values[i * (cols * 4) + c * 4 + 1] = (c * 3 + 2) * (i + 1);\n      f_values[i * (cols * 4) + c * 4 + 2] = (c * 3 + 3) * (i + 1);\n      u_values[i * (cols * 4) + c * 4 + 3] = 0xdeadbeef;\n    }\n  }\n  runShaderTest(t, wgsl, u_values);\n});"],"mappings":";;IAAA;AACA;AACA,GAAG,OAAO,MAAMA,WAAW,GAAG;AAC9B;AACA,CAAC,CAAC,SAASC,aAAa,QAAQ,yCAAyC,CACzE,SAASC,SAAS,QAAQ,8BAA8B,CACxD,SAASC,OAAO,QAAQ,mBAAmB;;AAE3C,OAAO,MAAMC,CAAC,GAAGH,aAAa,CAACE,OAAO,CAAC;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASE,aAAaA,CAACC,CAAC,EAAEC,IAAI,EAAEC,QAAQ,EAAE;EACxC,MAAMC,QAAQ,GAAGH,CAAC,CAACI,MAAM,CAACC,qBAAqB,CAAC;IAC9CC,MAAM,EAAE,MAAM;IACdC,OAAO,EAAE;MACPC,MAAM,EAAER,CAAC,CAACI,MAAM,CAACK,kBAAkB,CAAC,EAAEC,IAAI,EAAET,IAAI,CAAC,CAAC,CAAC;MACnDU,UAAU,EAAE;IACd;EACF,CAAC,CAAC;;EAEF;EACA,MAAMC,YAAY,GAAGZ,CAAC,CAACa,sBAAsB;IAC3C,IAAIC,WAAW,CAAC,CAAC,GAAGlB,SAAS,CAACM,QAAQ,CAACa,MAAM,EAAE,CAACC,EAAE,KAAK,UAAU,CAAC,CAAC,CAAC;IACpEC,cAAc,CAACC,OAAO,GAAGD,cAAc,CAACE;EAC1C,CAAC;EACD,MAAMC,SAAS,GAAGpB,CAAC,CAACI,MAAM,CAACiB,eAAe,CAAC;IACzCf,MAAM,EAAEH,QAAQ,CAACmB,kBAAkB,CAAC,CAAC,CAAC;IACtCC,OAAO,EAAE,CAAC,EAAEC,OAAO,EAAE,CAAC,EAAEC,QAAQ,EAAE,EAAEC,MAAM,EAAEd,YAAY,CAAC,CAAC,CAAC,CAAC;EAC9D,CAAC,CAAC;;EAEF;EACA,MAAMe,OAAO,GAAGC,UAAU,CAACC,YAAY,CAAC,sBAAsB,EAAE7B,CAAC,CAACI,MAAM,EAAEJ,CAAC,CAACI,MAAM,CAAC0B,oBAAoB,EAAE,EAAE,EAAE,MAAAF,UAAA,CAAAC,YAAA,yBAAM7B,CAAC,CAACI,MAAM,EAARJ,CAAC,CAACI,MAAM,CAAA0B,oBAAA,YAAR9B,CAAC,CAACI,MAAM,CAAC0B,oBAAoB,GAAE,CAAC;EACnJ,MAAMC,IAAI,GAAGJ,OAAO,CAACK,gBAAgB,CAAC,CAAC;EACvCD,IAAI,CAACE,WAAW,CAAC9B,QAAQ,CAAC;EAC1B4B,IAAI,CAACG,YAAY,CAAC,CAAC,EAAEd,SAAS,CAAC;EAC/BW,IAAI,CAACI,kBAAkB,CAAC,CAAC,CAAC;EAC1BJ,IAAI,CAACK,GAAG,CAAC,CAAC;EACVR,UAAU,CAACC,YAAY,CAAC,QAAQ,EAAE7B,CAAC,EAAEA,CAAC,CAACqC,KAAK,CAACC,MAAM,EAAE,CAAC,CAACX,OAAO,CAACY,MAAM,CAAC,CAAC,CAAC,CAAC,EAAE,MAAAX,UAAA,CAAAC,YAAA,WAAM7B,CAAC,EAADA,CAAC,CAACqC,KAAK,CAAAC,MAAA,GAAQ,CAACX,OAAO,CAACY,MAAM,CAAC,CAAC,CAAC,SAAjCvC,CAAC,CAACqC,KAAK,CAACC,MAAM,CAAC,CAACX,OAAO,CAACY,MAAM,CAAC,CAAC,CAAC,EAAC,CAAC;;EAEpH;EACAvC,CAAC,CAACwC,0BAA0B,CAAC5B,YAAY,EAAEV,QAAQ,CAAC;AACtD;;AAEAJ,CAAC,CAAC2C,IAAI,CAAC,iBAAiB,CAAC;AACzBC,IAAI;EACF;AACF;AACA;AACA;AACA;AACA;AACA,CAAC;AACDC,EAAE,CAAC,CAAC3C,CAAC,KAAK;EACR,MAAMC,IAAI,GAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;EACHF,aAAa;IACXC,CAAC;IACDC,IAAI;IACJ,IAAIa,WAAW,CAAC;IAChB;IACA,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IAC9C;IACA,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IAC9C;IACA,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IAC9C;EACF,CAAC;AACH,CAAC,CAAC;;AAEFhB,CAAC,CAAC2C,IAAI,CAAC,iBAAiB,CAAC;AACzBC,IAAI;EACF;AACF;AACA;AACA;AACA;AACA;AACA,CAAC;AACDC,EAAE,CAAC,CAAC3C,CAAC,KAAK;EACR,MAAMC,IAAI,GAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;EACHF,aAAa;IACXC,CAAC;IACDC,IAAI;IACJ,IAAIa,WAAW,CAAC;IAChB;IACA,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IAC9C;IACA,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IAC1D;IACA,UAAU,EAAE,UAAU,EAAE,UAAU;IAClC;EACF,CAAC;AACH,CAAC,CAAC;;AAEFhB,CAAC,CAAC2C,IAAI,CAAC,eAAe,CAAC;AACvBC,IAAI;EACF;AACF;AACA;AACA;AACA;AACA;AACA,CAAC;AACDC,EAAE,CAAC,CAAC3C,CAAC,KAAK;EACR,MAAMC,IAAI,GAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;EACHF,aAAa;IACXC,CAAC;IACDC,IAAI;IACJ,IAAIa,WAAW,CAAC;IAChB;IACA;IACA,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IAC9C;IACA,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IAC9C;IACA,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;;IAE9C;IACA;IACA,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IAC9C;IACA;IACA,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IAC9C;IACA,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IAC9C;IACA,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IAC9C;IACA;IACA,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IAC9C;IACA,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IAC9C;IACA,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;;IAE9C;IACA;IACA,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IAC9C;IACA;IACA,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IAC9C;IACA,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IAC9C;IACA,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IAC9C;IACA;IACA,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IAC9C;IACA,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IAC9C;IACA,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IAC9C;EACF,CAAC;AACH,CAAC,CAAC;;AAEFhB,CAAC,CAAC2C,IAAI,CAAC,eAAe,CAAC;AACvBC,IAAI;EACF;AACF;AACA;AACA;AACA;AACA;AACA,CAAC;AACDC,EAAE,CAAC,CAAC3C,CAAC,KAAK;EACR,MAAMC,IAAI,GAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;EACHF,aAAa;IACXC,CAAC;IACDC,IAAI;IACJ,IAAIa,WAAW,CAAC;IAChB;IACA,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IAC9C;IACA,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IAC9C;IACA,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IAC9C;IACA,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IAC9C;EACF,CAAC;AACH,CAAC,CAAC;;AAEFhB,CAAC,CAAC2C,IAAI,CAAC,gBAAgB,CAAC;AACxBC,IAAI;EACF;AACF;AACA;AACA;AACA;AACA;AACA,CAAC;AACDE,iBAAiB,CAAC,CAAC5C,CAAC,KAAK;EACvBA,CAAC,CAAC6C,0BAA0B,CAAC,YAAY,CAAC;AAC5C,CAAC,CAAC;AACFF,EAAE,CAAC,CAAC3C,CAAC,KAAK;EACR,MAAMC,IAAI,GAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;EACHF,aAAa;IACXC,CAAC;IACDC,IAAI;IACJ,IAAIa,WAAW,CAAC;IAChB;IACA,UAAU,EAAE,UAAU;IACtB;IACA,UAAU,EAAE,UAAU;IACtB;IACA,UAAU,EAAE,UAAU;IACtB;IACA,UAAU,EAAE,UAAU;IACtB;EACF,CAAC;AACH,CAAC,CAAC;;AAEFhB,CAAC,CAAC2C,IAAI,CAAC,4BAA4B,CAAC;AACpCC,IAAI;EACF;AACF;AACA;AACA;AACA;AACA;AACA,CAAC;AACDE,iBAAiB,CAAC,CAAC5C,CAAC,KAAK;EACvBA,CAAC,CAAC6C,0BAA0B,CAAC,YAAY,CAAC;AAC5C,CAAC,CAAC;AACFF,EAAE,CAAC,CAAC3C,CAAC,KAAK;EACR,MAAMC,IAAI,GAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;EACHF,aAAa;IACXC,CAAC;IACDC,IAAI;IACJ,IAAIa,WAAW,CAAC;IAChB;IACA,UAAU,EAAE,UAAU;IACtB;IACA,UAAU,EAAE,UAAU;IACtB;IACA,UAAU,EAAE,UAAU;IACtB;IACA,UAAU,EAAE,UAAU;IACtB;EACF,CAAC;AACH,CAAC,CAAC;;AAEFhB,CAAC,CAAC2C,IAAI,CAAC,iBAAiB,CAAC;AACzBC,IAAI;EACF;AACF;AACA;AACA;AACA;AACA;AACA,CAAC;AACDC,EAAE,CAAC,CAAC3C,CAAC,KAAK;EACR,MAAMC,IAAI,GAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;EACHF,aAAa;IACXC,CAAC;IACDC,IAAI;IACJ,IAAIa,WAAW,CAAC;IAChB;IACA,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IAClF,UAAU;IACV;IACA,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IAClF,UAAU;IACV;IACA,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;IAClF,UAAU;IACV;EACF,CAAC;AACH,CAAC,CAAC;;AAEFhB,CAAC,CAAC2C,IAAI,CAAC,MAAM,CAAC;AACdC,IAAI;EACF;AACF;AACA,CAAC;AACDC,EAAE,CAAC,CAAC3C,CAAC,KAAK;EACR,MAAMC,IAAI,GAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;EACHF,aAAa,CAACC,CAAC,EAAEC,IAAI,EAAE,IAAIa,WAAW,CAAC,CAAC,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,CAAC,CAAC,CAAC;AAC3F,CAAC,CAAC;;AAEFhB,CAAC,CAAC2C,IAAI,CAAC,QAAQ,CAAC;AAChBC,IAAI;EACF;AACF;AACA,CAAC;AACDI,MAAM,CAAC,CAACC,CAAC;AACTA,CAAC;AACDC,OAAO,CAAC,SAAS,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;AAC7BA,OAAO,CAAC,YAAY,EAAE,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;AACpCC,aAAa,CAAC;AACd,CAAC;AACDN,EAAE,CAAC,CAAC3C,CAAC,KAAK;EACR,MAAMkD,IAAI,GAAGlD,CAAC,CAAC8C,MAAM,CAACK,OAAO;EAC7B,MAAMlD,IAAI,GAAG;AACf,uBAAuBiD,IAAI;AAC3B,QAAQlD,CAAC,CAAC8C,MAAM,CAACM,UAAU,GAAG,sCAAsC,GAAG,mBAAmB;AAC1F;AACA;AACA;AACA;AACA;AACA,+BAA+BF,IAAI;AACnC;AACA;AACA;AACA;AACA,KAAK;EACH,MAAMG,QAAQ,GAAG,IAAIC,YAAY,CAACJ,IAAI,GAAG,CAAC,CAAC;EAC3C,MAAMK,QAAQ,GAAG,IAAIzC,WAAW,CAACuC,QAAQ,CAAC3B,MAAM,CAAC;EACjD,KAAK,IAAI8B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGN,IAAI,EAAEM,CAAC,EAAE,EAAE;IAC7BH,QAAQ,CAACG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,GAAGA,CAAC,GAAG,CAAC,GAAG,CAAC;IAC/BH,QAAQ,CAACG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,GAAGA,CAAC,GAAG,CAAC,GAAG,CAAC;IAC/BH,QAAQ,CAACG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,GAAGA,CAAC,GAAG,CAAC,GAAG,CAAC;IAC/BD,QAAQ,CAACC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,GAAG,UAAU;EAClC;EACAzD,aAAa,CAACC,CAAC,EAAEC,IAAI,EAAEsD,QAAQ,CAAC;AAClC,CAAC,CAAC;;AAEFzD,CAAC,CAAC2C,IAAI,CAAC,iBAAiB,CAAC;AACzBC,IAAI;EACF;AACF;AACA;AACA;AACA;AACA;AACA,CAAC;AACDI,MAAM,CAAC,CAACC,CAAC;AACTA,CAAC;AACDC,OAAO,CAAC,SAAS,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;AAC7BA,OAAO,CAAC,YAAY,EAAE,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;AACpCC,aAAa,CAAC;AACd,CAAC;AACDN,EAAE,CAAC,CAAC3C,CAAC,KAAK;EACR,MAAMkD,IAAI,GAAGlD,CAAC,CAAC8C,MAAM,CAACK,OAAO;EAC7B,MAAMlD,IAAI,GAAG;AACf,qBAAqBiD,IAAI;AACzB,MAAMlD,CAAC,CAAC8C,MAAM,CAACM,UAAU,GAAG,sCAAsC,GAAG,mBAAmB;AACxF;AACA;AACA;AACA;AACA;AACA,6BAA6BF,IAAI;AACjC;AACA;AACA;AACA;AACA,GAAG;EACD,MAAMG,QAAQ,GAAG,IAAIC,YAAY,CAACJ,IAAI,GAAG,CAAC,GAAG,CAAC,CAAC;EAC/C,MAAMK,QAAQ,GAAG,IAAIzC,WAAW,CAACuC,QAAQ,CAAC3B,MAAM,CAAC;EACjD,KAAK,IAAI+B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;IAC1B,KAAK,IAAID,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGN,IAAI,EAAEM,CAAC,EAAE,EAAE;MAC7BH,QAAQ,CAACI,CAAC,IAAIP,IAAI,GAAG,CAAC,CAAC,GAAGM,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,GAAG,CAACA,CAAC,GAAG,CAAC,GAAG,CAAC,KAAKC,CAAC,GAAG,CAAC,CAAC;MAC5DJ,QAAQ,CAACI,CAAC,IAAIP,IAAI,GAAG,CAAC,CAAC,GAAGM,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,GAAG,CAACA,CAAC,GAAG,CAAC,GAAG,CAAC,KAAKC,CAAC,GAAG,CAAC,CAAC;MAC5DJ,QAAQ,CAACI,CAAC,IAAIP,IAAI,GAAG,CAAC,CAAC,GAAGM,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,GAAG,CAACA,CAAC,GAAG,CAAC,GAAG,CAAC,KAAKC,CAAC,GAAG,CAAC,CAAC;MAC5DF,QAAQ,CAACE,CAAC,IAAIP,IAAI,GAAG,CAAC,CAAC,GAAGM,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,GAAG,UAAU;IACnD;EACF;EACAzD,aAAa,CAACC,CAAC,EAAEC,IAAI,EAAEsD,QAAQ,CAAC;AAClC,CAAC,CAAC","ignoreList":[]}