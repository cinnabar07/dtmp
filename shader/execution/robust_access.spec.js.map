{"version":3,"file":"robust_access.spec.js","names":["description","makeTestGroup","assert","Float16Array","GPUTest","align","generateTypes","supportedScalarTypes","supportsAtomics","g","kMaxU32","kMaxI32","kMinI32","runShaderTest","t","enables","stage","testSource","layout","testBindings","dynamicOffsets","GPUShaderStage","COMPUTE","constantsBuffer","createBufferTracked","size","usage","GPUBufferUsage","UNIFORM","resultBuffer","COPY_SRC","STORAGE","source","debug","module","device","createShaderModule","code","pipeline","createComputePipelineAsync","compute","entryPoint","group","createBindGroup","getBindGroupLayout","entries","binding","resource","buffer","testGroup","encoder","globalThis","_TRAMPOLINE_","createCommandEncoder","pass","beginComputePass","setPipeline","setBindGroup","dispatchWorkgroups","end","queue","submit","finish","expectGPUBufferValuesEqual","Uint32Array","testFillArrayBuffer","array","type","zeroByteStart","zeroByteCount","constructor","u32","i32","Int32Array","f16","f32","Float32Array","BYTES_PER_ELEMENT","fill","test","desc","params","u","combineWithParams","addressSpace","storageMode","access","dynamicOffset","containerType","shadowingMode","expand","p","beginSubcases","expandWithParams","beforeAllSubcases","baseType","selectDeviceOrSkipTestCase","fn","isAtomic","_kTypeInfo","undefined","usesCanary","globalSource","testFunctionSource","testBufferSize","bufferBindingOffset","bufferBindingSize","structDecl","testGroupBGLEntires","alignment","qualifiers","push","visibility","hasDynamicOffset","nextErrorReturnValue","errorReturnValue","toString","indexSigned","indicesToTest","arrayLength","indexTypeLiteral","indexTypeCast","exprIndexAddon","indexToTest","exprZeroElement","elementBaseType","exprElement","suffices","accessSuffixes","exprLoadElement","conditions","map","x","c","forEach","moduleScopeShadowDecls","functionScopeShadowDecls","createPipelineLayout","bindGroupLayouts","createBindGroupLayout","expectedData","ArrayBuffer","bufferBindingEnd","testBuffer","makeBufferWithContents","Uint8Array","COPY_DST","offset","expectedBytes","subarray"],"sources":["../../../../src/webgpu/shader/execution/robust_access.spec.ts"],"sourcesContent":["/**\n* AUTO-GENERATED - DO NOT EDIT. Source: https://github.com/gpuweb/cts\n**/export const description = `\nTests to check datatype clamping in shaders is correctly implemented for all indexable types\n(vectors, matrices, sized/unsized arrays) visible to shaders in various ways.\n\nTODO: add tests to check that textureLoad operations stay in-bounds.\n`;import { makeTestGroup } from '../../../common/framework/test_group.js';\nimport { assert } from '../../../common/util/util.js';\nimport { Float16Array } from '../../../external/petamoriken/float16/float16.js';\nimport { GPUTest } from '../../gpu_test.js';\nimport { align } from '../../util/math.js';\nimport { generateTypes, supportedScalarTypes, supportsAtomics } from '../types.js';\n\nexport const g = makeTestGroup(GPUTest);\n\nconst kMaxU32 = 0xffff_ffff;\nconst kMaxI32 = 0x7fff_ffff;\nconst kMinI32 = -0x8000_0000;\n\n/**\n * Wraps the provided source into a harness that checks calling `runTest()` returns 0.\n *\n * Non-test bindings are in bind group 1, including:\n * - `constants.zero`: a dynamically-uniform `0u` value.\n */\nasync function runShaderTest(\nt,\nenables,\nstage,\ntestSource,\nlayout,\ntestBindings,\ndynamicOffsets)\n{\n  assert(stage === GPUShaderStage.COMPUTE, 'Only know how to deal with compute for now');\n\n  // Contains just zero (for now).\n  const constantsBuffer = t.createBufferTracked({ size: 4, usage: GPUBufferUsage.UNIFORM });\n\n  const resultBuffer = t.createBufferTracked({\n    size: 4,\n    usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.STORAGE\n  });\n\n  const source = `${enables}\nstruct Constants {\n  zero: u32\n};\n@group(1) @binding(0) var<uniform> constants: Constants;\n\nstruct Result {\n  value: u32\n};\n@group(1) @binding(1) var<storage, read_write> result: Result;\n\n${testSource}\n\n@compute @workgroup_size(1)\nfn main() {\n  _ = constants.zero; // Ensure constants buffer is statically-accessed\n  result.value = runTest();\n}`;\n\n  t.debug(source);\n  const module = t.device.createShaderModule({ code: source });\n  const pipeline = await t.device.createComputePipelineAsync({\n    layout,\n    compute: { module, entryPoint: 'main' }\n  });\n\n  const group = t.device.createBindGroup({\n    layout: pipeline.getBindGroupLayout(1),\n    entries: [\n    { binding: 0, resource: { buffer: constantsBuffer } },\n    { binding: 1, resource: { buffer: resultBuffer } }]\n\n  });\n\n  const testGroup = t.device.createBindGroup({\n    layout: pipeline.getBindGroupLayout(0),\n    entries: testBindings\n  });\n\n  const encoder = globalThis._TRAMPOLINE_(\"createCommandEncoder\", t.device, t.device.createCommandEncoder, [], () => t.device.createCommandEncoder());\n  const pass = encoder.beginComputePass();\n  pass.setPipeline(pipeline);\n  pass.setBindGroup(0, testGroup, dynamicOffsets);\n  pass.setBindGroup(1, group);\n  pass.dispatchWorkgroups(1);\n  pass.end();\n\n  globalThis._TRAMPOLINE_(\"submit\", t, t.queue.submit, [[encoder.finish()]], () => t.queue.submit([encoder.finish()]));\n\n  t.expectGPUBufferValuesEqual(resultBuffer, new Uint32Array([0]));\n}\n\n/** Fill an ArrayBuffer with sentinel values, except clear a region to zero. */\nfunction testFillArrayBuffer(\narray,\ntype,\n{ zeroByteStart, zeroByteCount })\n{\n  const constructor = { u32: Uint32Array, i32: Int32Array, f16: Float16Array, f32: Float32Array }[\n  type];\n\n  assert(zeroByteCount % constructor.BYTES_PER_ELEMENT === 0);\n  new constructor(array).fill(42);\n  new constructor(array, zeroByteStart, zeroByteCount / constructor.BYTES_PER_ELEMENT).fill(0);\n}\n\n/**\n * Generate a bunch of indexable types (vec, mat, sized/unsized array) for testing.\n */\n\ng.test('linear_memory').\ndesc(\n  `For each indexable data type (vec, mat, sized/unsized array, of various scalar types), attempts\n    to access (read, write, atomic load/store) a region of memory (buffer or internal) at various\n    (signed/unsigned) indices. Checks that the accesses conform to robust access (OOB reads only\n    return bound memory, OOB writes don't write OOB).\n\n    TODO: Test in/out storage classes.\n    TODO: Test vertex and fragment stages.\n    TODO: Test using a dynamic offset instead of a static offset into uniform/storage bindings.\n    TODO: Test types like vec2<atomic<i32>>, if that's allowed.\n    TODO: Test exprIndexAddon as constexpr.\n    TODO: Test exprIndexAddon as pipeline-overridable constant expression.\n    TODO: Adjust test logic to support array of f16 in the uniform address space\n  `\n).\nparams((u) =>\nu.\ncombineWithParams([\n{ addressSpace: 'storage', storageMode: 'read', access: 'read', dynamicOffset: false },\n{\n  addressSpace: 'storage',\n  storageMode: 'read_write',\n  access: 'read',\n  dynamicOffset: false\n},\n{\n  addressSpace: 'storage',\n  storageMode: 'read_write',\n  access: 'write',\n  dynamicOffset: false\n},\n{ addressSpace: 'storage', storageMode: 'read', access: 'read', dynamicOffset: true },\n{ addressSpace: 'storage', storageMode: 'read_write', access: 'read', dynamicOffset: true },\n{\n  addressSpace: 'storage',\n  storageMode: 'read_write',\n  access: 'write',\n  dynamicOffset: true\n},\n{ addressSpace: 'uniform', access: 'read', dynamicOffset: false },\n{ addressSpace: 'uniform', access: 'read', dynamicOffset: true },\n{ addressSpace: 'private', access: 'read' },\n{ addressSpace: 'private', access: 'write' },\n{ addressSpace: 'function', access: 'read' },\n{ addressSpace: 'function', access: 'write' },\n{ addressSpace: 'workgroup', access: 'read' },\n{ addressSpace: 'workgroup', access: 'write' }]\n).\ncombineWithParams([\n{ containerType: 'array' },\n{ containerType: 'matrix' },\n{ containerType: 'vector' }]\n).\ncombineWithParams([\n{ shadowingMode: 'none' },\n{ shadowingMode: 'module-scope' },\n{ shadowingMode: 'function-scope' }]\n).\nexpand('isAtomic', (p) => supportsAtomics(p) ? [false, true] : [false]).\nexpand('baseType', supportedScalarTypes).\nbeginSubcases().\nexpandWithParams(generateTypes)\n).\nbeforeAllSubcases((t) => {\n  if (t.params.baseType === 'f16') {\n    t.selectDeviceOrSkipTestCase('shader-f16');\n  }\n}).\nfn(async (t) => {\n  const {\n    addressSpace,\n    storageMode,\n    access,\n    dynamicOffset,\n    isAtomic,\n    containerType,\n    baseType,\n    type,\n    shadowingMode,\n    _kTypeInfo\n  } = t.params;\n\n  assert(_kTypeInfo !== undefined, 'not an indexable type');\n  assert('arrayLength' in _kTypeInfo);\n\n  let usesCanary = false;\n  let globalSource = '';\n  let testFunctionSource = '';\n  const testBufferSize = 512;\n  const bufferBindingOffset = 256;\n  /** Undefined if no buffer binding is needed */\n  let bufferBindingSize = undefined;\n\n  // Declare the data that will be accessed to check robust access, as a buffer or a struct\n  // in the global scope or inside the test function itself.\n  const structDecl = `\nstruct S {\n  startCanary: array<u32, 10>,\n  data: ${type},\n  endCanary: array<u32, 10>,\n};`;\n\n  const testGroupBGLEntires = [];\n  switch (addressSpace) {\n    case 'uniform':\n    case 'storage':\n      {\n        assert(_kTypeInfo.layout !== undefined);\n        const layout = _kTypeInfo.layout;\n        bufferBindingSize = align(layout.size, layout.alignment);\n        const qualifiers = addressSpace === 'storage' ? `storage, ${storageMode}` : addressSpace;\n        globalSource += `\nstruct TestData {\n  data: ${type},\n};\n@group(0) @binding(0) var<${qualifiers}> s: TestData;`;\n\n        testGroupBGLEntires.push({\n          binding: 0,\n          visibility: GPUShaderStage.COMPUTE,\n          buffer: {\n            type:\n            addressSpace === 'uniform' ?\n            'uniform' :\n            storageMode === 'read' ?\n            'read-only-storage' :\n            'storage',\n            hasDynamicOffset: dynamicOffset\n          }\n        });\n      }\n      break;\n\n    case 'private':\n    case 'workgroup':\n      usesCanary = true;\n      globalSource += structDecl;\n      globalSource += `var<${addressSpace}> s: S;`;\n      break;\n\n    case 'function':\n      usesCanary = true;\n      globalSource += structDecl;\n      testFunctionSource += 'var s: S;';\n      break;\n  }\n\n  // Build the test function that will do the tests.\n\n  // If we use a local canary declared in the shader, initialize it.\n  if (usesCanary) {\n    testFunctionSource += `\n  for (var i = 0u; i < 10u; i = i + 1u) {\n    s.startCanary[i] = 0xFFFFFFFFu;\n    s.endCanary[i] = 0xFFFFFFFFu;\n  }`;\n  }\n\n  /** Returns a different number each time, kind of like a `__LINE__` to ID the failing check. */\n  const nextErrorReturnValue = (() => {\n    let errorReturnValue = 0x1000;\n    return () => {\n      ++errorReturnValue;\n      return `0x${errorReturnValue.toString(16)}u`;\n    };\n  })();\n\n  // This is here, instead of in subcases, so only a single shader is needed to test many modes.\n  for (const indexSigned of [false, true]) {\n    const indicesToTest = indexSigned ?\n    [\n    // Exactly in bounds (should be OK)\n    '0',\n    `${_kTypeInfo.arrayLength} - 1`,\n    // Exactly out of bounds\n    '-1',\n    `${_kTypeInfo.arrayLength}`,\n    // Far out of bounds\n    '-1000000',\n    '1000000',\n    `${kMinI32}`,\n    `${kMaxI32}`] :\n\n    [\n    // Exactly in bounds (should be OK)\n    '0u',\n    `${_kTypeInfo.arrayLength}u - 1u`,\n    // Exactly out of bounds\n    `${_kTypeInfo.arrayLength}u`,\n    // Far out of bounds\n    '1000000u',\n    `${kMaxU32}u`,\n    `${kMaxI32}u`];\n\n\n    const indexTypeLiteral = indexSigned ? '0' : '0u';\n    const indexTypeCast = indexSigned ? 'i32' : 'u32';\n    for (const exprIndexAddon of [\n    '', // No addon\n    ` + ${indexTypeLiteral}`, // Add a literal 0\n    ` + ${indexTypeCast}(constants.zero)` // Add a uniform 0\n    ]) {\n      // Produce the accesses to the variable.\n      for (const indexToTest of indicesToTest) {\n        testFunctionSource += `\n  {\n    let index = (${indexToTest})${exprIndexAddon};`;\n        const exprZeroElement = `${_kTypeInfo.elementBaseType}()`;\n        const exprElement = `s.data[index]`;\n        const suffices = _kTypeInfo.accessSuffixes ?? [''];\n        switch (access) {\n          case 'read':\n            {\n              const exprLoadElement = isAtomic ? `atomicLoad(&${exprElement})` : exprElement;\n              let conditions = suffices.map((x) => `${exprLoadElement}${x} != ${exprZeroElement}`);\n              if (containerType === 'matrix') {\n                // The comparison is a vector bool result.\n                // Convert that to a scalar bool.\n                conditions = conditions.map((c) => `any(${c})`);\n              }\n              conditions.forEach((c) => {\n                testFunctionSource += `\n    if (${c}) { return ${nextErrorReturnValue()}; }`;\n              });\n            }\n            break;\n\n          case 'write':\n            if (isAtomic) {\n              testFunctionSource += `\n    atomicStore(&s.data[index], ${exprZeroElement});`;\n            } else {\n              suffices.forEach((x) => {\n                testFunctionSource += `\n    s.data[index]${x} = ${exprZeroElement};`;\n              });\n            }\n            break;\n        }\n        testFunctionSource += `\n  }`;\n      }\n    }\n  }\n\n  // Check that the canaries haven't been modified\n  if (usesCanary) {\n    testFunctionSource += `\n  for (var i = 0u; i < 10u; i = i + 1u) {\n    if (s.startCanary[i] != 0xFFFFFFFFu) {\n      return ${nextErrorReturnValue()};\n    }\n    if (s.endCanary[i] != 0xFFFFFFFFu) {\n      return ${nextErrorReturnValue()};\n    }\n  }`;\n  }\n\n  // Shadowing case declarations\n  let moduleScopeShadowDecls = '';\n  let functionScopeShadowDecls = '';\n\n  switch (shadowingMode) {\n    case 'module-scope':\n      // Shadow the builtins likely used by robustness as module-scope variables\n      moduleScopeShadowDecls = `\nvar<private> min = 0;\nvar<private> max = 0;\nvar<private> arrayLength = 0;\n`;\n      // Make sure that these are referenced by the function.\n      // This ensures that compilers don't strip away unused variables.\n      functionScopeShadowDecls = `\n  _ = min;\n  _ = max;\n  _ = arrayLength;\n`;\n      break;\n    case 'function-scope':\n      // Shadow the builtins likely used by robustness as function-scope variables\n      functionScopeShadowDecls = `\n  let min = 0;\n  let max = 0;\n  let arrayLength = 0;\n`;\n      break;\n  }\n\n  // Run the test\n\n  // First aggregate the test source\n  const testSource = `\n${globalSource}\n${moduleScopeShadowDecls}\n\nfn runTest() -> u32 {\n  ${functionScopeShadowDecls}\n  ${testFunctionSource}\n  return 0u;\n}`;\n\n  const layout = t.device.createPipelineLayout({\n    bindGroupLayouts: [\n    t.device.createBindGroupLayout({\n      entries: testGroupBGLEntires\n    }),\n    t.device.createBindGroupLayout({\n      entries: [\n      {\n        binding: 0,\n        visibility: GPUShaderStage.COMPUTE,\n        buffer: {\n          type: 'uniform'\n        }\n      },\n      {\n        binding: 1,\n        visibility: GPUShaderStage.COMPUTE,\n        buffer: {\n          type: 'storage'\n        }\n      }]\n\n    })]\n\n  });\n\n  const enables = t.params.baseType === 'f16' ? 'enable f16;' : '';\n\n  // Run it.\n  if (bufferBindingSize !== undefined && baseType !== 'bool') {\n    const expectedData = new ArrayBuffer(testBufferSize);\n    const bufferBindingEnd = bufferBindingOffset + bufferBindingSize;\n    testFillArrayBuffer(expectedData, baseType, {\n      zeroByteStart: bufferBindingOffset,\n      zeroByteCount: bufferBindingSize\n    });\n\n    // Create a buffer that contains zeroes in the allowed access area, and 42s everywhere else.\n    const testBuffer = t.makeBufferWithContents(\n      new Uint8Array(expectedData),\n      GPUBufferUsage.COPY_SRC |\n      GPUBufferUsage.UNIFORM |\n      GPUBufferUsage.STORAGE |\n      GPUBufferUsage.COPY_DST\n    );\n\n    // Run the shader, accessing the buffer.\n    await runShaderTest(\n      t,\n      enables,\n      GPUShaderStage.COMPUTE,\n      testSource,\n      layout,\n      [\n      {\n        binding: 0,\n        resource: {\n          buffer: testBuffer,\n          offset: dynamicOffset ? 0 : bufferBindingOffset,\n          size: bufferBindingSize\n        }\n      }],\n\n      dynamicOffset ? [bufferBindingOffset] : undefined\n    );\n\n    // Check that content of the buffer outside of the allowed area didn't change.\n    const expectedBytes = new Uint8Array(expectedData);\n    t.expectGPUBufferValuesEqual(testBuffer, expectedBytes.subarray(0, bufferBindingOffset), 0);\n    t.expectGPUBufferValuesEqual(\n      testBuffer,\n      expectedBytes.subarray(bufferBindingEnd, testBufferSize),\n      bufferBindingEnd\n    );\n  } else {\n    await runShaderTest(t, enables, GPUShaderStage.COMPUTE, testSource, layout, []);\n  }\n});"],"mappings":";;IAAA;AACA;AACA,GAAG,OAAO,MAAMA,WAAW,GAAG;AAC9B;AACA;AACA;AACA;AACA,CAAC,CAAC,SAASC,aAAa,QAAQ,yCAAyC,CACzE,SAASC,MAAM,QAAQ,8BAA8B,CACrD,SAASC,YAAY,QAAQ,kDAAkD;AAC/E,SAASC,OAAO,QAAQ,mBAAmB;AAC3C,SAASC,KAAK,QAAQ,oBAAoB;AAC1C,SAASC,aAAa,EAAEC,oBAAoB,EAAEC,eAAe,QAAQ,aAAa;;AAElF,OAAO,MAAMC,CAAC,GAAGR,aAAa,CAACG,OAAO,CAAC;;AAEvC,MAAMM,OAAO,GAAG,WAAW;AAC3B,MAAMC,OAAO,GAAG,WAAW;AAC3B,MAAMC,OAAO,GAAG,CAAC,WAAW;;AAE5B;AACA;AACA;AACA;AACA;AACA;AACA,eAAeC,aAAaA;AAC5BC,CAAC;AACDC,OAAO;AACPC,KAAK;AACLC,UAAU;AACVC,MAAM;AACNC,YAAY;AACZC,cAAc;AACd;EACElB,MAAM,CAACc,KAAK,KAAKK,cAAc,CAACC,OAAO,EAAE,4CAA4C,CAAC;;EAEtF;EACA,MAAMC,eAAe,GAAGT,CAAC,CAACU,mBAAmB,CAAC,EAAEC,IAAI,EAAE,CAAC,EAAEC,KAAK,EAAEC,cAAc,CAACC,OAAO,CAAC,CAAC,CAAC;;EAEzF,MAAMC,YAAY,GAAGf,CAAC,CAACU,mBAAmB,CAAC;IACzCC,IAAI,EAAE,CAAC;IACPC,KAAK,EAAEC,cAAc,CAACG,QAAQ,GAAGH,cAAc,CAACI;EAClD,CAAC,CAAC;;EAEF,MAAMC,MAAM,GAAG,GAAGjB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAEE,UAAU;AACZ;AACA;AACA;AACA;AACA;AACA,EAAE;;EAEAH,CAAC,CAACmB,KAAK,CAACD,MAAM,CAAC;EACf,MAAME,MAAM,GAAGpB,CAAC,CAACqB,MAAM,CAACC,kBAAkB,CAAC,EAAEC,IAAI,EAAEL,MAAM,CAAC,CAAC,CAAC;EAC5D,MAAMM,QAAQ,GAAG,MAAMxB,CAAC,CAACqB,MAAM,CAACI,0BAA0B,CAAC;IACzDrB,MAAM;IACNsB,OAAO,EAAE,EAAEN,MAAM,EAAEO,UAAU,EAAE,MAAM,CAAC;EACxC,CAAC,CAAC;;EAEF,MAAMC,KAAK,GAAG5B,CAAC,CAACqB,MAAM,CAACQ,eAAe,CAAC;IACrCzB,MAAM,EAAEoB,QAAQ,CAACM,kBAAkB,CAAC,CAAC,CAAC;IACtCC,OAAO,EAAE;IACT,EAAEC,OAAO,EAAE,CAAC,EAAEC,QAAQ,EAAE,EAAEC,MAAM,EAAEzB,eAAe,CAAC,CAAC,CAAC,CAAC;IACrD,EAAEuB,OAAO,EAAE,CAAC,EAAEC,QAAQ,EAAE,EAAEC,MAAM,EAAEnB,YAAY,CAAC,CAAC,CAAC,CAAC;;EAEpD,CAAC,CAAC;;EAEF,MAAMoB,SAAS,GAAGnC,CAAC,CAACqB,MAAM,CAACQ,eAAe,CAAC;IACzCzB,MAAM,EAAEoB,QAAQ,CAACM,kBAAkB,CAAC,CAAC,CAAC;IACtCC,OAAO,EAAE1B;EACX,CAAC,CAAC;;EAEF,MAAM+B,OAAO,GAAGC,UAAU,CAACC,YAAY,CAAC,sBAAsB,EAAEtC,CAAC,CAACqB,MAAM,EAAErB,CAAC,CAACqB,MAAM,CAACkB,oBAAoB,EAAE,EAAE,EAAE,MAAAF,UAAA,CAAAC,YAAA,yBAAMtC,CAAC,CAACqB,MAAM,EAARrB,CAAC,CAACqB,MAAM,CAAAkB,oBAAA,YAARvC,CAAC,CAACqB,MAAM,CAACkB,oBAAoB,GAAE,CAAC;EACnJ,MAAMC,IAAI,GAAGJ,OAAO,CAACK,gBAAgB,CAAC,CAAC;EACvCD,IAAI,CAACE,WAAW,CAAClB,QAAQ,CAAC;EAC1BgB,IAAI,CAACG,YAAY,CAAC,CAAC,EAAER,SAAS,EAAE7B,cAAc,CAAC;EAC/CkC,IAAI,CAACG,YAAY,CAAC,CAAC,EAAEf,KAAK,CAAC;EAC3BY,IAAI,CAACI,kBAAkB,CAAC,CAAC,CAAC;EAC1BJ,IAAI,CAACK,GAAG,CAAC,CAAC;;EAEVR,UAAU,CAACC,YAAY,CAAC,QAAQ,EAAEtC,CAAC,EAAEA,CAAC,CAAC8C,KAAK,CAACC,MAAM,EAAE,CAAC,CAACX,OAAO,CAACY,MAAM,CAAC,CAAC,CAAC,CAAC,EAAE,MAAAX,UAAA,CAAAC,YAAA,WAAMtC,CAAC,EAADA,CAAC,CAAC8C,KAAK,CAAAC,MAAA,GAAQ,CAACX,OAAO,CAACY,MAAM,CAAC,CAAC,CAAC,SAAjChD,CAAC,CAAC8C,KAAK,CAACC,MAAM,CAAC,CAACX,OAAO,CAACY,MAAM,CAAC,CAAC,CAAC,EAAC,CAAC;;EAEpHhD,CAAC,CAACiD,0BAA0B,CAAClC,YAAY,EAAE,IAAImC,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAClE;;AAEA;AACA,SAASC,mBAAmBA;AAC5BC,KAAK;AACLC,IAAI;AACJ,EAAEC,aAAa,EAAEC,aAAa,CAAC,CAAC;AAChC;EACE,MAAMC,WAAW,GAAG,EAAEC,GAAG,EAAEP,WAAW,EAAEQ,GAAG,EAAEC,UAAU,EAAEC,GAAG,EAAEvE,YAAY,EAAEwE,GAAG,EAAEC,YAAY,CAAC,CAAC;EAC/FT,IAAI,CAAC;;EAELjE,MAAM,CAACmE,aAAa,GAAGC,WAAW,CAACO,iBAAiB,KAAK,CAAC,CAAC;EAC3D,IAAIP,WAAW,CAACJ,KAAK,CAAC,CAACY,IAAI,CAAC,EAAE,CAAC;EAC/B,IAAIR,WAAW,CAACJ,KAAK,EAAEE,aAAa,EAAEC,aAAa,GAAGC,WAAW,CAACO,iBAAiB,CAAC,CAACC,IAAI,CAAC,CAAC,CAAC;AAC9F;;AAEA;AACA;AACA;;AAEArE,CAAC,CAACsE,IAAI,CAAC,eAAe,CAAC;AACvBC,IAAI;EACF;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACDC,MAAM,CAAC,CAACC,CAAC;AACTA,CAAC;AACDC,iBAAiB,CAAC;AAClB,EAAEC,YAAY,EAAE,SAAS,EAAEC,WAAW,EAAE,MAAM,EAAEC,MAAM,EAAE,MAAM,EAAEC,aAAa,EAAE,KAAK,CAAC,CAAC;AACtF;EACEH,YAAY,EAAE,SAAS;EACvBC,WAAW,EAAE,YAAY;EACzBC,MAAM,EAAE,MAAM;EACdC,aAAa,EAAE;AACjB,CAAC;AACD;EACEH,YAAY,EAAE,SAAS;EACvBC,WAAW,EAAE,YAAY;EACzBC,MAAM,EAAE,OAAO;EACfC,aAAa,EAAE;AACjB,CAAC;AACD,EAAEH,YAAY,EAAE,SAAS,EAAEC,WAAW,EAAE,MAAM,EAAEC,MAAM,EAAE,MAAM,EAAEC,aAAa,EAAE,IAAI,CAAC,CAAC;AACrF,EAAEH,YAAY,EAAE,SAAS,EAAEC,WAAW,EAAE,YAAY,EAAEC,MAAM,EAAE,MAAM,EAAEC,aAAa,EAAE,IAAI,CAAC,CAAC;AAC3F;EACEH,YAAY,EAAE,SAAS;EACvBC,WAAW,EAAE,YAAY;EACzBC,MAAM,EAAE,OAAO;EACfC,aAAa,EAAE;AACjB,CAAC;AACD,EAAEH,YAAY,EAAE,SAAS,EAAEE,MAAM,EAAE,MAAM,EAAEC,aAAa,EAAE,KAAK,CAAC,CAAC;AACjE,EAAEH,YAAY,EAAE,SAAS,EAAEE,MAAM,EAAE,MAAM,EAAEC,aAAa,EAAE,IAAI,CAAC,CAAC;AAChE,EAAEH,YAAY,EAAE,SAAS,EAAEE,MAAM,EAAE,MAAM,CAAC,CAAC;AAC3C,EAAEF,YAAY,EAAE,SAAS,EAAEE,MAAM,EAAE,OAAO,CAAC,CAAC;AAC5C,EAAEF,YAAY,EAAE,UAAU,EAAEE,MAAM,EAAE,MAAM,CAAC,CAAC;AAC5C,EAAEF,YAAY,EAAE,UAAU,EAAEE,MAAM,EAAE,OAAO,CAAC,CAAC;AAC7C,EAAEF,YAAY,EAAE,WAAW,EAAEE,MAAM,EAAE,MAAM,CAAC,CAAC;AAC7C,EAAEF,YAAY,EAAE,WAAW,EAAEE,MAAM,EAAE,OAAO,CAAC,CAAC;AAC9C,CAAC;AACDH,iBAAiB,CAAC;AAClB,EAAEK,aAAa,EAAE,OAAO,CAAC,CAAC;AAC1B,EAAEA,aAAa,EAAE,QAAQ,CAAC,CAAC;AAC3B,EAAEA,aAAa,EAAE,QAAQ,CAAC,CAAC;AAC3B,CAAC;AACDL,iBAAiB,CAAC;AAClB,EAAEM,aAAa,EAAE,MAAM,CAAC,CAAC;AACzB,EAAEA,aAAa,EAAE,cAAc,CAAC,CAAC;AACjC,EAAEA,aAAa,EAAE,gBAAgB,CAAC,CAAC;AACnC,CAAC;AACDC,MAAM,CAAC,UAAU,EAAE,CAACC,CAAC,KAAKnF,eAAe,CAACmF,CAAC,CAAC,GAAG,CAAC,KAAK,EAAE,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;AACvED,MAAM,CAAC,UAAU,EAAEnF,oBAAoB,CAAC;AACxCqF,aAAa,CAAC,CAAC;AACfC,gBAAgB,CAACvF,aAAa;AAC9B,CAAC;AACDwF,iBAAiB,CAAC,CAAChF,CAAC,KAAK;EACvB,IAAIA,CAAC,CAACmE,MAAM,CAACc,QAAQ,KAAK,KAAK,EAAE;IAC/BjF,CAAC,CAACkF,0BAA0B,CAAC,YAAY,CAAC;EAC5C;AACF,CAAC,CAAC;AACFC,EAAE,CAAC,OAAOnF,CAAC,KAAK;EACd,MAAM;IACJsE,YAAY;IACZC,WAAW;IACXC,MAAM;IACNC,aAAa;IACbW,QAAQ;IACRV,aAAa;IACbO,QAAQ;IACR5B,IAAI;IACJsB,aAAa;IACbU;EACF,CAAC,GAAGrF,CAAC,CAACmE,MAAM;;EAEZ/E,MAAM,CAACiG,UAAU,KAAKC,SAAS,EAAE,uBAAuB,CAAC;EACzDlG,MAAM,CAAC,aAAa,IAAIiG,UAAU,CAAC;;EAEnC,IAAIE,UAAU,GAAG,KAAK;EACtB,IAAIC,YAAY,GAAG,EAAE;EACrB,IAAIC,kBAAkB,GAAG,EAAE;EAC3B,MAAMC,cAAc,GAAG,GAAG;EAC1B,MAAMC,mBAAmB,GAAG,GAAG;EAC/B;EACA,IAAIC,iBAAiB,GAAGN,SAAS;;EAEjC;EACA;EACA,MAAMO,UAAU,GAAG;AACrB;AACA;AACA,UAAUxC,IAAI;AACd;AACA,GAAG;;EAED,MAAMyC,mBAAmB,GAAG,EAAE;EAC9B,QAAQxB,YAAY;IAClB,KAAK,SAAS;IACd,KAAK,SAAS;MACZ;QACElF,MAAM,CAACiG,UAAU,CAACjF,MAAM,KAAKkF,SAAS,CAAC;QACvC,MAAMlF,MAAM,GAAGiF,UAAU,CAACjF,MAAM;QAChCwF,iBAAiB,GAAGrG,KAAK,CAACa,MAAM,CAACO,IAAI,EAAEP,MAAM,CAAC2F,SAAS,CAAC;QACxD,MAAMC,UAAU,GAAG1B,YAAY,KAAK,SAAS,GAAG,YAAYC,WAAW,EAAE,GAAGD,YAAY;QACxFkB,YAAY,IAAI;AACxB;AACA,UAAUnC,IAAI;AACd;AACA,4BAA4B2C,UAAU,gBAAgB;;QAE9CF,mBAAmB,CAACG,IAAI,CAAC;UACvBjE,OAAO,EAAE,CAAC;UACVkE,UAAU,EAAE3F,cAAc,CAACC,OAAO;UAClC0B,MAAM,EAAE;YACNmB,IAAI;YACJiB,YAAY,KAAK,SAAS;YAC1B,SAAS;YACTC,WAAW,KAAK,MAAM;YACtB,mBAAmB;YACnB,SAAS;YACT4B,gBAAgB,EAAE1B;UACpB;QACF,CAAC,CAAC;MACJ;MACA;;IAEF,KAAK,SAAS;IACd,KAAK,WAAW;MACdc,UAAU,GAAG,IAAI;MACjBC,YAAY,IAAIK,UAAU;MAC1BL,YAAY,IAAI,OAAOlB,YAAY,SAAS;MAC5C;;IAEF,KAAK,UAAU;MACbiB,UAAU,GAAG,IAAI;MACjBC,YAAY,IAAIK,UAAU;MAC1BJ,kBAAkB,IAAI,WAAW;MACjC;EACJ;;EAEA;;EAEA;EACA,IAAIF,UAAU,EAAE;IACdE,kBAAkB,IAAI;AAC1B;AACA;AACA;AACA,IAAI;EACF;;EAEA;EACA,MAAMW,oBAAoB,GAAG,CAAC,MAAM;IAClC,IAAIC,gBAAgB,GAAG,MAAM;IAC7B,OAAO,MAAM;MACX,EAAEA,gBAAgB;MAClB,OAAO,KAAKA,gBAAgB,CAACC,QAAQ,CAAC,EAAE,CAAC,GAAG;IAC9C,CAAC;EACH,CAAC,EAAE,CAAC;;EAEJ;EACA,KAAK,MAAMC,WAAW,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,EAAE;IACvC,MAAMC,aAAa,GAAGD,WAAW;IACjC;IACA;IACA,GAAG;IACH,GAAGlB,UAAU,CAACoB,WAAW,MAAM;IAC/B;IACA,IAAI;IACJ,GAAGpB,UAAU,CAACoB,WAAW,EAAE;IAC3B;IACA,UAAU;IACV,SAAS;IACT,GAAG3G,OAAO,EAAE;IACZ,GAAGD,OAAO,EAAE,CAAC;;IAEb;IACA;IACA,IAAI;IACJ,GAAGwF,UAAU,CAACoB,WAAW,QAAQ;IACjC;IACA,GAAGpB,UAAU,CAACoB,WAAW,GAAG;IAC5B;IACA,UAAU;IACV,GAAG7G,OAAO,GAAG;IACb,GAAGC,OAAO,GAAG,CAAC;;;IAGd,MAAM6G,gBAAgB,GAAGH,WAAW,GAAG,GAAG,GAAG,IAAI;IACjD,MAAMI,aAAa,GAAGJ,WAAW,GAAG,KAAK,GAAG,KAAK;IACjD,KAAK,MAAMK,cAAc,IAAI;IAC7B,EAAE,EAAE;IACJ,MAAMF,gBAAgB,EAAE,EAAE;IAC1B,MAAMC,aAAa,kBAAkB,CAAC;IAAA,CACrC,EAAE;MACD;MACA,KAAK,MAAME,WAAW,IAAIL,aAAa,EAAE;QACvCf,kBAAkB,IAAI;AAC9B;AACA,mBAAmBoB,WAAW,IAAID,cAAc,GAAG;QAC3C,MAAME,eAAe,GAAG,GAAGzB,UAAU,CAAC0B,eAAe,IAAI;QACzD,MAAMC,WAAW,GAAG,eAAe;QACnC,MAAMC,QAAQ,GAAG5B,UAAU,CAAC6B,cAAc,IAAI,CAAC,EAAE,CAAC;QAClD,QAAQ1C,MAAM;UACZ,KAAK,MAAM;YACT;cACE,MAAM2C,eAAe,GAAG/B,QAAQ,GAAG,eAAe4B,WAAW,GAAG,GAAGA,WAAW;cAC9E,IAAII,UAAU,GAAGH,QAAQ,CAACI,GAAG,CAAC,CAACC,CAAC,KAAK,GAAGH,eAAe,GAAGG,CAAC,OAAOR,eAAe,EAAE,CAAC;cACpF,IAAIpC,aAAa,KAAK,QAAQ,EAAE;gBAC9B;gBACA;gBACA0C,UAAU,GAAGA,UAAU,CAACC,GAAG,CAAC,CAACE,CAAC,KAAK,OAAOA,CAAC,GAAG,CAAC;cACjD;cACAH,UAAU,CAACI,OAAO,CAAC,CAACD,CAAC,KAAK;gBACxB9B,kBAAkB,IAAI;AACtC,UAAU8B,CAAC,cAAcnB,oBAAoB,CAAC,CAAC,KAAK;cACtC,CAAC,CAAC;YACJ;YACA;;UAEF,KAAK,OAAO;YACV,IAAIhB,QAAQ,EAAE;cACZK,kBAAkB,IAAI;AACpC,kCAAkCqB,eAAe,IAAI;YACzC,CAAC,MAAM;cACLG,QAAQ,CAACO,OAAO,CAAC,CAACF,CAAC,KAAK;gBACtB7B,kBAAkB,IAAI;AACtC,mBAAmB6B,CAAC,MAAMR,eAAe,GAAG;cAC9B,CAAC,CAAC;YACJ;YACA;QACJ;QACArB,kBAAkB,IAAI;AAC9B,IAAI;MACE;IACF;EACF;;EAEA;EACA,IAAIF,UAAU,EAAE;IACdE,kBAAkB,IAAI;AAC1B;AACA;AACA,eAAeW,oBAAoB,CAAC,CAAC;AACrC;AACA;AACA,eAAeA,oBAAoB,CAAC,CAAC;AACrC;AACA,IAAI;EACF;;EAEA;EACA,IAAIqB,sBAAsB,GAAG,EAAE;EAC/B,IAAIC,wBAAwB,GAAG,EAAE;;EAEjC,QAAQ/C,aAAa;IACnB,KAAK,cAAc;MACjB;MACA8C,sBAAsB,GAAG;AAC/B;AACA;AACA;AACA,CAAC;MACK;MACA;MACAC,wBAAwB,GAAG;AACjC;AACA;AACA;AACA,CAAC;MACK;IACF,KAAK,gBAAgB;MACnB;MACAA,wBAAwB,GAAG;AACjC;AACA;AACA;AACA,CAAC;MACK;EACJ;;EAEA;;EAEA;EACA,MAAMvH,UAAU,GAAG;AACrB,EAAEqF,YAAY;AACd,EAAEiC,sBAAsB;AACxB;AACA;AACA,IAAIC,wBAAwB;AAC5B,IAAIjC,kBAAkB;AACtB;AACA,EAAE;;EAEA,MAAMrF,MAAM,GAAGJ,CAAC,CAACqB,MAAM,CAACsG,oBAAoB,CAAC;IAC3CC,gBAAgB,EAAE;IAClB5H,CAAC,CAACqB,MAAM,CAACwG,qBAAqB,CAAC;MAC7B9F,OAAO,EAAE+D;IACX,CAAC,CAAC;IACF9F,CAAC,CAACqB,MAAM,CAACwG,qBAAqB,CAAC;MAC7B9F,OAAO,EAAE;MACT;QACEC,OAAO,EAAE,CAAC;QACVkE,UAAU,EAAE3F,cAAc,CAACC,OAAO;QAClC0B,MAAM,EAAE;UACNmB,IAAI,EAAE;QACR;MACF,CAAC;MACD;QACErB,OAAO,EAAE,CAAC;QACVkE,UAAU,EAAE3F,cAAc,CAACC,OAAO;QAClC0B,MAAM,EAAE;UACNmB,IAAI,EAAE;QACR;MACF,CAAC;;IAEH,CAAC,CAAC;;EAEJ,CAAC,CAAC;;EAEF,MAAMpD,OAAO,GAAGD,CAAC,CAACmE,MAAM,CAACc,QAAQ,KAAK,KAAK,GAAG,aAAa,GAAG,EAAE;;EAEhE;EACA,IAAIW,iBAAiB,KAAKN,SAAS,IAAIL,QAAQ,KAAK,MAAM,EAAE;IAC1D,MAAM6C,YAAY,GAAG,IAAIC,WAAW,CAACrC,cAAc,CAAC;IACpD,MAAMsC,gBAAgB,GAAGrC,mBAAmB,GAAGC,iBAAiB;IAChEzC,mBAAmB,CAAC2E,YAAY,EAAE7C,QAAQ,EAAE;MAC1C3B,aAAa,EAAEqC,mBAAmB;MAClCpC,aAAa,EAAEqC;IACjB,CAAC,CAAC;;IAEF;IACA,MAAMqC,UAAU,GAAGjI,CAAC,CAACkI,sBAAsB;MACzC,IAAIC,UAAU,CAACL,YAAY,CAAC;MAC5BjH,cAAc,CAACG,QAAQ;MACvBH,cAAc,CAACC,OAAO;MACtBD,cAAc,CAACI,OAAO;MACtBJ,cAAc,CAACuH;IACjB,CAAC;;IAED;IACA,MAAMrI,aAAa;MACjBC,CAAC;MACDC,OAAO;MACPM,cAAc,CAACC,OAAO;MACtBL,UAAU;MACVC,MAAM;MACN;MACA;QACE4B,OAAO,EAAE,CAAC;QACVC,QAAQ,EAAE;UACRC,MAAM,EAAE+F,UAAU;UAClBI,MAAM,EAAE5D,aAAa,GAAG,CAAC,GAAGkB,mBAAmB;UAC/ChF,IAAI,EAAEiF;QACR;MACF,CAAC,CAAC;;MAEFnB,aAAa,GAAG,CAACkB,mBAAmB,CAAC,GAAGL;IAC1C,CAAC;;IAED;IACA,MAAMgD,aAAa,GAAG,IAAIH,UAAU,CAACL,YAAY,CAAC;IAClD9H,CAAC,CAACiD,0BAA0B,CAACgF,UAAU,EAAEK,aAAa,CAACC,QAAQ,CAAC,CAAC,EAAE5C,mBAAmB,CAAC,EAAE,CAAC,CAAC;IAC3F3F,CAAC,CAACiD,0BAA0B;MAC1BgF,UAAU;MACVK,aAAa,CAACC,QAAQ,CAACP,gBAAgB,EAAEtC,cAAc,CAAC;MACxDsC;IACF,CAAC;EACH,CAAC,MAAM;IACL,MAAMjI,aAAa,CAACC,CAAC,EAAEC,OAAO,EAAEM,cAAc,CAACC,OAAO,EAAEL,UAAU,EAAEC,MAAM,EAAE,EAAE,CAAC;EACjF;AACF,CAAC,CAAC","ignoreList":[]}