{"version":3,"file":"harness.js","names":["Colors","runFlowControlTest","t","build_wgsl","inputData","Array","expectations","build_wgsl_result","value","v","params","preventValueOptimizations","push","length","expect_order","expected","kind","stack","Error","values","counter","join","expect_not_reached","built_wgsl","entrypoint","extra","main_wgsl","undefined","wgsl","pipeline","device","createComputePipeline","layout","compute","module","createShaderModule","code","entryPoint","inputBuffer","makeBufferWithContents","Uint32Array","GPUBufferUsage","STORAGE","maxOutputValues","outputBuffer","createBufferTracked","size","usage","COPY_SRC","bindGroup","createBindGroup","getBindGroupLayout","entries","binding","resource","buffer","encoder","globalThis","_TRAMPOLINE_","createCommandEncoder","pass","beginComputePass","setPipeline","setBindGroup","dispatchWorkgroups","end","queue","submit","finish","eventualExpectOK","readGPUBufferRangeTyped","type","typedLength","then","outputs","outputCount","data","fail","err","dim","blue","print_output_value","subarray","expect_order_err","expectation","err_idx","out","i","green","red","event","eventValue","expectationIndex","cleanup"],"sources":["../../../../../src/webgpu/shader/execution/flow_control/harness.ts"],"sourcesContent":["/**\n* AUTO-GENERATED - DO NOT EDIT. Source: https://github.com/gpuweb/cts\n**/import { Colors } from '../../../../common/util/colors.js';\n/**\n * Options for runFlowControlTest()\n */\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * The builder interface for the runFlowControlTest() callback.\n * This interface is indented to be used to inject WGSL logic into the test\n * shader.\n * @see runFlowControlTest\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Builds, runs then checks the output of a flow control shader test.\n *\n * `build_wgsl` is a function that's called to build the WGSL shader.\n * This function takes a FlowControlTestBuilder as the single argument, and\n * returns either a string which is embedded into the WGSL entrypoint function,\n * or an object of the signature `{ entrypoint: string; extra: string }` which\n * contains the entrypoint code, along with additional module-scope code.\n *\n * The FlowControlTestBuilder should be used to insert expectations into WGSL to\n * validate control flow. FlowControlTestBuilder also can be used to add values\n * to the shader which cannot be optimized away.\n *\n * Example, testing that an if-statement behaves as expected:\n *\n * ```\n *   runFlowControlTest(t, f =>\n *   `\n *    ${f.expect_order(0)}\n *    if (${f.value(true)}) {\n *      ${f.expect_order(1)}\n *    } else {\n *      ${f.expect_not_reached()}\n *    }\n *    ${f.expect_order(2)}\n *  `);\n * ```\n *\n * @param t The test object\n * @param builder The shader builder function that takes a\n * FlowControlTestBuilder as the single argument, and returns either a WGSL\n * string which is embedded into the WGSL entrypoint function, or a structure\n * with entrypoint-scoped WGSL code and extra module-scope WGSL code.\n */\nexport function runFlowControlTest(\nt,\nbuild_wgsl)\n{\n  const inputData = new Array();\n\n\n\n\n\n\n\n\n\n\n\n\n  const expectations = new Array();\n\n  const build_wgsl_result = build_wgsl({\n    value: (v) => {\n      if (t.params.preventValueOptimizations) {\n        if (typeof v === 'boolean') {\n          inputData.push(v ? 1 : 0);\n          return `inputs[${inputData.length - 1}] != 0`;\n        }\n        inputData.push(v);\n        return `inputs[${inputData.length - 1}]`;\n      } else {\n        return `${v}`;\n      }\n    },\n    expect_order: (...expected) => {\n      expectations.push({\n        kind: 'events',\n        stack: Error().stack,\n        values: expected,\n        counter: 0\n      });\n      // Expectation id starts from 1 to distinguish from initialization 0.\n      return `push_output(${expectations.length}); // expect_order(${expected.join(', ')})`;\n    },\n    expect_not_reached: () => {\n      expectations.push({\n        kind: 'not-reached',\n        stack: Error().stack\n      });\n      // Expectation id starts from 1 to distinguish from initialization 0.\n      return `push_output(${expectations.length}); // expect_not_reached()`;\n    }\n  });\n\n  const built_wgsl =\n  typeof build_wgsl_result === 'string' ?\n  { entrypoint: build_wgsl_result, extra: '' } :\n  build_wgsl_result;\n\n  const main_wgsl = built_wgsl.entrypoint !== undefined ? built_wgsl : built_wgsl.entrypoint;\n\n  const wgsl = `\nstruct Outputs {\n  count : u32,\n  data  : array<u32>,\n};\n@group(0) @binding(0) var<storage, read>       inputs  : array<i32>;\n@group(0) @binding(1) var<storage, read_write> outputs : Outputs;\n\nfn push_output(value : u32) {\n  outputs.data[outputs.count] = value;\n  outputs.count++;\n}\n\n@compute @workgroup_size(1)\nfn main() {\n  _ = &inputs;\n  _ = &outputs;\n  ${main_wgsl.entrypoint}\n}\n${main_wgsl.extra}\n`;\n\n  const pipeline = t.device.createComputePipeline({\n    layout: 'auto',\n    compute: {\n      module: t.device.createShaderModule({ code: wgsl }),\n      entryPoint: 'main'\n    }\n  });\n\n  // If there are no inputs, just put a single value in the buffer to keep\n  // makeBufferWithContents() happy.\n  if (inputData.length === 0) {\n    inputData.push(0);\n  }\n\n  const inputBuffer = t.makeBufferWithContents(new Uint32Array(inputData), GPUBufferUsage.STORAGE);\n\n  const maxOutputValues = 1000;\n  const outputBuffer = t.createBufferTracked({\n    size: 4 * (1 + maxOutputValues),\n    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC\n  });\n\n  const bindGroup = t.device.createBindGroup({\n    layout: pipeline.getBindGroupLayout(0),\n    entries: [\n    { binding: 0, resource: { buffer: inputBuffer } },\n    { binding: 1, resource: { buffer: outputBuffer } }]\n\n  });\n\n  // Run the shader.\n  const encoder = globalThis._TRAMPOLINE_(\"createCommandEncoder\", t.device, t.device.createCommandEncoder, [], () => t.device.createCommandEncoder());\n  const pass = encoder.beginComputePass();\n  pass.setPipeline(pipeline);\n  pass.setBindGroup(0, bindGroup);\n  pass.dispatchWorkgroups(1);\n  pass.end();\n  globalThis._TRAMPOLINE_(\"submit\", t, t.queue.submit, [[encoder.finish()]], () => t.queue.submit([encoder.finish()]));\n\n  t.eventualExpectOK(\n    t.\n    readGPUBufferRangeTyped(outputBuffer, {\n      type: Uint32Array,\n      typedLength: outputBuffer.size / 4\n    }).\n    then((outputs) => {\n      // outputs[0]    is the number of outputted values\n      // outputs[1..N] holds the outputted values\n      const outputCount = outputs.data[0];\n      if (outputCount > maxOutputValues) {\n        return new Error(\n          `output data count (${outputCount}) exceeds limit of ${maxOutputValues}`\n        );\n      }\n\n      // returns an Error with the given message and WGSL source\n      const fail = (err) => Error(`${err}\\nWGSL:\\n${Colors.dim(Colors.blue(wgsl))}`);\n\n      // returns a string that shows the outputted values to help understand the whole trace.\n      const print_output_value = () => {\n        const subarray = outputs.data.subarray(1, outputCount + 1);\n        return `Output values (length: ${outputCount}): ${subarray.join(', ')}`;\n      };\n\n      // returns a colorized string of the expect_order() call, highlighting\n      // the event number that caused an error.\n      const expect_order_err = (expectation, err_idx) => {\n        let out = 'expect_order(';\n        for (let i = 0; i < expectation.values.length; i++) {\n          if (i > 0) {\n            out += ', ';\n          }\n          if (i < err_idx) {\n            out += Colors.green(`${expectation.values[i]}`);\n          } else if (i > err_idx) {\n            out += Colors.dim(`${expectation.values[i]}`);\n          } else {\n            out += Colors.red(`${expectation.values[i]}`);\n          }\n        }\n        out += ')';\n        return out;\n      };\n\n      // Each of the outputted values represents an event\n      // Check that each event is as expected\n      for (let event = 0; event < outputCount; event++) {\n        const eventValue = outputs.data[1 + event]; // outputs.data[0] is count\n        // Expectation id starts from 1, and 0 is invalid value.\n        if (eventValue === 0) {\n          return fail(\n            `outputs.data[${event}] is initial value 0, doesn't refer to any valid expectations)\\n${print_output_value()}`\n          );\n        }\n        const expectationIndex = eventValue - 1;\n        if (expectationIndex >= expectations.length) {\n          return fail(\n            `outputs.data[${event}] value (${expectationIndex}) exceeds number of expectations (${\n            expectations.length})\\n${\n            print_output_value()}`\n          );\n        }\n        const expectation = expectations[expectationIndex];\n        switch (expectation.kind) {\n          case 'not-reached':\n            return fail(\n              `expect_not_reached() reached at event ${event}\\n${print_output_value()}\\n${\n              expectation.stack}`\n\n            );\n          case 'events':\n            if (expectation.counter >= expectation.values.length) {\n              return fail(\n                `${expect_order_err(\n                  expectation,\n                  expectation.counter\n                )}) unexpectedly reached at event ${Colors.red(\n                  `${event}`\n                )}\\n${print_output_value()}\\n${expectation.stack}`\n              );\n            }\n            if (event !== expectation.values[expectation.counter]) {\n              return fail(\n                `${expect_order_err(expectation, expectation.counter)} expected event ${\n                expectation.values[expectation.counter]}, got ${\n                event}\\n${print_output_value()}\\n${expectation.stack}`\n              );\n            }\n\n            expectation.counter++;\n            break;\n        }\n      }\n\n      // Finally check that all expect_order() calls were reached\n      for (const expectation of expectations) {\n        if (expectation.kind === 'events' && expectation.counter !== expectation.values.length) {\n          return fail(\n            `${expect_order_err(expectation, expectation.counter)} event ${\n            expectation.values[expectation.counter]} was not reached\\n${\n            expectation.stack}\\n${print_output_value()}`\n          );\n        }\n      }\n      outputs.cleanup();\n      return undefined;\n    })\n  );\n}"],"mappings":";;IAAA;AACA;AACA,GAAG,SAASA,MAAM,QAAQ,mCAAmC,CAAC,CAC9D;AACA;AACA;;;;;;;;;;;;AAaA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AAyBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,kBAAkBA;AAClCC,CAAC;AACDC,UAAU;AACV;EACE,MAAMC,SAAS,GAAG,IAAIC,KAAK,CAAC,CAAC;;;;;;;;;;;;;EAa7B,MAAMC,YAAY,GAAG,IAAID,KAAK,CAAC,CAAC;;EAEhC,MAAME,iBAAiB,GAAGJ,UAAU,CAAC;IACnCK,KAAK,EAAEA,CAACC,CAAC,KAAK;MACZ,IAAIP,CAAC,CAACQ,MAAM,CAACC,yBAAyB,EAAE;QACtC,IAAI,OAAOF,CAAC,KAAK,SAAS,EAAE;UAC1BL,SAAS,CAACQ,IAAI,CAACH,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;UACzB,OAAO,UAAUL,SAAS,CAACS,MAAM,GAAG,CAAC,QAAQ;QAC/C;QACAT,SAAS,CAACQ,IAAI,CAACH,CAAC,CAAC;QACjB,OAAO,UAAUL,SAAS,CAACS,MAAM,GAAG,CAAC,GAAG;MAC1C,CAAC,MAAM;QACL,OAAO,GAAGJ,CAAC,EAAE;MACf;IACF,CAAC;IACDK,YAAY,EAAEA,CAAC,GAAGC,QAAQ,KAAK;MAC7BT,YAAY,CAACM,IAAI,CAAC;QAChBI,IAAI,EAAE,QAAQ;QACdC,KAAK,EAAEC,KAAK,CAAC,CAAC,CAACD,KAAK;QACpBE,MAAM,EAAEJ,QAAQ;QAChBK,OAAO,EAAE;MACX,CAAC,CAAC;MACF;MACA,OAAO,eAAed,YAAY,CAACO,MAAM,sBAAsBE,QAAQ,CAACM,IAAI,CAAC,IAAI,CAAC,GAAG;IACvF,CAAC;IACDC,kBAAkB,EAAEA,CAAA,KAAM;MACxBhB,YAAY,CAACM,IAAI,CAAC;QAChBI,IAAI,EAAE,aAAa;QACnBC,KAAK,EAAEC,KAAK,CAAC,CAAC,CAACD;MACjB,CAAC,CAAC;MACF;MACA,OAAO,eAAeX,YAAY,CAACO,MAAM,4BAA4B;IACvE;EACF,CAAC,CAAC;;EAEF,MAAMU,UAAU;EAChB,OAAOhB,iBAAiB,KAAK,QAAQ;EACrC,EAAEiB,UAAU,EAAEjB,iBAAiB,EAAEkB,KAAK,EAAE,EAAE,CAAC,CAAC;EAC5ClB,iBAAiB;;EAEjB,MAAMmB,SAAS,GAAGH,UAAU,CAACC,UAAU,KAAKG,SAAS,GAAGJ,UAAU,GAAGA,UAAU,CAACC,UAAU;;EAE1F,MAAMI,IAAI,GAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIF,SAAS,CAACF,UAAU;AACxB;AACA,EAAEE,SAAS,CAACD,KAAK;AACjB,CAAC;;EAEC,MAAMI,QAAQ,GAAG3B,CAAC,CAAC4B,MAAM,CAACC,qBAAqB,CAAC;IAC9CC,MAAM,EAAE,MAAM;IACdC,OAAO,EAAE;MACPC,MAAM,EAAEhC,CAAC,CAAC4B,MAAM,CAACK,kBAAkB,CAAC,EAAEC,IAAI,EAAER,IAAI,CAAC,CAAC,CAAC;MACnDS,UAAU,EAAE;IACd;EACF,CAAC,CAAC;;EAEF;EACA;EACA,IAAIjC,SAAS,CAACS,MAAM,KAAK,CAAC,EAAE;IAC1BT,SAAS,CAACQ,IAAI,CAAC,CAAC,CAAC;EACnB;;EAEA,MAAM0B,WAAW,GAAGpC,CAAC,CAACqC,sBAAsB,CAAC,IAAIC,WAAW,CAACpC,SAAS,CAAC,EAAEqC,cAAc,CAACC,OAAO,CAAC;;EAEhG,MAAMC,eAAe,GAAG,IAAI;EAC5B,MAAMC,YAAY,GAAG1C,CAAC,CAAC2C,mBAAmB,CAAC;IACzCC,IAAI,EAAE,CAAC,IAAI,CAAC,GAAGH,eAAe,CAAC;IAC/BI,KAAK,EAAEN,cAAc,CAACC,OAAO,GAAGD,cAAc,CAACO;EACjD,CAAC,CAAC;;EAEF,MAAMC,SAAS,GAAG/C,CAAC,CAAC4B,MAAM,CAACoB,eAAe,CAAC;IACzClB,MAAM,EAAEH,QAAQ,CAACsB,kBAAkB,CAAC,CAAC,CAAC;IACtCC,OAAO,EAAE;IACT,EAAEC,OAAO,EAAE,CAAC,EAAEC,QAAQ,EAAE,EAAEC,MAAM,EAAEjB,WAAW,CAAC,CAAC,CAAC,CAAC;IACjD,EAAEe,OAAO,EAAE,CAAC,EAAEC,QAAQ,EAAE,EAAEC,MAAM,EAAEX,YAAY,CAAC,CAAC,CAAC,CAAC;;EAEpD,CAAC,CAAC;;EAEF;EACA,MAAMY,OAAO,GAAGC,UAAU,CAACC,YAAY,CAAC,sBAAsB,EAAExD,CAAC,CAAC4B,MAAM,EAAE5B,CAAC,CAAC4B,MAAM,CAAC6B,oBAAoB,EAAE,EAAE,EAAE,MAAAF,UAAA,CAAAC,YAAA,yBAAMxD,CAAC,CAAC4B,MAAM,EAAR5B,CAAC,CAAC4B,MAAM,CAAA6B,oBAAA,YAARzD,CAAC,CAAC4B,MAAM,CAAC6B,oBAAoB,GAAE,CAAC;EACnJ,MAAMC,IAAI,GAAGJ,OAAO,CAACK,gBAAgB,CAAC,CAAC;EACvCD,IAAI,CAACE,WAAW,CAACjC,QAAQ,CAAC;EAC1B+B,IAAI,CAACG,YAAY,CAAC,CAAC,EAAEd,SAAS,CAAC;EAC/BW,IAAI,CAACI,kBAAkB,CAAC,CAAC,CAAC;EAC1BJ,IAAI,CAACK,GAAG,CAAC,CAAC;EACVR,UAAU,CAACC,YAAY,CAAC,QAAQ,EAAExD,CAAC,EAAEA,CAAC,CAACgE,KAAK,CAACC,MAAM,EAAE,CAAC,CAACX,OAAO,CAACY,MAAM,CAAC,CAAC,CAAC,CAAC,EAAE,MAAAX,UAAA,CAAAC,YAAA,WAAMxD,CAAC,EAADA,CAAC,CAACgE,KAAK,CAAAC,MAAA,GAAQ,CAACX,OAAO,CAACY,MAAM,CAAC,CAAC,CAAC,SAAjClE,CAAC,CAACgE,KAAK,CAACC,MAAM,CAAC,CAACX,OAAO,CAACY,MAAM,CAAC,CAAC,CAAC,EAAC,CAAC;;EAEpHlE,CAAC,CAACmE,gBAAgB;IAChBnE,CAAC;IACDoE,uBAAuB,CAAC1B,YAAY,EAAE;MACpC2B,IAAI,EAAE/B,WAAW;MACjBgC,WAAW,EAAE5B,YAAY,CAACE,IAAI,GAAG;IACnC,CAAC,CAAC;IACF2B,IAAI,CAAC,CAACC,OAAO,KAAK;MAChB;MACA;MACA,MAAMC,WAAW,GAAGD,OAAO,CAACE,IAAI,CAAC,CAAC,CAAC;MACnC,IAAID,WAAW,GAAGhC,eAAe,EAAE;QACjC,OAAO,IAAIzB,KAAK;UACd,sBAAsByD,WAAW,sBAAsBhC,eAAe;QACxE,CAAC;MACH;;MAEA;MACA,MAAMkC,IAAI,GAAGA,CAACC,GAAG,KAAK5D,KAAK,CAAC,GAAG4D,GAAG,YAAY9E,MAAM,CAAC+E,GAAG,CAAC/E,MAAM,CAACgF,IAAI,CAACpD,IAAI,CAAC,CAAC,EAAE,CAAC;;MAE9E;MACA,MAAMqD,kBAAkB,GAAGA,CAAA,KAAM;QAC/B,MAAMC,QAAQ,GAAGR,OAAO,CAACE,IAAI,CAACM,QAAQ,CAAC,CAAC,EAAEP,WAAW,GAAG,CAAC,CAAC;QAC1D,OAAO,0BAA0BA,WAAW,MAAMO,QAAQ,CAAC7D,IAAI,CAAC,IAAI,CAAC,EAAE;MACzE,CAAC;;MAED;MACA;MACA,MAAM8D,gBAAgB,GAAGA,CAACC,WAAW,EAAEC,OAAO,KAAK;QACjD,IAAIC,GAAG,GAAG,eAAe;QACzB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,WAAW,CAACjE,MAAM,CAACN,MAAM,EAAE0E,CAAC,EAAE,EAAE;UAClD,IAAIA,CAAC,GAAG,CAAC,EAAE;YACTD,GAAG,IAAI,IAAI;UACb;UACA,IAAIC,CAAC,GAAGF,OAAO,EAAE;YACfC,GAAG,IAAItF,MAAM,CAACwF,KAAK,CAAC,GAAGJ,WAAW,CAACjE,MAAM,CAACoE,CAAC,CAAC,EAAE,CAAC;UACjD,CAAC,MAAM,IAAIA,CAAC,GAAGF,OAAO,EAAE;YACtBC,GAAG,IAAItF,MAAM,CAAC+E,GAAG,CAAC,GAAGK,WAAW,CAACjE,MAAM,CAACoE,CAAC,CAAC,EAAE,CAAC;UAC/C,CAAC,MAAM;YACLD,GAAG,IAAItF,MAAM,CAACyF,GAAG,CAAC,GAAGL,WAAW,CAACjE,MAAM,CAACoE,CAAC,CAAC,EAAE,CAAC;UAC/C;QACF;QACAD,GAAG,IAAI,GAAG;QACV,OAAOA,GAAG;MACZ,CAAC;;MAED;MACA;MACA,KAAK,IAAII,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGf,WAAW,EAAEe,KAAK,EAAE,EAAE;QAChD,MAAMC,UAAU,GAAGjB,OAAO,CAACE,IAAI,CAAC,CAAC,GAAGc,KAAK,CAAC,CAAC,CAAC;QAC5C;QACA,IAAIC,UAAU,KAAK,CAAC,EAAE;UACpB,OAAOd,IAAI;YACT,gBAAgBa,KAAK,mEAAmET,kBAAkB,CAAC,CAAC;UAC9G,CAAC;QACH;QACA,MAAMW,gBAAgB,GAAGD,UAAU,GAAG,CAAC;QACvC,IAAIC,gBAAgB,IAAItF,YAAY,CAACO,MAAM,EAAE;UAC3C,OAAOgE,IAAI;YACT,gBAAgBa,KAAK,YAAYE,gBAAgB;YACjDtF,YAAY,CAACO,MAAM;YACnBoE,kBAAkB,CAAC,CAAC;UACtB,CAAC;QACH;QACA,MAAMG,WAAW,GAAG9E,YAAY,CAACsF,gBAAgB,CAAC;QAClD,QAAQR,WAAW,CAACpE,IAAI;UACtB,KAAK,aAAa;YAChB,OAAO6D,IAAI;cACT,yCAAyCa,KAAK,KAAKT,kBAAkB,CAAC,CAAC;cACvEG,WAAW,CAACnE,KAAK;;YAEnB,CAAC;UACH,KAAK,QAAQ;YACX,IAAImE,WAAW,CAAChE,OAAO,IAAIgE,WAAW,CAACjE,MAAM,CAACN,MAAM,EAAE;cACpD,OAAOgE,IAAI;gBACT,GAAGM,gBAAgB;kBACjBC,WAAW;kBACXA,WAAW,CAAChE;gBACd,CAAC,mCAAmCpB,MAAM,CAACyF,GAAG;kBAC5C,GAAGC,KAAK;gBACV,CAAC,KAAKT,kBAAkB,CAAC,CAAC,KAAKG,WAAW,CAACnE,KAAK;cAClD,CAAC;YACH;YACA,IAAIyE,KAAK,KAAKN,WAAW,CAACjE,MAAM,CAACiE,WAAW,CAAChE,OAAO,CAAC,EAAE;cACrD,OAAOyD,IAAI;gBACT,GAAGM,gBAAgB,CAACC,WAAW,EAAEA,WAAW,CAAChE,OAAO,CAAC;gBACrDgE,WAAW,CAACjE,MAAM,CAACiE,WAAW,CAAChE,OAAO,CAAC;gBACvCsE,KAAK,KAAKT,kBAAkB,CAAC,CAAC,KAAKG,WAAW,CAACnE,KAAK;cACtD,CAAC;YACH;;YAEAmE,WAAW,CAAChE,OAAO,EAAE;YACrB;QACJ;MACF;;MAEA;MACA,KAAK,MAAMgE,WAAW,IAAI9E,YAAY,EAAE;QACtC,IAAI8E,WAAW,CAACpE,IAAI,KAAK,QAAQ,IAAIoE,WAAW,CAAChE,OAAO,KAAKgE,WAAW,CAACjE,MAAM,CAACN,MAAM,EAAE;UACtF,OAAOgE,IAAI;YACT,GAAGM,gBAAgB,CAACC,WAAW,EAAEA,WAAW,CAAChE,OAAO,CAAC;YACrDgE,WAAW,CAACjE,MAAM,CAACiE,WAAW,CAAChE,OAAO,CAAC;YACvCgE,WAAW,CAACnE,KAAK,KAAKgE,kBAAkB,CAAC,CAAC;UAC5C,CAAC;QACH;MACF;MACAP,OAAO,CAACmB,OAAO,CAAC,CAAC;MACjB,OAAOlE,SAAS;IAClB,CAAC;EACH,CAAC;AACH","ignoreList":[]}