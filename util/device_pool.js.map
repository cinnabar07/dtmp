{"version":3,"file":"device_pool.js","names":["SkipTestCase","attemptGarbageCollection","getGPU","getDefaultRequestAdapterOptions","assert","raceWithRejectOnTimeout","assertReject","unreachable","getDefaultLimits","kLimits","TestFailedButDeviceReusable","Error","FeaturesNotSupported","TestOOMedShouldAttemptGC","DevicePool","holders","acquire","recorder","descriptor","descriptorModifierFn","errorMessage","DescriptorToHolderMap","getOrCreate","undefined","ex","name","message","holder","state","beginTestScope","release","DeviceHolder","endTestScope","lostInfo","reason","delete","device","globalThis","_TRAMPOLINE_","destroy","lost","releaseGPUDevice","expectedDeviceLost","expectedLostReason","unsupported","Set","Map","k","v","uncanonicalizedDescriptor","key","canonicalizeDescriptor","has","JSON","stringify","value","get","set","create","add","insertAndCleanUp","kMaxEntries","size","desc","featuresCanonicalized","requiredFeatures","Array","from","sort","limitsCanonicalized","adapterOptions","featureLevel","compatibilityMode","defaultLimits","requiredLimits","limit","requestedValue","defaultValue","default","descriptorCanonicalized","defaultQueue","supportsFeature","adapter","feature","features","gpu","requestAdapter","requestDevice","constructor","_device","then","ev","pushErrorScope","expectDeviceLost","kTimeout","attemptEndTestScope","gpuValidationError","gpuInternalError","gpuOutOfMemoryError","queue","submit","Promise","all","popErrorScope","onSubmittedWorkDone","allowMissingStack","GPUOutOfMemoryError","GPUInternalError","GPUValidationError"],"sources":["../../../src/webgpu/util/device_pool.ts"],"sourcesContent":["/**\n* AUTO-GENERATED - DO NOT EDIT. Source: https://github.com/gpuweb/cts\n**/import { SkipTestCase } from '../../common/framework/fixture.js';import { attemptGarbageCollection } from '../../common/util/collect_garbage.js';import { getGPU, getDefaultRequestAdapterOptions } from '../../common/util/navigator_gpu.js';\nimport {\n  assert,\n  raceWithRejectOnTimeout,\n  assertReject,\n  unreachable } from\n'../../common/util/util.js';\nimport { getDefaultLimits, kLimits } from '../capability_info.js';\n\n// MUST_NOT_BE_IMPORTED_BY_DATA_CACHE\n// This file should not be transitively imported by .cache.ts files\n\n\n\n\n\n\n\n\nclass TestFailedButDeviceReusable extends Error {}\nclass FeaturesNotSupported extends Error {}\nexport class TestOOMedShouldAttemptGC extends Error {}\n\n\n\n\n\n\nexport class DevicePool {\n  holders = 'uninitialized';\n\n  /** Acquire a device from the pool and begin the error scopes. */\n  async acquire(\n  recorder,\n  descriptor,\n  descriptorModifierFn)\n  {\n    let errorMessage = '';\n    if (this.holders === 'uninitialized') {\n      this.holders = new DescriptorToHolderMap();\n      try {\n        await this.holders.getOrCreate(recorder, undefined, descriptorModifierFn);\n      } catch (ex) {\n        this.holders = 'failed';\n        if (ex instanceof Error) {\n          errorMessage = ` with ${ex.name} \"${ex.message}\"`;\n        }\n      }\n    }\n\n    assert(\n      this.holders !== 'failed',\n      `WebGPU device failed to initialize${errorMessage}; not retrying`\n    );\n\n    const holder = await this.holders.getOrCreate(recorder, descriptor, descriptorModifierFn);\n\n    assert(holder.state === 'free', 'Device was in use on DevicePool.acquire');\n    holder.state = 'acquired';\n    holder.beginTestScope();\n    return holder;\n  }\n\n  /**\n   * End the error scopes and check for errors.\n   * Then, if the device seems reusable, release it back into the pool. Otherwise, drop it.\n   */\n  async release(holder) {\n    assert(this.holders instanceof DescriptorToHolderMap, 'DevicePool got into a bad state');\n    assert(holder instanceof DeviceHolder, 'DeviceProvider should always be a DeviceHolder');\n\n    assert(holder.state === 'acquired', 'trying to release a device while already released');\n    try {\n      await holder.endTestScope();\n\n      // (Hopefully if the device was lost, it has been reported by the time endErrorScopes()\n      // has finished (or timed out). If not, it could cause a finite number of extra test\n      // failures following this one (but should recover eventually).)\n      assert(\n        holder.lostInfo === undefined,\n        `Device was unexpectedly lost. Reason: ${holder.lostInfo?.reason}, Message: ${holder.lostInfo?.message}`\n      );\n    } catch (ex) {\n      // Any error that isn't explicitly TestFailedButDeviceReusable forces a new device to be\n      // created for the next test.\n      if (!(ex instanceof TestFailedButDeviceReusable)) {\n        this.holders.delete(holder);\n        if ('destroy' in holder.device) {\n          globalThis._TRAMPOLINE_(\"destroy\", holder.device, holder.device.destroy, [], () => holder.device.destroy());\n          // Wait for destruction (or actual device loss if any) to complete.\n          await holder.device.lost;\n        }\n\n        // Release the (hopefully only) ref to the GPUDevice.\n        holder.releaseGPUDevice();\n\n        // Try to clean up, in case there are stray GPU resources in need of collection.\n        if (ex instanceof TestOOMedShouldAttemptGC) {\n          await attemptGarbageCollection();\n        }\n      }\n      // In the try block, we may throw an error if the device is lost in order to force device\n      // reinitialization, however, if the device lost was expected we want to suppress the error\n      // The device lost is expected when `holder.expectedLostReason` is equal to\n      // `holder.lostInfo.reason`.\n      const expectedDeviceLost =\n      holder.expectedLostReason !== undefined &&\n      holder.lostInfo !== undefined &&\n      holder.expectedLostReason === holder.lostInfo.reason;\n      if (!expectedDeviceLost) {\n        throw ex;\n      }\n    } finally {\n      // Mark the holder as free so the device can be reused (if it's still in this.devices).\n      holder.state = 'free';\n    }\n  }\n}\n\n/**\n * Map from GPUDeviceDescriptor to DeviceHolder.\n */\nclass DescriptorToHolderMap {\n  /** Map keys that are known to be unsupported and can be rejected quickly. */\n  unsupported = new Set();\n  holders = new Map();\n\n  /** Deletes an item from the map by DeviceHolder value. */\n  delete(holder) {\n    for (const [k, v] of this.holders) {\n      if (v === holder) {\n        this.holders.delete(k);\n        return;\n      }\n    }\n    unreachable(\"internal error: couldn't find DeviceHolder to delete\");\n  }\n\n  /**\n   * Gets a DeviceHolder from the map if it exists; otherwise, calls create() to create one,\n   * inserts it, and returns it.\n   *\n   * If an `uncanonicalizedDescriptor` is provided, it is canonicalized and used as the map key.\n   * If one is not provided, the map key is `\"\"` (empty string).\n   *\n   * Throws SkipTestCase if devices with this descriptor are unsupported.\n   */\n  async getOrCreate(\n  recorder,\n  uncanonicalizedDescriptor,\n  descriptorModifierFn)\n  {\n    const [descriptor, key] = canonicalizeDescriptor(uncanonicalizedDescriptor);\n    // Quick-reject descriptors that are known to be unsupported already.\n    if (this.unsupported.has(key)) {\n      throw new SkipTestCase(\n        `GPUDeviceDescriptor previously failed: ${JSON.stringify(descriptor)}`\n      );\n    }\n\n    // Search for an existing device with the same descriptor.\n    {\n      const value = this.holders.get(key);\n      if (value) {\n        // Move it to the end of the Map (most-recently-used).\n        this.holders.delete(key);\n        this.holders.set(key, value);\n        return value;\n      }\n    }\n\n    // No existing item was found; add a new one.\n    let value;\n    try {\n      value = await DeviceHolder.create(recorder, descriptor, descriptorModifierFn);\n    } catch (ex) {\n      if (ex instanceof FeaturesNotSupported) {\n        this.unsupported.add(key);\n        throw new SkipTestCase(\n          `GPUDeviceDescriptor not supported: ${JSON.stringify(descriptor)}\\n${ex?.message ?? ''}`\n        );\n      }\n\n      throw ex;\n    }\n    this.insertAndCleanUp(key, value);\n    return value;\n  }\n\n  /** Insert an entry, then remove the least-recently-used items if there are too many. */\n  insertAndCleanUp(key, value) {\n    this.holders.set(key, value);\n\n    const kMaxEntries = 5;\n    if (this.holders.size > kMaxEntries) {\n      // Delete the first (least recently used) item in the set.\n      for (const [key] of this.holders) {\n        this.holders.delete(key);\n        return;\n      }\n    }\n  }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Make a stringified map-key from a GPUDeviceDescriptor.\n * Tries to make sure all defaults are resolved, first - but it's okay if some are missed\n * (it just means some GPUDevice objects won't get deduplicated).\n *\n * This does **not** canonicalize `undefined` (the \"default\" descriptor) into a fully-qualified\n * GPUDeviceDescriptor. This is just because `undefined` is a common case and we want to use it\n * as a sanity check that WebGPU is working.\n */\nfunction canonicalizeDescriptor(\ndesc)\n{\n  if (desc === undefined) {\n    return [undefined, ''];\n  }\n\n  const featuresCanonicalized = desc.requiredFeatures ?\n  Array.from(new Set(desc.requiredFeatures)).sort() :\n  [];\n\n  /** Canonicalized version of the requested limits: in canonical order, with only values which are\n   * specified _and_ non-default. */\n  const limitsCanonicalized = {};\n  // MAINTENANCE_TODO: Remove cast when @webgpu/types includes compatibilityMode\n  const adapterOptions = getDefaultRequestAdapterOptions();\n\n\n  const featureLevel = adapterOptions?.compatibilityMode ? 'compatibility' : 'core';\n  const defaultLimits = getDefaultLimits(featureLevel);\n  if (desc.requiredLimits) {\n    for (const limit of kLimits) {\n      const requestedValue = desc.requiredLimits[limit];\n      const defaultValue = defaultLimits[limit].default;\n      // Skip adding a limit to limitsCanonicalized if it is the same as the default.\n      if (requestedValue !== undefined && requestedValue !== defaultValue) {\n        limitsCanonicalized[limit] = requestedValue;\n      }\n    }\n  }\n\n  // Type ensures every field is carried through.\n  const descriptorCanonicalized = {\n    requiredFeatures: featuresCanonicalized,\n    requiredLimits: limitsCanonicalized,\n    defaultQueue: {}\n  };\n  return [descriptorCanonicalized, JSON.stringify(descriptorCanonicalized)];\n}\n\nfunction supportsFeature(\nadapter,\ndescriptor)\n{\n  if (descriptor === undefined) {\n    return true;\n  }\n\n  for (const feature of descriptor.requiredFeatures) {\n    if (!adapter.features.has(feature)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * DeviceHolder has three states:\n * - 'free': Free to be used for a new test.\n * - 'acquired': In use by a running test.\n */\n\n\n/**\n * Holds a GPUDevice and tracks its state (free/acquired) and handles device loss.\n */\nclass DeviceHolder {\n  /** Adapter the device was created from. Cannot be reused; just for adapter info. */\n\n  /** The device. Will be cleared during cleanup if there were unexpected errors. */\n\n  /** Whether the device is in use by a test or not. */\n  state = 'free';\n  /** initially undefined; becomes set when the device is lost */\n\n  /** Set if the device is expected to be lost. */\n\n\n  // Gets a device and creates a DeviceHolder.\n  // If the device is lost, DeviceHolder.lost gets set.\n  static async create(\n  recorder,\n  descriptor,\n  descriptorModifierFn)\n  {\n    const gpu = getGPU(recorder);\n    const adapter = await globalThis._TRAMPOLINE_(\"requestAdapter\", gpu, gpu.requestAdapter, [], () => gpu.requestAdapter());\n    assert(adapter !== null, 'requestAdapter returned null');\n    if (descriptorModifierFn) {\n      descriptor = descriptorModifierFn(adapter, descriptor);\n    }\n    if (!supportsFeature(adapter, descriptor)) {\n      throw new FeaturesNotSupported('One or more features are not supported');\n    }\n    // No trackForCleanup because we plan to reuse the device for the next test.\n\n    const device = await globalThis._TRAMPOLINE_(\"requestDevice\", adapter, adapter.requestDevice, [descriptor], () => adapter.requestDevice(descriptor));\n    assert(device !== null, 'requestDevice returned null');\n\n    return new DeviceHolder(adapter, device);\n  }\n\n  constructor(adapter, device) {\n    this.adapter = adapter;\n    this._device = device;\n    void this._device.lost.then((ev) => {\n      this.lostInfo = ev;\n    });\n  }\n\n  get device() {\n    assert(this._device !== undefined);\n    return this._device;\n  }\n\n  /** Push error scopes that surround test execution. */\n  beginTestScope() {\n    assert(this.state === 'acquired');\n    this.device.pushErrorScope('validation');\n    this.device.pushErrorScope('internal');\n    this.device.pushErrorScope('out-of-memory');\n  }\n\n  /** Mark the DeviceHolder as expecting a device loss when the test scope ends. */\n  expectDeviceLost(reason) {\n    assert(this.state === 'acquired');\n    this.expectedLostReason = reason;\n  }\n\n  /**\n   * Attempt to end test scopes: Check that there are no extra error scopes, and that no\n   * otherwise-uncaptured errors occurred during the test. Time out if it takes too long.\n   */\n  endTestScope() {\n    assert(this.state === 'acquired');\n    const kTimeout = 5000;\n\n    // Time out if attemptEndTestScope (popErrorScope or onSubmittedWorkDone) never completes. If\n    // this rejects, the device won't be reused, so it's OK that popErrorScope calls may not have\n    // finished.\n    //\n    // This could happen due to a browser bug - e.g.,\n    // as of this writing, on Chrome GPU process crash, popErrorScope just hangs.\n    return raceWithRejectOnTimeout(this.attemptEndTestScope(), kTimeout, 'endTestScope timed out');\n  }\n\n  async attemptEndTestScope() {\n    let gpuValidationError;\n    let gpuInternalError;\n    let gpuOutOfMemoryError;\n\n    // Submit to the queue to attempt to force a GPU flush.\n    globalThis._TRAMPOLINE_(\"submit\", this.device, this.device.queue.submit, [[]], () => this.device.queue.submit([]));\n\n    try {\n      // May reject if the device was lost.\n      [gpuOutOfMemoryError, gpuInternalError, gpuValidationError] = await Promise.all([\n      this.device.popErrorScope(),\n      this.device.popErrorScope(),\n      this.device.popErrorScope()]\n      );\n    } catch (ex) {\n      assert(this.lostInfo !== undefined, 'popErrorScope failed; did beginTestScope get missed?');\n      throw ex;\n    }\n\n    // Attempt to wait for the queue to be idle.\n    if (this.device.queue.onSubmittedWorkDone) {\n      await this.device.queue.onSubmittedWorkDone();\n    }\n\n    await assertReject('OperationError', this.device.popErrorScope(), {\n      allowMissingStack: true,\n      message: 'There was an extra error scope on the stack after a test'\n    });\n\n    if (gpuOutOfMemoryError !== null) {\n      assert(gpuOutOfMemoryError instanceof GPUOutOfMemoryError);\n      // Don't allow the device to be reused; unexpected OOM could break the device.\n      throw new TestOOMedShouldAttemptGC('Unexpected out-of-memory error occurred');\n    }\n    if (gpuInternalError !== null) {\n      assert(gpuInternalError instanceof GPUInternalError);\n      // Allow the device to be reused.\n      throw new TestFailedButDeviceReusable(\n        `Unexpected internal error occurred: ${gpuInternalError.message}`\n      );\n    }\n    if (gpuValidationError !== null) {\n      assert(gpuValidationError instanceof GPUValidationError);\n      // Allow the device to be reused.\n      throw new TestFailedButDeviceReusable(\n        `Unexpected validation error occurred: ${gpuValidationError.message}`\n      );\n    }\n  }\n\n  /**\n   * Release the ref to the GPUDevice. This should be the only ref held by the DevicePool or\n   * GPUTest, so in theory it can get garbage collected.\n   */\n  releaseGPUDevice() {\n    this._device = undefined;\n  }\n}"],"mappings":"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","ignoreList":[]}