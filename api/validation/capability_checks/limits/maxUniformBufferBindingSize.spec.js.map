{"version":3,"file":"maxUniformBufferBindingSize.spec.js","names":["kMaximumLimitBaseParams","makeLimitTestGroup","kBufferParts","getSizeAndOffsetForBufferPart","device","bufferPart","size","align","limits","minUniformBufferOffsetAlignment","offset","limit","g","description","kExtraLimits","maxBufferSize","test","desc","params","combine","fn","t","limitTest","testValueName","testDeviceWithRequestedMaximumLimits","testValue","shouldError","bindGroupLayout","createBindGroupLayout","entries","binding","visibility","GPUShaderStage","VERTEX","buffer","pushErrorScope","uniformBuffer","createBufferTracked","usage","GPUBufferUsage","UNIFORM","outOfMemoryError","popErrorScope","expectValidationError","createBindGroup","layout","resource","adapter","defaultLimit","adapterLimit","expect","getDefaultLimit"],"sources":["../../../../../../src/webgpu/api/validation/capability_checks/limits/maxUniformBufferBindingSize.spec.ts"],"sourcesContent":["/**\n* AUTO-GENERATED - DO NOT EDIT. Source: https://github.com/gpuweb/cts\n**/import { kMaximumLimitBaseParams, makeLimitTestGroup } from './limit_utils.js';const kBufferParts = ['wholeBuffer', 'biggerBufferWithOffset'];\n\n\nfunction getSizeAndOffsetForBufferPart(device, bufferPart, size) {\n  const align = device.limits.minUniformBufferOffsetAlignment;\n  switch (bufferPart) {\n    case 'wholeBuffer':\n      return { offset: 0, size };\n    case 'biggerBufferWithOffset':\n      return { size: size + align, offset: align };\n  }\n}\n\nconst limit = 'maxUniformBufferBindingSize';\nexport const { g, description } = makeLimitTestGroup(limit);\n\n// We also need to update the maxBufferSize limit when testing.\nconst kExtraLimits = { maxBufferSize: 'maxLimit' };\n\ng.test('createBindGroup,at_over').\ndesc(`Test using at and over ${limit} limit`).\nparams(kMaximumLimitBaseParams.combine('bufferPart', kBufferParts)).\nfn(async (t) => {\n  const { limitTest, testValueName, bufferPart } = t.params;\n  await t.testDeviceWithRequestedMaximumLimits(\n    limitTest,\n    testValueName,\n    async ({ device, testValue, shouldError }) => {\n      const bindGroupLayout = device.createBindGroupLayout({\n        entries: [\n        {\n          binding: 0,\n          visibility: GPUShaderStage.VERTEX,\n          buffer: {}\n        }]\n\n      });\n\n      const { size, offset } = getSizeAndOffsetForBufferPart(device, bufferPart, testValue);\n\n      // If the size of the buffer exceeds the related but separate maxBufferSize limit, we can\n      // skip the validation since the allocation will fail with a validation error.\n      if (size > device.limits.maxBufferSize) {\n        return;\n      }\n\n      device.pushErrorScope('out-of-memory');\n      const uniformBuffer = t.createBufferTracked({\n        usage: GPUBufferUsage.UNIFORM,\n        size\n      });\n      const outOfMemoryError = await device.popErrorScope();\n\n      if (!outOfMemoryError) {\n        await t.expectValidationError(\n          () => {\n            device.createBindGroup({\n              layout: bindGroupLayout,\n              entries: [\n              {\n                binding: 0,\n                resource: {\n                  buffer: uniformBuffer,\n                  offset,\n                  size: testValue\n                }\n              }]\n\n            });\n          },\n          shouldError,\n          `size: ${size}, offset: ${offset}, testValue: ${testValue}`\n        );\n      }\n    },\n    kExtraLimits\n  );\n});\n\ng.test('validate,maxBufferSize').\ndesc(`Test that ${limit} <= maxBufferSize`).\nfn((t) => {\n  const { adapter, defaultLimit, adapterLimit } = t;\n  t.expect(defaultLimit <= t.getDefaultLimit('maxBufferSize'));\n  t.expect(adapterLimit <= adapter.limits.maxBufferSize);\n});"],"mappings":"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","ignoreList":[]}