{"version":3,"file":"limit_utils.js","names":["kUnitCaseParamsBuilder","makeTestGroup","getGPU","assert","range","reorder","getDefaultLimitsForAdapter","GPUTestBase","kCreatePipelineTypes","kRenderEncoderTypes","kEncoderTypes","kBindGroupTests","kBindingCombinations","getPipelineTypeForBindingCombination","bindingCombination","getBindGroupIndex","bindGroupTest","numBindGroups","i","getBindingIndex","getWGSLBindings","order","storageDefinitionWGSLSnippetFn","numBindings","id","groupNdx","bindingNdx","storageWGSL","join","getPerStageWGSLForBindingCombinationImpl","bodyFn","extraWGSL","bindingParams","getPerStageWGSLForBindingCombination","usageWGSLSnippetFn","maxBindGroups","set","getPerStageWGSLForBindingCombinationStorageTextures","kLimitModes","kMaximumTestValues","getMaximumTestValue","limit","testValue","kMinimumTestValues","kMaximumLimitValueTests","getLimitValue","defaultLimit","maximumLimit","limitValueTest","Math","floor","kMinimumLimitValueTests","getDefaultLimitForAdapter","adapter","limitInfo","default","kMinimumLimits","Set","kMaximumLimitBaseParams","combine","kMinimumLimitBaseParams","LimitTestsImpl","_adapter","_device","undefined","adapterLimit","init","gpu","rec","globalThis","_TRAMPOLINE_","requestAdapter","limits","Number","isNaN","device","requestDeviceWithLimits","requiredLimits","shouldReject","requiredFeatures","requestDeviceTracked","allowMissingStack","getDefaultOrAdapterLimit","limitMode","_getDeviceWithSpecificLimit","requestedLimit","extraLimits","features","extraLimitStr","Object","entries","extraLimit","has","actualLimit","expect","_getDeviceWithRequestedMaximumLimit","_testThenDestroyDevice","deviceAndLimits","fn","shouldError","pushErrorScope","validationError","popErrorScope","outOfMemoryError","internalError","message","destroy","testDeviceWithSpecificLimits","deviceLimitValue","testDeviceWithRequestedMaximumLimits","limitTest","testValueName","extraFeatures","inputs","expectGPUErrorAsync","filter","msg","returnValue","Promise","error","shouldRejectConditionally","expectedName","p","shouldResolve","e","expectValidationError","expectNoValidationError","testForValidationErrorWithPossibleOutOfMemoryError","result","getGroupIndexWGSLForPipelineType","pipelineType","groupIndex","getBindingIndexWGSLForPipelineType","bindingIndex","_createRenderPipelineDescriptor","module","layout","vertex","entryPoint","fragment","targets","format","createShaderModule","code","_createRenderPipelineDescriptorWithFragmentShader","depthStencil","depthWriteEnabled","depthCompare","_createComputePipelineDescriptor","compute","createPipeline","createPipelineType","createRenderPipeline","createComputePipeline","createPipelineAsync","createRenderPipelineAsync","createComputePipelineAsync","testCreatePipeline","async","testCreateRenderPipeline","pipelineDescriptor","testMaxComputeWorkgroupSize","axis","kExtraLimits","maxComputeInvocationsPerWorkgroup","size","codePointAt","getModuleForWorkgroupSize","getGPURenderCommandsMixin","#getGPURenderCommandsMixin","encoderType","buffer","createBufferTracked","usage","GPUBufferUsage","UNIFORM","texture","createTextureTracked","GPUTextureUsage","RENDER_ATTACHMENT","createBindGroupLayout","binding","visibility","GPUShaderStage","VERTEX","bindGroup","createBindGroup","resource","encoder","createCommandEncoder","passEncoder","beginRenderPass","colorAttachments","view","createView","loadOp","storeOp","prep","end","test","finish","createRenderBundleEncoder","colorFormats","testGPURenderAndBindingCommandsMixin","getGPUBindingCommandsMixin","#getGPUBindingCommandsMixin","COMPUTE","beginComputePass","testGPUBindingCommandsMixin","makeLimitTestFixture","LimitTests","makeLimitTestGroup","description","g"],"sources":["../../../../../../src/webgpu/api/validation/capability_checks/limits/limit_utils.ts"],"sourcesContent":["/**\n* AUTO-GENERATED - DO NOT EDIT. Source: https://github.com/gpuweb/cts\n**/import { kUnitCaseParamsBuilder } from '../../../../../common/framework/params_builder.js';import { makeTestGroup } from '../../../../../common/framework/test_group.js';import { getGPU } from '../../../../../common/util/navigator_gpu.js';\nimport { assert, range, reorder } from '../../../../../common/util/util.js';\nimport { getDefaultLimitsForAdapter } from '../../../../capability_info.js';\nimport { GPUTestBase } from '../../../../gpu_test.js';\n\n\n\nexport const kCreatePipelineTypes = [\n'createRenderPipeline',\n'createRenderPipelineWithFragmentStage',\n'createComputePipeline'];\n\n\n\nexport const kRenderEncoderTypes = ['render', 'renderBundle'];\n\n\nexport const kEncoderTypes = ['compute', 'render', 'renderBundle'];\n\n\nexport const kBindGroupTests = ['sameGroup', 'differentGroups'];\n\n\nexport const kBindingCombinations = [\n'vertex',\n'fragment',\n'vertexAndFragmentWithPossibleVertexStageOverflow',\n'vertexAndFragmentWithPossibleFragmentStageOverflow',\n'compute'];\n\n\n\nexport function getPipelineTypeForBindingCombination(bindingCombination) {\n  switch (bindingCombination) {\n    case 'vertex':\n      return 'createRenderPipeline';\n    case 'fragment':\n    case 'vertexAndFragmentWithPossibleVertexStageOverflow':\n    case 'vertexAndFragmentWithPossibleFragmentStageOverflow':\n      return 'createRenderPipelineWithFragmentStage';\n    case 'compute':\n      return 'createComputePipeline';\n  }\n}\n\nfunction getBindGroupIndex(bindGroupTest, numBindGroups, i) {\n  switch (bindGroupTest) {\n    case 'sameGroup':\n      return 0;\n    case 'differentGroups':\n      return i % numBindGroups;\n  }\n}\n\nfunction getBindingIndex(bindGroupTest, numBindGroups, i) {\n  switch (bindGroupTest) {\n    case 'sameGroup':\n      return i;\n    case 'differentGroups':\n      return i / numBindGroups | 0;\n  }\n}\n\nfunction getWGSLBindings(\n{\n  order,\n  bindGroupTest,\n  storageDefinitionWGSLSnippetFn,\n  numBindGroups\n\n\n\n\n\n},\nnumBindings,\nid)\n{\n  return reorder(\n    order,\n    range(numBindings, (i) => {\n      const groupNdx = getBindGroupIndex(bindGroupTest, numBindGroups, i);\n      const bindingNdx = getBindingIndex(bindGroupTest, numBindGroups, i);\n      const storageWGSL = storageDefinitionWGSLSnippetFn(i, id);\n      return `@group(${groupNdx}) @binding(${bindingNdx}) ${storageWGSL};`;\n    })\n  ).join('\\n        ');\n}\n\nexport function getPerStageWGSLForBindingCombinationImpl(\nbindingCombination,\norder,\nbindGroupTest,\nstorageDefinitionWGSLSnippetFn,\nbodyFn,\nnumBindGroups,\nnumBindings,\nextraWGSL = '')\n{\n  const bindingParams = {\n    order,\n    bindGroupTest,\n    storageDefinitionWGSLSnippetFn,\n    numBindGroups\n  };\n  switch (bindingCombination) {\n    case 'vertex':\n      return `\n        ${extraWGSL}\n\n        ${getWGSLBindings(bindingParams, numBindings, 0)}\n\n        @vertex fn mainVS() -> @builtin(position) vec4f {\n          ${bodyFn(numBindings, 0)}\n          return vec4f(0);\n        }\n      `;\n    case 'fragment':\n      return `\n        ${extraWGSL}\n\n        ${getWGSLBindings(bindingParams, numBindings, 0)}\n\n        @vertex fn mainVS() -> @builtin(position) vec4f {\n          return vec4f(0);\n        }\n\n        @fragment fn mainFS() {\n          ${bodyFn(numBindings, 0)}\n        }\n      `;\n    case 'vertexAndFragmentWithPossibleVertexStageOverflow':{\n        return `\n        ${extraWGSL}\n\n        ${getWGSLBindings(bindingParams, numBindings, 0)}\n\n        ${getWGSLBindings(bindingParams, numBindings - 1, 1)}\n\n        @vertex fn mainVS() -> @builtin(position) vec4f {\n          ${bodyFn(numBindings, 0)}\n          return vec4f(0);\n        }\n\n        @fragment fn mainFS() {\n          ${bodyFn(numBindings - 1, 1)}\n        }\n      `;\n      }\n    case 'vertexAndFragmentWithPossibleFragmentStageOverflow':{\n        return `\n        ${extraWGSL}\n\n        ${getWGSLBindings(bindingParams, numBindings - 1, 0)}\n\n        ${getWGSLBindings(bindingParams, numBindings, 1)}\n\n        @vertex fn mainVS() -> @builtin(position) vec4f {\n          ${bodyFn(numBindings - 1, 0)}\n          return vec4f(0);\n        }\n\n        @fragment fn mainFS() {\n          ${bodyFn(numBindings, 1)}\n        }\n      `;\n      }\n    case 'compute':\n      return `\n        ${extraWGSL}\n        ${getWGSLBindings(bindingParams, numBindings, 0)}\n        @compute @workgroup_size(1) fn main() {\n          ${bodyFn(numBindings, 0)}\n        }\n      `;\n      break;\n  }\n}\n\nexport function getPerStageWGSLForBindingCombination(\nbindingCombination,\norder,\nbindGroupTest,\nstorageDefinitionWGSLSnippetFn,\nusageWGSLSnippetFn,\nmaxBindGroups,\nnumBindings,\nextraWGSL = '')\n{\n  return getPerStageWGSLForBindingCombinationImpl(\n    bindingCombination,\n    order,\n    bindGroupTest,\n    storageDefinitionWGSLSnippetFn,\n    (numBindings, set) =>\n    `${range(numBindings, (i) => usageWGSLSnippetFn(i, set)).join('\\n          ')}`,\n    maxBindGroups,\n    numBindings,\n    extraWGSL\n  );\n}\n\nexport function getPerStageWGSLForBindingCombinationStorageTextures(\nbindingCombination,\norder,\nbindGroupTest,\nstorageDefinitionWGSLSnippetFn,\nusageWGSLSnippetFn,\nnumBindGroups,\nnumBindings,\nextraWGSL = '')\n{\n  return getPerStageWGSLForBindingCombinationImpl(\n    bindingCombination,\n    order,\n    bindGroupTest,\n    storageDefinitionWGSLSnippetFn,\n    (numBindings, set) =>\n    `${range(numBindings, (i) => usageWGSLSnippetFn(i, set)).join('\\n          ')}`,\n    numBindGroups,\n    numBindings,\n    extraWGSL\n  );\n}\n\nexport const kLimitModes = ['defaultLimit', 'adapterLimit'];\n\n\n\nexport const kMaximumTestValues = ['atLimit', 'overLimit'];\n\n\nexport function getMaximumTestValue(limit, testValue) {\n  switch (testValue) {\n    case 'atLimit':\n      return limit;\n    case 'overLimit':\n      return limit + 1;\n  }\n}\n\nexport const kMinimumTestValues = ['atLimit', 'underLimit'];\n\n\nexport const kMaximumLimitValueTests = [\n'atDefault',\n'underDefault',\n'betweenDefaultAndMaximum',\n'atMaximum',\n'overMaximum'];\n\n\n\nexport function getLimitValue(\ndefaultLimit,\nmaximumLimit,\nlimitValueTest)\n{\n  switch (limitValueTest) {\n    case 'atDefault':\n      return defaultLimit;\n    case 'underDefault':\n      return defaultLimit - 1;\n    case 'betweenDefaultAndMaximum':\n      // The result can be larger than maximum i32.\n      return Math.floor((defaultLimit + maximumLimit) / 2);\n    case 'atMaximum':\n      return maximumLimit;\n    case 'overMaximum':\n      return maximumLimit + 1;\n  }\n}\n\nexport const kMinimumLimitValueTests = [\n'atDefault',\n'overDefault',\n'betweenDefaultAndMinimum',\n'atMinimum',\n'underMinimum'];\n\n\n\nexport function getDefaultLimitForAdapter(adapter, limit) {\n  const limitInfo = getDefaultLimitsForAdapter(adapter);\n  return limitInfo[limit].default;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst kMinimumLimits = new Set([\n'minUniformBufferOffsetAlignment',\n'minStorageBufferOffsetAlignment']\n);\n\n/**\n * Adds the default parameters to a limit test\n */\nexport const kMaximumLimitBaseParams = kUnitCaseParamsBuilder.\ncombine('limitTest', kMaximumLimitValueTests).\ncombine('testValueName', kMaximumTestValues);\n\nexport const kMinimumLimitBaseParams = kUnitCaseParamsBuilder.\ncombine('limitTest', kMinimumLimitValueTests).\ncombine('testValueName', kMinimumTestValues);\n\nexport class LimitTestsImpl extends GPUTestBase {\n  _adapter = null;\n  _device = undefined;\n  limit = '';\n  defaultLimit = 0;\n  adapterLimit = 0;\n\n  async init() {\n    await super.init();\n    const gpu = getGPU(this.rec);\n    this._adapter = await globalThis._TRAMPOLINE_(\"requestAdapter\", gpu, gpu.requestAdapter, [], () => gpu.requestAdapter());\n    const limit = this.limit;\n    this.defaultLimit = getDefaultLimitForAdapter(this.adapter, limit);\n    this.adapterLimit = this.adapter.limits[limit];\n    assert(!Number.isNaN(this.defaultLimit));\n    assert(!Number.isNaN(this.adapterLimit));\n  }\n\n  get adapter() {\n    assert(this._adapter !== undefined);\n    return this._adapter;\n  }\n\n  get device() {\n    assert(this._device !== undefined, 'device is only valid in _testThenDestroyDevice callback');\n    return this._device;\n  }\n\n  async requestDeviceWithLimits(\n  adapter,\n  requiredLimits,\n  shouldReject,\n  requiredFeatures)\n  {\n    if (shouldReject) {\n      this.shouldReject('OperationError', this.requestDeviceTracked(adapter, { requiredLimits }), {\n        allowMissingStack: true\n      });\n      return undefined;\n    } else {\n      return this.requestDeviceTracked(adapter, { requiredLimits, requiredFeatures });\n    }\n  }\n\n  getDefaultOrAdapterLimit(limit, limitMode) {\n    switch (limitMode) {\n      case 'defaultLimit':\n        return getDefaultLimitForAdapter(this.adapter, limit);\n      case 'adapterLimit':\n        return this.adapter.limits[limit];\n    }\n  }\n\n  /**\n   * Gets a device with the adapter a requested limit and checks that that limit\n   * is correct or that the device failed to create if the requested limit is\n   * beyond the maximum supported by the device.\n   */\n  async _getDeviceWithSpecificLimit(\n  requestedLimit,\n  extraLimits,\n  features)\n  {\n    const { adapter, limit, adapterLimit, defaultLimit } = this;\n\n    const requiredLimits = {};\n    requiredLimits[limit] = requestedLimit;\n\n    if (extraLimits) {\n      for (const [extraLimitStr, limitMode] of Object.entries(extraLimits)) {\n        const extraLimit = extraLimitStr;\n        requiredLimits[extraLimit] =\n        limitMode === 'defaultLimit' ?\n        getDefaultLimitForAdapter(adapter, extraLimit) :\n        adapter.limits[extraLimit];\n      }\n    }\n\n    const shouldReject = kMinimumLimits.has(limit) ?\n    requestedLimit < adapterLimit :\n    requestedLimit > adapterLimit;\n\n    const device = await this.requestDeviceWithLimits(\n      adapter,\n      requiredLimits,\n      shouldReject,\n      features\n    );\n    const actualLimit = device ? device.limits[limit] : 0;\n\n    if (shouldReject) {\n      this.expect(!device, 'expected no device');\n    } else {\n      if (kMinimumLimits.has(limit)) {\n        if (requestedLimit <= defaultLimit) {\n          this.expect(\n            actualLimit === requestedLimit,\n            `expected actual actualLimit: ${actualLimit} to equal defaultLimit: ${requestedLimit}`\n          );\n        } else {\n          this.expect(\n            actualLimit === defaultLimit,\n            `expected actual actualLimit: ${actualLimit} to equal defaultLimit: ${defaultLimit}`\n          );\n        }\n      } else {\n        if (requestedLimit <= defaultLimit) {\n          this.expect(\n            actualLimit === defaultLimit,\n            `expected actual actualLimit: ${actualLimit} to equal defaultLimit: ${defaultLimit}`\n          );\n        } else {\n          this.expect(\n            actualLimit === requestedLimit,\n            `expected actual actualLimit: ${actualLimit} to equal requestedLimit: ${requestedLimit}`\n          );\n        }\n      }\n    }\n\n    return device ? { device, defaultLimit, adapterLimit, requestedLimit, actualLimit } : undefined;\n  }\n\n  /**\n   * Gets a device with the adapter a requested limit and checks that that limit\n   * is correct or that the device failed to create if the requested limit is\n   * beyond the maximum supported by the device.\n   */\n  async _getDeviceWithRequestedMaximumLimit(\n  limitValueTest,\n  extraLimits,\n  features)\n  {\n    const { defaultLimit, adapterLimit: maximumLimit } = this;\n\n    const requestedLimit = getLimitValue(defaultLimit, maximumLimit, limitValueTest);\n    return this._getDeviceWithSpecificLimit(requestedLimit, extraLimits, features);\n  }\n\n  /**\n   * Call the given function and check no WebGPU errors are leaked.\n   */\n  async _testThenDestroyDevice(\n  deviceAndLimits,\n  testValue,\n  fn)\n  {\n    assert(!this._device);\n\n    const { device, actualLimit } = deviceAndLimits;\n    this._device = device;\n\n    const shouldError = kMinimumLimits.has(this.limit) ?\n    testValue < actualLimit :\n    testValue > actualLimit;\n\n    device.pushErrorScope('internal');\n    device.pushErrorScope('out-of-memory');\n    device.pushErrorScope('validation');\n\n    await fn({ ...deviceAndLimits, testValue, shouldError });\n\n    const validationError = await device.popErrorScope();\n    const outOfMemoryError = await device.popErrorScope();\n    const internalError = await device.popErrorScope();\n\n    this.expect(!validationError, `unexpected validation error: ${validationError?.message || ''}`);\n    this.expect(\n      !outOfMemoryError,\n      `unexpected out-of-memory error: ${outOfMemoryError?.message || ''}`\n    );\n    this.expect(!internalError, `unexpected internal error: ${internalError?.message || ''}`);\n\n    globalThis._TRAMPOLINE_(\"destroy\", device, device.destroy, [], () => device.destroy());\n    this._device = undefined;\n  }\n\n  /**\n   * Creates a device with a specific limit.\n   * If the limit of over the maximum we expect an exception\n   * If the device is created then we call a test function, checking\n   * that the function does not leak any GPU errors.\n   */\n  async testDeviceWithSpecificLimits(\n  deviceLimitValue,\n  testValue,\n  fn,\n  extraLimits,\n  features)\n  {\n    assert(!this._device);\n\n    const deviceAndLimits = await this._getDeviceWithSpecificLimit(\n      deviceLimitValue,\n      extraLimits,\n      features\n    );\n    // If we request over the limit requestDevice will throw\n    if (!deviceAndLimits) {\n      return;\n    }\n\n    await this._testThenDestroyDevice(deviceAndLimits, testValue, fn);\n  }\n\n  /**\n   * Creates a device with the limit defined by LimitValueTest.\n   * If the limit of over the maximum we expect an exception\n   * If the device is created then we call a test function, checking\n   * that the function does not leak any GPU errors.\n   */\n  async testDeviceWithRequestedMaximumLimits(\n  limitTest,\n  testValueName,\n  fn,\n  extraLimits,\n  extraFeatures = [])\n  {\n    assert(!this._device);\n\n    const deviceAndLimits = await this._getDeviceWithRequestedMaximumLimit(\n      limitTest,\n      extraLimits,\n      extraFeatures\n    );\n    // If we request over the limit requestDevice will throw\n    if (!deviceAndLimits) {\n      return;\n    }\n\n    const { actualLimit } = deviceAndLimits;\n    const testValue = getMaximumTestValue(actualLimit, testValueName);\n\n    await this._testThenDestroyDevice(\n      deviceAndLimits,\n      testValue,\n      async (inputs) => {\n        await fn({ ...inputs, testValueName });\n      }\n    );\n  }\n\n  /**\n   * Calls a function that expects a GPU error if shouldError is true\n   */\n  // MAINTENANCE_TODO: Remove this duplicated code with GPUTest if possible\n  async expectGPUErrorAsync(\n  filter,\n  fn,\n  shouldError = true,\n  msg = '')\n  {\n    const { device } = this;\n\n    device.pushErrorScope(filter);\n    const returnValue = fn();\n    if (returnValue instanceof Promise) {\n      await returnValue;\n    }\n\n    const error = await device.popErrorScope();\n    this.expect(\n      !!error === shouldError,\n      `${error?.message || 'no error when one was expected'}: ${msg}`\n    );\n\n    return returnValue;\n  }\n\n  /** Expect that the provided promise rejects, with the provided exception name. */\n  async shouldRejectConditionally(\n  expectedName,\n  p,\n  shouldReject,\n  message)\n  {\n    if (shouldReject) {\n      this.shouldReject(expectedName, p, { message });\n    } else {\n      this.shouldResolve(p, message);\n    }\n\n    // We need to explicitly wait for the promise because the device may be\n    // destroyed immediately after returning from this function.\n    try {\n      await p;\n    } catch (e) {\n\n      //\n    }}\n\n  /**\n   * Calls a function that expects a validation error if shouldError is true\n   */\n  async expectValidationError(\n  fn,\n  shouldError = true,\n  msg = '')\n  {\n    return this.expectGPUErrorAsync('validation', fn, shouldError, msg);\n  }\n\n  /**\n   * Calls a function that expects to not generate a validation error\n   */\n  async expectNoValidationError(fn, msg = '') {\n    return this.expectGPUErrorAsync('validation', fn, false, msg);\n  }\n\n  /**\n   * Calls a function that might expect a validation error.\n   * if shouldError is true then expect a validation error,\n   * if shouldError is false then ignore out-of-memory errors.\n   */\n  async testForValidationErrorWithPossibleOutOfMemoryError(\n  fn,\n  shouldError = true,\n  msg = '')\n  {\n    const { device } = this;\n\n    if (!shouldError) {\n      device.pushErrorScope('out-of-memory');\n      const result = fn();\n      await device.popErrorScope();\n      return result;\n    }\n\n    // Validation should fail before out-of-memory so there is no need to check\n    // for out-of-memory here.\n    device.pushErrorScope('validation');\n    const returnValue = fn();\n    const validationError = await device.popErrorScope();\n\n    this.expect(\n      !!validationError,\n      `${validationError?.message || 'no error when one was expected'}: ${msg}`\n    );\n\n    return returnValue;\n  }\n\n  getGroupIndexWGSLForPipelineType(pipelineType, groupIndex) {\n    switch (pipelineType) {\n      case 'createRenderPipeline':\n        return `\n          @group(${groupIndex}) @binding(0) var<uniform> v: f32;\n          @vertex fn mainVS() -> @builtin(position) vec4f {\n            return vec4f(v);\n          }\n        `;\n      case 'createRenderPipelineWithFragmentStage':\n        return `\n          @group(${groupIndex}) @binding(0) var<uniform> v: f32;\n          @vertex fn mainVS() -> @builtin(position) vec4f {\n            return vec4f(v);\n          }\n          @fragment fn mainFS() -> @location(0) vec4f {\n            return vec4f(1);\n          }\n        `;\n      case 'createComputePipeline':\n        return `\n          @group(${groupIndex}) @binding(0) var<uniform> v: f32;\n          @compute @workgroup_size(1) fn main() {\n            _ = v;\n          }\n        `;\n        break;\n    }\n  }\n\n  getBindingIndexWGSLForPipelineType(pipelineType, bindingIndex) {\n    switch (pipelineType) {\n      case 'createRenderPipeline':\n        return `\n          @group(0) @binding(${bindingIndex}) var<uniform> v: f32;\n          @vertex fn mainVS() -> @builtin(position) vec4f {\n            return vec4f(v);\n          }\n        `;\n      case 'createRenderPipelineWithFragmentStage':\n        return `\n          @group(0) @binding(${bindingIndex}) var<uniform> v: f32;\n          @vertex fn mainVS() -> @builtin(position) vec4f {\n            return vec4f(v);\n          }\n          @fragment fn mainFS() -> @location(0) vec4f {\n            return vec4f(1);\n          }\n        `;\n      case 'createComputePipeline':\n        return `\n          @group(0) @binding(${bindingIndex}) var<uniform> v: f32;\n          @compute @workgroup_size(1) fn main() {\n            _ = v;\n          }\n        `;\n        break;\n    }\n  }\n\n  _createRenderPipelineDescriptor(module) {\n    const { device } = this;\n    return {\n      layout: 'auto',\n      vertex: {\n        module,\n        entryPoint: 'mainVS'\n      },\n      // Specify a color attachment so we have at least one render target.\n      fragment: {\n        targets: [{ format: 'rgba8unorm' }],\n        module: device.createShaderModule({\n          code: `@fragment fn main() -> @location(0) vec4f { return vec4f(0); }`\n        })\n      }\n    };\n  }\n\n  _createRenderPipelineDescriptorWithFragmentShader(\n  module)\n  {\n    return {\n      layout: 'auto',\n      vertex: {\n        module,\n        entryPoint: 'mainVS'\n      },\n      fragment: {\n        module,\n        entryPoint: 'mainFS',\n        targets: []\n      },\n      depthStencil: {\n        format: 'depth24plus-stencil8',\n        depthWriteEnabled: true,\n        depthCompare: 'always'\n      }\n    };\n  }\n\n  _createComputePipelineDescriptor(module) {\n    return {\n      layout: 'auto',\n      compute: {\n        module,\n        entryPoint: 'main'\n      }\n    };\n  }\n\n  createPipeline(createPipelineType, module) {\n    const { device } = this;\n\n    switch (createPipelineType) {\n      case 'createRenderPipeline':\n        return device.createRenderPipeline(this._createRenderPipelineDescriptor(module));\n        break;\n      case 'createRenderPipelineWithFragmentStage':\n        return device.createRenderPipeline(\n          this._createRenderPipelineDescriptorWithFragmentShader(module)\n        );\n        break;\n      case 'createComputePipeline':\n        return device.createComputePipeline(this._createComputePipelineDescriptor(module));\n        break;\n    }\n  }\n\n  createPipelineAsync(createPipelineType, module) {\n    const { device } = this;\n\n    switch (createPipelineType) {\n      case 'createRenderPipeline':\n        return device.createRenderPipelineAsync(this._createRenderPipelineDescriptor(module));\n      case 'createRenderPipelineWithFragmentStage':\n        return device.createRenderPipelineAsync(\n          this._createRenderPipelineDescriptorWithFragmentShader(module)\n        );\n      case 'createComputePipeline':\n        return device.createComputePipelineAsync(this._createComputePipelineDescriptor(module));\n    }\n  }\n\n  async testCreatePipeline(\n  createPipelineType,\n  async,\n  module,\n  shouldError,\n  msg = '')\n  {\n    if (async) {\n      await this.shouldRejectConditionally(\n        'GPUPipelineError',\n        this.createPipelineAsync(createPipelineType, module),\n        shouldError,\n        msg\n      );\n    } else {\n      await this.expectValidationError(\n        () => {\n          this.createPipeline(createPipelineType, module);\n        },\n        shouldError,\n        msg\n      );\n    }\n  }\n\n  async testCreateRenderPipeline(\n  pipelineDescriptor,\n  async,\n  shouldError,\n  msg = '')\n  {\n    const { device } = this;\n    if (async) {\n      await this.shouldRejectConditionally(\n        'GPUPipelineError',\n        device.createRenderPipelineAsync(pipelineDescriptor),\n        shouldError,\n        msg\n      );\n    } else {\n      await this.expectValidationError(\n        () => {\n          device.createRenderPipeline(pipelineDescriptor);\n        },\n        shouldError,\n        msg\n      );\n    }\n  }\n\n  async testMaxComputeWorkgroupSize(\n  limitTest,\n  testValueName,\n  async,\n  axis)\n  {\n    const kExtraLimits = {\n      maxComputeInvocationsPerWorkgroup: 'adapterLimit'\n    };\n\n    await this.testDeviceWithRequestedMaximumLimits(\n      limitTest,\n      testValueName,\n      async ({ device, testValue, actualLimit, shouldError }) => {\n        if (testValue > device.limits.maxComputeInvocationsPerWorkgroup) {\n          return;\n        }\n\n        const size = [1, 1, 1];\n        size[axis.codePointAt(0) - 'X'.codePointAt(0)] = testValue;\n        const { module, code } = this.getModuleForWorkgroupSize(size);\n\n        await this.testCreatePipeline(\n          'createComputePipeline',\n          async,\n          module,\n          shouldError,\n          `size: ${testValue}, limit: ${actualLimit}\\n${code}`\n        );\n      },\n      kExtraLimits\n    );\n  }\n\n  /**\n   * Creates an GPURenderCommandsMixin setup with some initial state.\n   */\n  #getGPURenderCommandsMixin(encoderType) {\n    const { device } = this;\n\n    switch (encoderType) {\n      case 'render':{\n          const buffer = this.createBufferTracked({\n            size: 16,\n            usage: GPUBufferUsage.UNIFORM\n          });\n\n          const texture = this.createTextureTracked({\n            size: [1, 1],\n            format: 'rgba8unorm',\n            usage: GPUTextureUsage.RENDER_ATTACHMENT\n          });\n\n          const layout = device.createBindGroupLayout({\n            entries: [\n            {\n              binding: 0,\n              visibility: GPUShaderStage.VERTEX,\n              buffer: {}\n            }]\n\n          });\n\n          const bindGroup = device.createBindGroup({\n            layout,\n            entries: [\n            {\n              binding: 0,\n              resource: { buffer }\n            }]\n\n          });\n\n          const encoder = globalThis._TRAMPOLINE_(\"createCommandEncoder\", device, device.createCommandEncoder, [], () => device.createCommandEncoder());\n          const passEncoder = encoder.beginRenderPass({\n            colorAttachments: [\n            {\n              view: texture.createView(),\n              loadOp: 'clear',\n              storeOp: 'store'\n            }]\n\n          });\n\n          return {\n            passEncoder,\n            bindGroup,\n            prep() {\n              passEncoder.end();\n            },\n            test() {\n              encoder.finish();\n            }\n          };\n          break;\n        }\n\n      case 'renderBundle':{\n          const buffer = this.createBufferTracked({\n            size: 16,\n            usage: GPUBufferUsage.UNIFORM\n          });\n\n          const layout = device.createBindGroupLayout({\n            entries: [\n            {\n              binding: 0,\n              visibility: GPUShaderStage.VERTEX,\n              buffer: {}\n            }]\n\n          });\n\n          const bindGroup = device.createBindGroup({\n            layout,\n            entries: [\n            {\n              binding: 0,\n              resource: { buffer }\n            }]\n\n          });\n\n          const passEncoder = device.createRenderBundleEncoder({\n            colorFormats: ['rgba8unorm']\n          });\n\n          return {\n            passEncoder,\n            bindGroup,\n            prep() {},\n            test() {\n              passEncoder.finish();\n            }\n          };\n          break;\n        }\n    }\n  }\n\n  /**\n   * Test a method on GPURenderCommandsMixin or GPUBindingCommandsMixin\n   * The function will be called with the passEncoder.\n   */\n  async testGPURenderAndBindingCommandsMixin(\n  encoderType,\n  fn,\n\n\n\n\n\n\n  shouldError,\n  msg = '')\n  {\n    const { passEncoder, prep, test, bindGroup } = this.#getGPURenderCommandsMixin(encoderType);\n    fn({ passEncoder, bindGroup });\n    prep();\n\n    await this.expectValidationError(test, shouldError, msg);\n  }\n\n  /**\n   * Creates GPUBindingCommandsMixin setup with some initial state.\n   */\n  #getGPUBindingCommandsMixin(encoderType) {\n    const { device } = this;\n\n    switch (encoderType) {\n      case 'compute':{\n          const buffer = this.createBufferTracked({\n            size: 16,\n            usage: GPUBufferUsage.UNIFORM\n          });\n\n          const layout = device.createBindGroupLayout({\n            entries: [\n            {\n              binding: 0,\n              visibility: GPUShaderStage.COMPUTE,\n              buffer: {}\n            }]\n\n          });\n\n          const bindGroup = device.createBindGroup({\n            layout,\n            entries: [\n            {\n              binding: 0,\n              resource: { buffer }\n            }]\n\n          });\n\n          const encoder = globalThis._TRAMPOLINE_(\"createCommandEncoder\", device, device.createCommandEncoder, [], () => device.createCommandEncoder());\n          const passEncoder = encoder.beginComputePass();\n          return {\n            passEncoder,\n            bindGroup,\n            prep() {\n              passEncoder.end();\n            },\n            test() {\n              encoder.finish();\n            }\n          };\n          break;\n        }\n      case 'render':\n        return this.#getGPURenderCommandsMixin('render');\n      case 'renderBundle':\n        return this.#getGPURenderCommandsMixin('renderBundle');\n    }\n  }\n\n  /**\n   * Tests a method on GPUBindingCommandsMixin\n   * The function pass will be called with the passEncoder and a bindGroup\n   */\n  async testGPUBindingCommandsMixin(\n  encoderType,\n  fn,\n  shouldError,\n  msg = '')\n  {\n    const { passEncoder, bindGroup, prep, test } = this.#getGPUBindingCommandsMixin(encoderType);\n    fn({ passEncoder, bindGroup });\n    prep();\n\n    await this.expectValidationError(test, shouldError, msg);\n  }\n\n  getModuleForWorkgroupSize(size) {\n    const { device } = this;\n    const code = `\n      @group(0) @binding(0) var<storage, read_write> d: f32;\n      @compute @workgroup_size(${size.join(',')}) fn main() {\n        d = 0;\n      }\n    `;\n    const module = device.createShaderModule({ code });\n    return { module, code };\n  }\n}\n\n/**\n * Makes a new LimitTest class so that the tests have access to `limit`\n */\nfunction makeLimitTestFixture(limit) {\n  class LimitTests extends LimitTestsImpl {\n    limit = limit;\n  }\n\n  return LimitTests;\n}\n\n/**\n * This is to avoid repeating yourself (D.R.Y.) as I ran into that issue multiple times\n * writing these tests where I'd copy a test, need to rename a limit in 3-4 places,\n * forget one place, and then spend 20-30 minutes wondering why the test was failing.\n */\nexport function makeLimitTestGroup(limit) {\n  const description = `API Validation Tests for ${limit}.`;\n  const g = makeTestGroup(makeLimitTestFixture(limit));\n  return { g, description, limit };\n}"],"mappings":"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","ignoreList":[]}