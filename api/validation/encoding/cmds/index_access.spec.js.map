{"version":3,"file":"index_access.spec.js","names":["description","makeTestGroup","ValidationTest","F","createIndexBuffer","indexData","makeBufferWithContents","Uint32Array","GPUBufferUsage","INDEX","createRenderPipeline","device","layout","vertex","module","createShaderModule","code","entryPoint","fragment","targets","format","primitive","topology","stripIndexFormat","beginRenderPass","encoder","colorAttachment","createTextureTracked","size","width","height","depthOrArrayLayers","usage","GPUTextureUsage","RENDER_ATTACHMENT","colorAttachments","view","createView","clearValue","r","g","b","a","loadOp","storeOp","drawIndexed","indexBuffer","indexCount","instanceCount","firstIndex","baseVertex","firstInstance","isSuccess","pipeline","globalThis","_TRAMPOLINE_","createCommandEncoder","pass","setPipeline","setIndexBuffer","end","queue","submit","finish","expectValidationError","test","desc","params","u","combineWithParams","combine","fn","t"],"sources":["../../../../../../src/webgpu/api/validation/encoding/cmds/index_access.spec.ts"],"sourcesContent":["/**\n* AUTO-GENERATED - DO NOT EDIT. Source: https://github.com/gpuweb/cts\n**/export const description = `\nValidation tests for indexed draws accessing the index buffer.\n`;import { makeTestGroup } from '../../../../../common/framework/test_group.js';\nimport { ValidationTest } from '../../validation_test.js';\n\nclass F extends ValidationTest {\n  createIndexBuffer(indexData) {\n    return this.makeBufferWithContents(new Uint32Array(indexData), GPUBufferUsage.INDEX);\n  }\n\n  createRenderPipeline() {\n    return this.device.createRenderPipeline({\n      layout: 'auto',\n      vertex: {\n        module: this.device.createShaderModule({\n          code: `\n            @vertex fn main() -> @builtin(position) vec4<f32> {\n              return vec4<f32>(0.0, 0.0, 0.0, 1.0);\n            }`\n        }),\n        entryPoint: 'main'\n      },\n      fragment: {\n        module: this.device.createShaderModule({\n          code: `\n            @fragment fn main() -> @location(0) vec4<f32> {\n              return vec4<f32>(0.0, 1.0, 0.0, 1.0);\n            }`\n        }),\n        entryPoint: 'main',\n        targets: [{ format: 'rgba8unorm' }]\n      },\n      primitive: {\n        topology: 'triangle-strip',\n        stripIndexFormat: 'uint32'\n      }\n    });\n  }\n\n  beginRenderPass(encoder) {\n    const colorAttachment = this.createTextureTracked({\n      format: 'rgba8unorm',\n      size: { width: 1, height: 1, depthOrArrayLayers: 1 },\n      usage: GPUTextureUsage.RENDER_ATTACHMENT\n    });\n\n    return encoder.beginRenderPass({\n      colorAttachments: [\n      {\n        view: colorAttachment.createView(),\n        clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 },\n        loadOp: 'clear',\n        storeOp: 'store'\n      }]\n\n    });\n  }\n\n  drawIndexed(\n  indexBuffer,\n  indexCount,\n  instanceCount,\n  firstIndex,\n  baseVertex,\n  firstInstance,\n  isSuccess)\n  {\n    const pipeline = this.createRenderPipeline();\n\n    const encoder = globalThis._TRAMPOLINE_(\"createCommandEncoder\", this.device, this.device.createCommandEncoder, [], () => this.device.createCommandEncoder());\n    const pass = this.beginRenderPass(encoder);\n    pass.setPipeline(pipeline);\n    pass.setIndexBuffer(indexBuffer, 'uint32');\n    pass.drawIndexed(indexCount, instanceCount, firstIndex, baseVertex, firstInstance);\n    pass.end();\n\n    if (isSuccess) {\n      globalThis._TRAMPOLINE_(\"submit\", this.device, this.device.queue.submit, [[encoder.finish()]], () => this.device.queue.submit([encoder.finish()]));\n    } else {\n      this.expectValidationError(() => {\n        encoder.finish();\n      });\n    }\n  }\n}\n\nexport const g = makeTestGroup(F);\n\ng.test('out_of_bounds').\ndesc(\n  `Test drawing with out of bound index access to make sure encoder validation catch the\n    following indexCount and firstIndex OOB conditions\n    - either is within bound but indexCount + firstIndex is out of bound\n    - only firstIndex is out of bound\n    - only indexCount is out of bound\n    - firstIndex much larger than indexCount\n    - indexCount much larger than firstIndex\n    - max uint32 value for both to make sure the sum doesn't overflow\n    - max uint32 indexCount and small firstIndex\n    - max uint32 firstIndex and small indexCount\n    Together with normal and large instanceCount`\n).\nparams(\n  (u) =>\n  u.\n  combineWithParams([\n  { indexCount: 6, firstIndex: 0 }, // draw all 6 out of 6 index\n  { indexCount: 5, firstIndex: 1 }, // draw the last 5 out of 6 index\n  { indexCount: 1, firstIndex: 5 }, // draw the last 1 out of 6 index\n  { indexCount: 0, firstIndex: 6 }, // firstIndex point to the one after last, but (indexCount + firstIndex) * stride <= bufferSize, valid\n  { indexCount: 0, firstIndex: 7 }, // (indexCount + firstIndex) * stride > bufferSize, invalid\n  { indexCount: 7, firstIndex: 0 }, // only indexCount out of bound\n  { indexCount: 6, firstIndex: 1 }, // indexCount + firstIndex out of bound\n  { indexCount: 1, firstIndex: 6 }, // indexCount valid, but (indexCount + firstIndex) out of bound\n  { indexCount: 6, firstIndex: 10000 }, // firstIndex much larger than the bound\n  { indexCount: 10000, firstIndex: 0 }, // indexCount much larger than the bound\n  { indexCount: 0xffffffff, firstIndex: 0xffffffff }, // max uint32 value\n  { indexCount: 0xffffffff, firstIndex: 2 }, // max uint32 indexCount and small firstIndex\n  { indexCount: 2, firstIndex: 0xffffffff } // small indexCount and max uint32 firstIndex\n  ]).\n  combine('instanceCount', [1, 10000]) // normal and large instanceCount\n).\nfn((t) => {\n  const { indexCount, firstIndex, instanceCount } = t.params;\n\n  const indexBuffer = t.createIndexBuffer([0, 1, 2, 3, 1, 2]);\n  const isSuccess = indexCount + firstIndex <= 6;\n\n  t.drawIndexed(indexBuffer, indexCount, instanceCount, firstIndex, 0, 0, isSuccess);\n});\n\ng.test('out_of_bounds_zero_sized_index_buffer').\ndesc(\n  `Test drawing with an empty index buffer to make sure the encoder validation catch the\n    following indexCount and firstIndex conditions\n    - indexCount + firstIndex is out of bound\n    - indexCount is 0 but firstIndex is out of bound\n    - only indexCount is out of bound\n    - both are 0s (not out of bound) but index buffer size is 0\n    Together with normal and large instanceCount`\n).\nparams(\n  (u) =>\n  u.\n  combineWithParams([\n  { indexCount: 3, firstIndex: 1 }, // indexCount + firstIndex out of bound\n  { indexCount: 0, firstIndex: 1 }, // indexCount is 0 but firstIndex out of bound\n  { indexCount: 3, firstIndex: 0 }, // only indexCount out of bound\n  { indexCount: 0, firstIndex: 0 } // just zeros, valid\n  ]).\n  combine('instanceCount', [1, 10000]) // normal and large instanceCount\n).\nfn((t) => {\n  const { indexCount, firstIndex, instanceCount } = t.params;\n\n  const indexBuffer = t.createIndexBuffer([]);\n  const isSuccess = indexCount + firstIndex <= 0;\n\n  t.drawIndexed(indexBuffer, indexCount, instanceCount, firstIndex, 0, 0, isSuccess);\n});"],"mappings":"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","ignoreList":[]}