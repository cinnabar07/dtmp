{"version":3,"file":"image_copy.js","names":["depthStencilFormatCopyableAspects","kTextureFormatInfo","isCompressedTextureFormat","align","ValidationTest","ImageCopyTest","testRun","textureCopyView","textureDataLayout","size","method","dataSize","success","submit","data","Uint8Array","expectValidationError","device","queue","writeTexture","buffer","createBufferTracked","usage","GPUBufferUsage","COPY_SRC","encoder","globalThis","_TRAMPOLINE_","createCommandEncoder","copyBufferToTexture","cmd","finish","isCompatibility","texture","format","skip","COPY_DST","copyTextureToBuffer","createAlignedTexture","width","height","depthOrArrayLayers","origin","x","y","z","dimension","info","alignedSize","Math","max","blockWidth","blockHeight","createTextureTracked","GPUTextureUsage","testBuffer","validateFinish","validateFinishAndSubmit","createEncoder","valuesToTestDivisibilityBy","number","values","i","push","texelBlockAlignmentTestExpanderForOffset","depth","stencil","bytesPerBlock","texelBlockAlignmentTestExpanderForRowsPerImage","texelBlockAlignmentTestExpanderForValueToCoordinate","coordinateToTest","formatCopyableWithMethod","supportedAspects","length","color","copySrc","copyDst","getACopyableAspectWithMethod"],"sources":["../../../../../src/webgpu/api/validation/image_copy/image_copy.ts"],"sourcesContent":["/**\n* AUTO-GENERATED - DO NOT EDIT. Source: https://github.com/gpuweb/cts\n**/import { depthStencilFormatCopyableAspects,\n\n  kTextureFormatInfo,\n  isCompressedTextureFormat } from\n'../../../format_info.js';\nimport { align } from '../../../util/math.js';\n\nimport { ValidationTest } from '../validation_test.js';\n\nexport class ImageCopyTest extends ValidationTest {\n  testRun(\n  textureCopyView,\n  textureDataLayout,\n  size,\n  {\n    method,\n    dataSize,\n    success,\n    submit = false\n\n\n\n\n\n\n\n  })\n  {\n    switch (method) {\n      case 'WriteTexture':{\n          const data = new Uint8Array(dataSize);\n\n          this.expectValidationError(() => {\n            this.device.queue.writeTexture(textureCopyView, data, textureDataLayout, size);\n          }, !success);\n\n          break;\n        }\n      case 'CopyB2T':{\n          const buffer = this.createBufferTracked({\n            size: dataSize,\n            usage: GPUBufferUsage.COPY_SRC\n          });\n\n          const encoder = globalThis._TRAMPOLINE_(\"createCommandEncoder\", this.device, this.device.createCommandEncoder, [], () => this.device.createCommandEncoder());\n          encoder.copyBufferToTexture({ buffer, ...textureDataLayout }, textureCopyView, size);\n\n          if (submit) {\n            const cmd = encoder.finish();\n            this.expectValidationError(() => {\n              globalThis._TRAMPOLINE_(\"submit\", this.device, this.device.queue.submit, [[cmd]], () => this.device.queue.submit([cmd]));\n            }, !success);\n          } else {\n            this.expectValidationError(() => {\n              encoder.finish();\n            }, !success);\n          }\n\n          break;\n        }\n      case 'CopyT2B':{\n          if (this.isCompatibility && isCompressedTextureFormat(textureCopyView.texture.format)) {\n            this.skip(\n              'copyTextureToBuffer is not supported for compressed texture formats in compatibility mode.'\n            );\n          }\n          const buffer = this.createBufferTracked({\n            size: dataSize,\n            usage: GPUBufferUsage.COPY_DST\n          });\n\n          const encoder = globalThis._TRAMPOLINE_(\"createCommandEncoder\", this.device, this.device.createCommandEncoder, [], () => this.device.createCommandEncoder());\n          encoder.copyTextureToBuffer(textureCopyView, { buffer, ...textureDataLayout }, size);\n\n          if (submit) {\n            const cmd = encoder.finish();\n            this.expectValidationError(() => {\n              globalThis._TRAMPOLINE_(\"submit\", this.device, this.device.queue.submit, [[cmd]], () => this.device.queue.submit([cmd]));\n            }, !success);\n          } else {\n            this.expectValidationError(() => {\n              encoder.finish();\n            }, !success);\n          }\n\n          break;\n        }\n    }\n  }\n\n  /**\n   * Creates a texture when all that is needed is an aligned texture given the format and desired\n   * dimensions/origin. The resultant texture guarantees that a copy with the same size and origin\n   * should be possible.\n   */\n  createAlignedTexture(\n  format,\n  size = {\n    width: 1,\n    height: 1,\n    depthOrArrayLayers: 1\n  },\n  origin = { x: 0, y: 0, z: 0 },\n  dimension = '2d')\n  {\n    const info = kTextureFormatInfo[format];\n    const alignedSize = {\n      width: align(Math.max(1, size.width + origin.x), info.blockWidth),\n      height: align(Math.max(1, size.height + origin.y), info.blockHeight),\n      depthOrArrayLayers: Math.max(1, size.depthOrArrayLayers + origin.z)\n    };\n    return this.createTextureTracked({\n      size: alignedSize,\n      dimension,\n      format,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST\n    });\n  }\n\n  testBuffer(\n  buffer,\n  texture,\n  textureDataLayout,\n  size,\n  {\n    method,\n    dataSize,\n    success,\n    submit = true\n\n\n\n\n\n\n\n  })\n  {\n    switch (method) {\n      case 'WriteTexture':{\n          const data = new Uint8Array(dataSize);\n\n          this.expectValidationError(() => {\n            this.device.queue.writeTexture({ texture }, data, textureDataLayout, size);\n          }, !success);\n\n          break;\n        }\n      case 'CopyB2T':{\n          const { encoder, validateFinish, validateFinishAndSubmit } = this.createEncoder('non-pass');\n          encoder.copyBufferToTexture({ buffer, ...textureDataLayout }, { texture }, size);\n\n          if (submit) {\n            // validation error is expected to come from the submit and encoding should succeed\n            validateFinishAndSubmit(true, success);\n          } else {\n            // validation error is expected to come from the encoding\n            validateFinish(success);\n          }\n\n          break;\n        }\n      case 'CopyT2B':{\n          if (this.isCompatibility && isCompressedTextureFormat(texture.format)) {\n            this.skip(\n              'copyTextureToBuffer is not supported for compressed texture formats in compatibility mode.'\n            );\n          }\n          const { encoder, validateFinish, validateFinishAndSubmit } = this.createEncoder('non-pass');\n          encoder.copyTextureToBuffer({ texture }, { buffer, ...textureDataLayout }, size);\n\n          if (submit) {\n            // validation error is expected to come from the submit and encoding should succeed\n            validateFinishAndSubmit(true, success);\n          } else {\n            // validation error is expected to come from the encoding\n            validateFinish(success);\n          }\n\n          break;\n        }\n    }\n  }\n}\n\n// For testing divisibility by a number we test all the values returned by this function:\nfunction valuesToTestDivisibilityBy(number) {\n  const values = [];\n  for (let i = 0; i <= 2 * number; ++i) {\n    values.push(i);\n  }\n  values.push(3 * number);\n  return values;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n// This is a helper function used for expanding test parameters for offset alignment, by spec\nexport function texelBlockAlignmentTestExpanderForOffset({ format }) {\n  const info = kTextureFormatInfo[format];\n  if (info.depth || info.stencil) {\n    return valuesToTestDivisibilityBy(4);\n  }\n\n  return valuesToTestDivisibilityBy(kTextureFormatInfo[format].bytesPerBlock);\n}\n\n// This is a helper function used for expanding test parameters for texel block alignment tests on rowsPerImage\nexport function texelBlockAlignmentTestExpanderForRowsPerImage({ format }) {\n  return valuesToTestDivisibilityBy(kTextureFormatInfo[format].blockHeight);\n}\n\n// This is a helper function used for expanding test parameters for texel block alignment tests on origin and size\nexport function texelBlockAlignmentTestExpanderForValueToCoordinate({\n  format,\n  coordinateToTest\n}) {\n  switch (coordinateToTest) {\n    case 'x':\n    case 'width':\n      return valuesToTestDivisibilityBy(kTextureFormatInfo[format].blockWidth);\n\n    case 'y':\n    case 'height':\n      return valuesToTestDivisibilityBy(kTextureFormatInfo[format].blockHeight);\n\n    case 'z':\n    case 'depthOrArrayLayers':\n      return valuesToTestDivisibilityBy(1);\n  }\n}\n\n// This is a helper function used for filtering test parameters\nexport function formatCopyableWithMethod({ format, method }) {\n  const info = kTextureFormatInfo[format];\n  if (info.depth || info.stencil) {\n    const supportedAspects = depthStencilFormatCopyableAspects(\n      method,\n      format\n    );\n    return supportedAspects.length > 0;\n  }\n  if (method === 'CopyT2B') {\n    return info.color.copySrc;\n  } else {\n    return info.color.copyDst;\n  }\n}\n\n// This is a helper function used for filtering test parameters\nexport function getACopyableAspectWithMethod({\n  format,\n  method\n}) {\n  const info = kTextureFormatInfo[format];\n  if (info.depth || info.stencil) {\n    const supportedAspects = depthStencilFormatCopyableAspects(\n      method,\n      format\n    );\n    return supportedAspects[0];\n  }\n  return 'all';\n}"],"mappings":"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","ignoreList":[]}