{"version":3,"file":"layout_related.spec.js","names":["description","makeTestGroup","assert","kTextureDimensions","kTextureFormatInfo","kSizedTextureFormats","textureDimensionAndFormatCompatible","align","bytesInACompleteRow","dataBytesForCopyOrOverestimate","dataBytesForCopyOrFail","kImageCopyTypes","ImageCopyTest","texelBlockAlignmentTestExpanderForOffset","texelBlockAlignmentTestExpanderForRowsPerImage","formatCopyableWithMethod","g","test","desc","params","u","combine","combineWithParams","dimension","size","beginSubcases","undefined","unless","p","copyHeightInBlocks","copyDepth","fn","t","rowsPerImage","method","format","copyHeight","blockHeight","texture","createTextureTracked","usage","GPUTextureUsage","COPY_SRC","COPY_DST","layout","bytesPerRow","copySize","width","height","depthOrArrayLayers","minDataSizeOrOverestimate","copyValid","testRun","dataSize","success","_success","filter","bytesPerRowPadding","rowsPerImagePaddingInBlocks","copyWidthInBlocks","_offsetMultiplier","info","depth","stencil","expand","color","bytes","beforeAllSubcases","skipIfTextureFormatNotSupported","selectDeviceOrSkipTestCase","feature","offset","bytesPerRowAlignment","copyWidth","blockWidth","minDataSize","createAlignedTexture","bytesPerBlock","expandWithParams","widthInBlocks","offsetInBlocks","dataSizeInBlocks"],"sources":["../../../../../src/webgpu/api/validation/image_copy/layout_related.spec.ts"],"sourcesContent":["/**\n* AUTO-GENERATED - DO NOT EDIT. Source: https://github.com/gpuweb/cts\n**/export const description = `Validation tests for the linear data layout of linear data <-> texture copies\n\nTODO check if the tests need to be updated to support aspects of depth-stencil textures`;import { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { assert } from '../../../../common/util/util.js';\nimport { kTextureDimensions } from '../../../capability_info.js';\nimport {\n  kTextureFormatInfo,\n  kSizedTextureFormats,\n  textureDimensionAndFormatCompatible } from\n'../../../format_info.js';\nimport { align } from '../../../util/math.js';\nimport {\n  bytesInACompleteRow,\n  dataBytesForCopyOrOverestimate,\n  dataBytesForCopyOrFail,\n  kImageCopyTypes } from\n'../../../util/texture/layout.js';\n\nimport {\n  ImageCopyTest,\n  texelBlockAlignmentTestExpanderForOffset,\n  texelBlockAlignmentTestExpanderForRowsPerImage,\n  formatCopyableWithMethod } from\n'./image_copy.js';\n\nexport const g = makeTestGroup(ImageCopyTest);\n\ng.test('bound_on_rows_per_image').\ndesc(\n  `\nTest that rowsPerImage must be at least the copy height (if defined).\n- for various copy methods\n- for all texture dimensions\n- for various values of rowsPerImage including undefined\n- for various copy heights\n- for various copy depths\n`\n).\nparams((u) =>\nu.\ncombine('method', kImageCopyTypes).\ncombineWithParams([\n{ dimension: '1d', size: [4, 1, 1] },\n{ dimension: '2d', size: [4, 4, 1] },\n{ dimension: '2d', size: [4, 4, 3] },\n{ dimension: '3d', size: [4, 4, 3] }]\n).\nbeginSubcases().\ncombine('rowsPerImage', [undefined, 0, 1, 2, 1024]).\ncombine('copyHeightInBlocks', [0, 1, 2]).\ncombine('copyDepth', [1, 3]).\nunless((p) => p.dimension === '1d' && p.copyHeightInBlocks !== 1).\nunless((p) => p.copyDepth > p.size[2])\n).\nfn((t) => {\n  const { rowsPerImage, copyHeightInBlocks, copyDepth, dimension, size, method } = t.params;\n\n  const format = 'rgba8unorm';\n  const copyHeight = copyHeightInBlocks * kTextureFormatInfo[format].blockHeight;\n\n  const texture = t.createTextureTracked({\n    size,\n    dimension,\n    format,\n    usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST\n  });\n\n  const layout = { bytesPerRow: 1024, rowsPerImage };\n  const copySize = { width: 0, height: copyHeight, depthOrArrayLayers: copyDepth };\n  const { minDataSizeOrOverestimate, copyValid } = dataBytesForCopyOrOverestimate({\n    layout,\n    format,\n    copySize,\n    method\n  });\n\n  t.testRun({ texture }, layout, copySize, {\n    dataSize: minDataSizeOrOverestimate,\n    method,\n    success: copyValid\n  });\n});\n\ng.test('copy_end_overflows_u64').\ndesc(\n  `\nTest an error is produced when offset+requiredBytesInCopy overflows GPUSize64.\n- for various copy methods\n`\n).\nparams((u) =>\nu.\ncombine('method', kImageCopyTypes).\nbeginSubcases().\ncombineWithParams([\n{ bytesPerRow: 2 ** 31, rowsPerImage: 2 ** 31, depthOrArrayLayers: 1, _success: true }, // success case\n{ bytesPerRow: 2 ** 31, rowsPerImage: 2 ** 31, depthOrArrayLayers: 16, _success: false } // bytesPerRow * rowsPerImage * (depthOrArrayLayers - 1) overflows.\n])\n).\nfn((t) => {\n  const { method, bytesPerRow, rowsPerImage, depthOrArrayLayers, _success } = t.params;\n\n  const texture = t.createTextureTracked({\n    size: [1, 1, depthOrArrayLayers],\n    format: 'rgba8unorm',\n    usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST\n  });\n\n  t.testRun(\n    { texture },\n    { bytesPerRow, rowsPerImage },\n    { width: 1, height: 1, depthOrArrayLayers },\n    {\n      dataSize: 10000,\n      method,\n      success: _success\n    }\n  );\n});\n\ng.test('required_bytes_in_copy').\ndesc(\n  `\nTest the computation of requiredBytesInCopy by computing the minimum data size for the copy and checking success/error at the boundary.\n- for various copy methods\n- for all formats\n- for all dimensions\n- for various extra bytesPerRow/rowsPerImage\n- for various copy sizes\n- for various offsets in the linear data\n`\n).\nparams((u) =>\nu.\ncombine('method', kImageCopyTypes).\ncombine('format', kSizedTextureFormats).\nfilter(formatCopyableWithMethod).\ncombine('dimension', kTextureDimensions).\nfilter(({ dimension, format }) => textureDimensionAndFormatCompatible(dimension, format)).\nbeginSubcases().\ncombineWithParams([\n{ bytesPerRowPadding: 0, rowsPerImagePaddingInBlocks: 0 }, // no padding\n{ bytesPerRowPadding: 0, rowsPerImagePaddingInBlocks: 6 }, // rowsPerImage padding\n{ bytesPerRowPadding: 6, rowsPerImagePaddingInBlocks: 0 }, // bytesPerRow padding\n{ bytesPerRowPadding: 15, rowsPerImagePaddingInBlocks: 17 } // both paddings\n]).\ncombineWithParams([\n{ copyWidthInBlocks: 3, copyHeightInBlocks: 4, copyDepth: 5, _offsetMultiplier: 0 }, // standard copy\n{ copyWidthInBlocks: 5, copyHeightInBlocks: 4, copyDepth: 3, _offsetMultiplier: 11 }, // standard copy, offset > 0\n{ copyWidthInBlocks: 256, copyHeightInBlocks: 3, copyDepth: 2, _offsetMultiplier: 0 }, // copyWidth is 256-aligned\n{ copyWidthInBlocks: 0, copyHeightInBlocks: 4, copyDepth: 5, _offsetMultiplier: 0 }, // empty copy because of width\n{ copyWidthInBlocks: 3, copyHeightInBlocks: 0, copyDepth: 5, _offsetMultiplier: 0 }, // empty copy because of height\n{ copyWidthInBlocks: 3, copyHeightInBlocks: 4, copyDepth: 0, _offsetMultiplier: 13 }, // empty copy because of depth, offset > 0\n{ copyWidthInBlocks: 1, copyHeightInBlocks: 4, copyDepth: 5, _offsetMultiplier: 0 }, // copyWidth = 1\n{ copyWidthInBlocks: 3, copyHeightInBlocks: 1, copyDepth: 5, _offsetMultiplier: 15 }, // copyHeight = 1, offset > 0\n{ copyWidthInBlocks: 5, copyHeightInBlocks: 4, copyDepth: 1, _offsetMultiplier: 0 }, // copyDepth = 1\n{ copyWidthInBlocks: 7, copyHeightInBlocks: 1, copyDepth: 1, _offsetMultiplier: 0 } // copyHeight = 1 and copyDepth = 1\n])\n// The test texture size will be rounded up from the copy size to the next valid texture size.\n// If the format is a depth/stencil format, its copy size must equal to subresource's size.\n// So filter out depth/stencil cases where the rounded-up texture size would be different from the copy size.\n.filter(({ format, copyWidthInBlocks, copyHeightInBlocks, copyDepth }) => {\n  const info = kTextureFormatInfo[format];\n  return (\n    !info.depth && !info.stencil ||\n    copyWidthInBlocks > 0 && copyHeightInBlocks > 0 && copyDepth > 0);\n\n}).\nunless((p) => p.dimension === '1d' && (p.copyHeightInBlocks > 1 || p.copyDepth > 1)).\nexpand('offset', (p) => {\n  const info = kTextureFormatInfo[p.format];\n  if (info.depth || info.stencil) {\n    return [p._offsetMultiplier * 4];\n  }\n  return [p._offsetMultiplier * info.color.bytes];\n})\n).\nbeforeAllSubcases((t) => {\n  const info = kTextureFormatInfo[t.params.format];\n  t.skipIfTextureFormatNotSupported(t.params.format);\n  t.selectDeviceOrSkipTestCase(info.feature);\n}).\nfn((t) => {\n  const {\n    offset,\n    bytesPerRowPadding,\n    rowsPerImagePaddingInBlocks,\n    copyWidthInBlocks,\n    copyHeightInBlocks,\n    copyDepth,\n    format,\n    dimension,\n    method\n  } = t.params;\n  const info = kTextureFormatInfo[format];\n\n  // In the CopyB2T and CopyT2B cases we need to have bytesPerRow 256-aligned,\n  // to make this happen we align the bytesInACompleteRow value and multiply\n  // bytesPerRowPadding by 256.\n  const bytesPerRowAlignment = method === 'WriteTexture' ? 1 : 256;\n  const copyWidth = copyWidthInBlocks * info.blockWidth;\n  const copyHeight = copyHeightInBlocks * info.blockHeight;\n  const rowsPerImage = copyHeight + rowsPerImagePaddingInBlocks * info.blockHeight;\n  const bytesPerRow =\n  align(bytesInACompleteRow(copyWidth, format), bytesPerRowAlignment) +\n  bytesPerRowPadding * bytesPerRowAlignment;\n  const copySize = { width: copyWidth, height: copyHeight, depthOrArrayLayers: copyDepth };\n\n  const layout = { offset, bytesPerRow, rowsPerImage };\n  const minDataSize = dataBytesForCopyOrFail({ layout, format, copySize, method });\n\n  const texture = t.createAlignedTexture(format, copySize, undefined, dimension);\n\n  t.testRun({ texture }, layout, copySize, {\n    dataSize: minDataSize,\n    method,\n    success: true\n  });\n\n  if (minDataSize > 0) {\n    t.testRun({ texture }, layout, copySize, {\n      dataSize: minDataSize - 1,\n      method,\n      success: false\n    });\n  }\n});\n\ng.test('rows_per_image_alignment').\ndesc(\n  `\nTest that rowsPerImage has no alignment constraints.\n- for various copy methods\n- for all sized format\n- for all dimensions\n- for various rowsPerImage\n`\n).\nparams((u) =>\nu.\ncombine('method', kImageCopyTypes).\ncombine('format', kSizedTextureFormats).\nfilter(formatCopyableWithMethod).\ncombine('dimension', kTextureDimensions).\nfilter(({ dimension, format }) => textureDimensionAndFormatCompatible(dimension, format)).\nbeginSubcases().\nexpand('rowsPerImage', texelBlockAlignmentTestExpanderForRowsPerImage)\n// Copy height is info.blockHeight, so rowsPerImage must be equal or greater than it.\n.filter(({ rowsPerImage, format }) => rowsPerImage >= kTextureFormatInfo[format].blockHeight)\n).\nbeforeAllSubcases((t) => {\n  const info = kTextureFormatInfo[t.params.format];\n  t.skipIfTextureFormatNotSupported(t.params.format);\n  t.selectDeviceOrSkipTestCase(info.feature);\n}).\nfn((t) => {\n  const { rowsPerImage, format, method } = t.params;\n  const info = kTextureFormatInfo[format];\n\n  const size = { width: info.blockWidth, height: info.blockHeight, depthOrArrayLayers: 1 };\n  const texture = t.createTextureTracked({\n    size,\n    format,\n    usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST\n  });\n\n  t.testRun({ texture }, { bytesPerRow: 256, rowsPerImage }, size, {\n    dataSize: info.bytesPerBlock,\n    method,\n    success: true\n  });\n});\n\ng.test('offset_alignment').\ndesc(\n  `\nTest the alignment requirement on the linear data offset (block size, or 4 for depth-stencil).\n- for various copy methods\n- for all sized formats\n- for all dimensions\n- for various linear data offsets\n`\n).\nparams((u) =>\nu.\ncombine('method', kImageCopyTypes).\ncombine('format', kSizedTextureFormats).\nfilter(formatCopyableWithMethod).\ncombine('dimension', kTextureDimensions).\nfilter(({ dimension, format }) => textureDimensionAndFormatCompatible(dimension, format)).\nbeginSubcases().\nexpand('offset', texelBlockAlignmentTestExpanderForOffset)\n).\nbeforeAllSubcases((t) => {\n  const info = kTextureFormatInfo[t.params.format];\n  t.skipIfTextureFormatNotSupported(t.params.format);\n  t.selectDeviceOrSkipTestCase(info.feature);\n}).\nfn((t) => {\n  const { format, offset, method } = t.params;\n  const info = kTextureFormatInfo[format];\n\n  const size = { width: info.blockWidth, height: info.blockHeight, depthOrArrayLayers: 1 };\n  const texture = t.createTextureTracked({\n    size,\n    format,\n    usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST\n  });\n\n  let success = false;\n  if (method === 'WriteTexture') success = true;\n  if (info.depth || info.stencil) {\n    if (offset % 4 === 0) success = true;\n  } else {\n    if (offset % info.color.bytes === 0) success = true;\n  }\n\n  t.testRun({ texture }, { offset, bytesPerRow: 256 }, size, {\n    dataSize: offset + info.bytesPerBlock,\n    method,\n    success\n  });\n});\n\ng.test('bound_on_bytes_per_row').\ndesc(\n  `\nTest that bytesPerRow, if specified must be big enough for a full copy row.\n- for various copy methods\n- for all sized formats\n- for all dimension\n- for various copy heights\n- for various copy depths\n- for various combinations of bytesPerRow and copy width.\n`\n).\nparams((u) =>\nu.\ncombine('method', kImageCopyTypes).\ncombine('format', kSizedTextureFormats).\nfilter(formatCopyableWithMethod).\ncombine('dimension', kTextureDimensions).\nfilter(({ dimension, format }) => textureDimensionAndFormatCompatible(dimension, format)).\nbeginSubcases().\ncombine('copyHeightInBlocks', [1, 2]).\ncombine('copyDepth', [1, 2]).\nunless((p) => p.dimension === '1d' && (p.copyHeightInBlocks > 1 || p.copyDepth > 1)).\nexpandWithParams((p) => {\n  const info = kTextureFormatInfo[p.format];\n  // We currently have a built-in assumption that for all formats, 128 % bytesPerBlock === 0.\n  // This assumption ensures that all division below results in integers.\n  assert(128 % info.bytesPerBlock === 0);\n  return [\n  // Copying exact fit with aligned bytesPerRow should work.\n  {\n    bytesPerRow: 256,\n    widthInBlocks: 256 / info.bytesPerBlock,\n    copyWidthInBlocks: 256 / info.bytesPerBlock,\n    _success: true\n  },\n  // Copying into smaller texture when padding in bytesPerRow is enough should work unless\n  // it is a depth/stencil typed format.\n  {\n    bytesPerRow: 256,\n    widthInBlocks: 256 / info.bytesPerBlock,\n    copyWidthInBlocks: 256 / info.bytesPerBlock - 1,\n    _success: !(info.stencil || info.depth)\n  },\n  // Unaligned bytesPerRow should not work unless the method is 'WriteTexture'.\n  {\n    bytesPerRow: 128,\n    widthInBlocks: 128 / info.bytesPerBlock,\n    copyWidthInBlocks: 128 / info.bytesPerBlock,\n    _success: p.method === 'WriteTexture'\n  },\n  {\n    bytesPerRow: 384,\n    widthInBlocks: 384 / info.bytesPerBlock,\n    copyWidthInBlocks: 384 / info.bytesPerBlock,\n    _success: p.method === 'WriteTexture'\n  },\n  // When bytesPerRow is smaller than bytesInLastRow copying should fail.\n  {\n    bytesPerRow: 256,\n    widthInBlocks: 2 * 256 / info.bytesPerBlock,\n    copyWidthInBlocks: 2 * 256 / info.bytesPerBlock,\n    _success: false\n  },\n  // When copyHeightInBlocks > 1, bytesPerRow must be specified.\n  {\n    bytesPerRow: undefined,\n    widthInBlocks: 256 / info.bytesPerBlock,\n    copyWidthInBlocks: 256 / info.bytesPerBlock,\n    _success: !(p.copyHeightInBlocks > 1 || p.copyDepth > 1)\n  }];\n\n})\n).\nbeforeAllSubcases((t) => {\n  const info = kTextureFormatInfo[t.params.format];\n  t.skipIfTextureFormatNotSupported(t.params.format);\n  t.selectDeviceOrSkipTestCase(info.feature);\n}).\nfn((t) => {\n  const {\n    method,\n    format,\n    bytesPerRow,\n    widthInBlocks,\n    copyWidthInBlocks,\n    copyHeightInBlocks,\n    copyDepth,\n    _success\n  } = t.params;\n  const info = kTextureFormatInfo[format];\n\n  // We create an aligned texture using the widthInBlocks which may be different from the\n  // copyWidthInBlocks. This allows us to test scenarios where the two may be different.\n  const texture = t.createAlignedTexture(format, {\n    width: widthInBlocks * info.blockWidth,\n    height: copyHeightInBlocks * info.blockHeight,\n    depthOrArrayLayers: copyDepth\n  });\n\n  const layout = { bytesPerRow, rowsPerImage: copyHeightInBlocks };\n  const copySize = {\n    width: copyWidthInBlocks * info.blockWidth,\n    height: copyHeightInBlocks * info.blockHeight,\n    depthOrArrayLayers: copyDepth\n  };\n  const { minDataSizeOrOverestimate } = dataBytesForCopyOrOverestimate({\n    layout,\n    format,\n    copySize,\n    method\n  });\n\n  t.testRun({ texture }, layout, copySize, {\n    dataSize: minDataSizeOrOverestimate,\n    method,\n    success: _success\n  });\n});\n\ng.test('bound_on_offset').\ndesc(\n  `\nTest that the offset cannot be larger than the linear data size (even for an empty copy).\n- for various offsets and data sizes\n`\n).\nparams((u) =>\nu.\ncombine('method', kImageCopyTypes).\nbeginSubcases().\ncombine('offsetInBlocks', [0, 1, 2]).\ncombine('dataSizeInBlocks', [0, 1, 2])\n).\nfn((t) => {\n  const { offsetInBlocks, dataSizeInBlocks, method } = t.params;\n\n  const format = 'rgba8unorm';\n  const info = kTextureFormatInfo[format];\n  const offset = offsetInBlocks * info.color.bytes;\n  const dataSize = dataSizeInBlocks * info.color.bytes;\n\n  const texture = t.createTextureTracked({\n    size: { width: 4, height: 4, depthOrArrayLayers: 1 },\n    format,\n    usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST\n  });\n\n  const success = offset <= dataSize;\n\n  t.testRun(\n    { texture },\n    { offset, bytesPerRow: 0 },\n    { width: 0, height: 0, depthOrArrayLayers: 0 },\n    { dataSize, method, success }\n  );\n});"],"mappings":"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","ignoreList":[]}