{"version":3,"file":"layout_shader_compat.spec.js","names":["description","makeTestGroup","kShaderStageCombinations","kShaderStages","GPUConst","ValidationTest","kBindableResources","bindGroupLayoutEntryContents","compareSamp","sampler","type","filtSamp","nonFiltSamp","sampledTex","texture","sampleType","sampledTexMS","multisampled","storageBuf","buffer","readonlyStorageBuf","uniformBuf","readonlyStorageTex","storageTexture","format","access","writeonlyStorageTex","readwriteStorageTex","F","createPipelineLayout","bindingInPipelineLayout","visibility","device","bindGroupLayouts","createBindGroupLayout","entries","binding","GetBindableResourceShaderDeclaration","bindableResource","BindingResourceCompatibleWithShaderStages","bindingResource","shaderStages","ShaderStage","VERTEX","g","test","desc","params","u","combine","beginSubcases","unless","p","bindingInShader","pipelineLayoutVisibility","shaderStageWithBinding","fn","t","isBindingStaticallyUsed","layout","bindResourceDeclaration","staticallyUseBinding","isAsync","success","COMPUTE","computeShader","doCreateComputePipelineTest","compute","module","createShaderModule","code","vertexShader","doCreateRenderPipelineTest","vertex","depthStencil","depthWriteEnabled","depthCompare","FRAGMENT","fragmentShader","fragment","targets"],"sources":["../../../../src/webgpu/api/validation/layout_shader_compat.spec.ts"],"sourcesContent":["/**\n* AUTO-GENERATED - DO NOT EDIT. Source: https://github.com/gpuweb/cts\n**/export const description = `\nTODO:\n- interface matching between pipeline layout and shader\n    - x= bind group index values, binding index values, multiple bindings\n    - x= {superset, subset}\n`;import { makeTestGroup } from '../../../common/framework/test_group.js';\nimport {\n  kShaderStageCombinations,\n  kShaderStages } from\n\n'../../capability_info.js';\nimport { GPUConst } from '../../constants.js';\n\nimport { ValidationTest } from './validation_test.js';\n\n\nconst kBindableResources = [\n'uniformBuf',\n'storageBuf',\n'readonlyStorageBuf',\n'filtSamp',\n'nonFiltSamp',\n'compareSamp',\n'sampledTex',\n'sampledTexMS',\n'readonlyStorageTex',\n'writeonlyStorageTex',\n'readwriteStorageTex'];\n\n\nconst bindGroupLayoutEntryContents = {\n  compareSamp: {\n    sampler: {\n      type: 'comparison'\n    }\n  },\n  filtSamp: {\n    sampler: {\n      type: 'filtering'\n    }\n  },\n  nonFiltSamp: {\n    sampler: {\n      type: 'non-filtering'\n    }\n  },\n  sampledTex: {\n    texture: {\n      sampleType: 'unfilterable-float'\n    }\n  },\n  sampledTexMS: {\n    texture: {\n      sampleType: 'unfilterable-float',\n      multisampled: true\n    }\n  },\n  storageBuf: {\n    buffer: {\n      type: 'storage'\n    }\n  },\n  readonlyStorageBuf: {\n    buffer: {\n      type: 'read-only-storage'\n    }\n  },\n  uniformBuf: {\n    buffer: {\n      type: 'uniform'\n    }\n  },\n  readonlyStorageTex: {\n    storageTexture: {\n      format: 'r32float',\n      access: 'read-only'\n    }\n  },\n  writeonlyStorageTex: {\n    storageTexture: {\n      format: 'r32float',\n      access: 'write-only'\n    }\n  },\n  readwriteStorageTex: {\n    storageTexture: {\n      format: 'r32float',\n      access: 'read-write'\n    }\n  }\n};\n\nclass F extends ValidationTest {\n  createPipelineLayout(\n  bindingInPipelineLayout,\n  visibility)\n  {\n    return this.device.createPipelineLayout({\n      bindGroupLayouts: [\n      this.device.createBindGroupLayout({\n        entries: [\n        {\n          binding: 0,\n          visibility,\n          ...bindGroupLayoutEntryContents[bindingInPipelineLayout]\n        }]\n\n      })]\n\n    });\n  }\n\n  GetBindableResourceShaderDeclaration(bindableResource) {\n    switch (bindableResource) {\n      case 'compareSamp':\n        return 'var tmp : sampler_comparison';\n      case 'filtSamp':\n      case 'nonFiltSamp':\n        return 'var tmp : sampler';\n      case 'sampledTex':\n        return 'var tmp : texture_2d<f32>';\n      case 'sampledTexMS':\n        return 'var tmp : texture_multisampled_2d<f32>';\n      case 'storageBuf':\n        return 'var<storage, read_write> tmp : vec4u';\n      case 'readonlyStorageBuf':\n        return 'var<storage, read> tmp : vec4u';\n      case 'uniformBuf':\n        return 'var<uniform> tmp : vec4u;';\n      case 'readonlyStorageTex':\n        return 'var tmp : texture_storage_2d<r32float, read>';\n      case 'writeonlyStorageTex':\n        return 'var tmp : texture_storage_2d<r32float, write>';\n      case 'readwriteStorageTex':\n        return 'var tmp : texture_storage_2d<r32float, read_write>';\n    }\n  }\n}\n\nconst BindingResourceCompatibleWithShaderStages = function (\nbindingResource,\nshaderStages)\n{\n  if ((shaderStages & GPUConst.ShaderStage.VERTEX) > 0) {\n    switch (bindingResource) {\n      case 'writeonlyStorageTex':\n      case 'readwriteStorageTex':\n      case 'storageBuf':\n        return false;\n      default:\n        break;\n    }\n  }\n  return true;\n};\n\nexport const g = makeTestGroup(F);\n\ng.test('pipeline_layout_shader_exact_match').\ndesc(\n  `\n  Test that the binding type in the pipeline layout must match the related declaration in shader.\n  Note that read-write storage textures in the pipeline layout can match write-only storage textures\n  in the shader.\n  `\n).\nparams((u) =>\nu.\ncombine('bindingInPipelineLayout', kBindableResources).\ncombine('bindingInShader', kBindableResources).\nbeginSubcases().\ncombine('pipelineLayoutVisibility', kShaderStageCombinations).\ncombine('shaderStageWithBinding', kShaderStages).\ncombine('isBindingStaticallyUsed', [true, false]).\nunless(\n  (p) =>\n  // We don't test using non-filtering sampler in shader because it has the same declaration\n  // as filtering sampler.\n  p.bindingInShader === 'nonFiltSamp' ||\n  !BindingResourceCompatibleWithShaderStages(\n    p.bindingInPipelineLayout,\n    p.pipelineLayoutVisibility\n  ) ||\n  !BindingResourceCompatibleWithShaderStages(p.bindingInShader, p.shaderStageWithBinding)\n)\n).\nfn((t) => {\n  const {\n    bindingInPipelineLayout,\n    bindingInShader,\n    pipelineLayoutVisibility,\n    shaderStageWithBinding,\n    isBindingStaticallyUsed\n  } = t.params;\n\n  const layout = t.createPipelineLayout(bindingInPipelineLayout, pipelineLayoutVisibility);\n  const bindResourceDeclaration = `@group(0) @binding(0) ${t.GetBindableResourceShaderDeclaration(\n    bindingInShader\n  )}`;\n  const staticallyUseBinding = isBindingStaticallyUsed ? '_ = tmp; ' : '';\n  const isAsync = false;\n\n  let success = true;\n  if (isBindingStaticallyUsed) {\n    success = bindingInPipelineLayout === bindingInShader;\n\n    // Filtering and non-filtering both have the same shader declaration.\n    success ||= bindingInPipelineLayout === 'nonFiltSamp' && bindingInShader === 'filtSamp';\n\n    // Promoting storage textures that are read-write in the layout can be readonly in the shader.\n    success ||=\n    bindingInPipelineLayout === 'readwriteStorageTex' &&\n    bindingInShader === 'writeonlyStorageTex';\n\n    // The shader using the resource must be included in the visibility in the layout.\n    success &&= (pipelineLayoutVisibility & shaderStageWithBinding) > 0;\n  }\n\n  switch (shaderStageWithBinding) {\n    case GPUConst.ShaderStage.COMPUTE:{\n        const computeShader = `\n        ${bindResourceDeclaration};\n        @compute @workgroup_size(1)\n        fn main() {\n          ${staticallyUseBinding}\n        }\n        `;\n        t.doCreateComputePipelineTest(isAsync, success, {\n          layout,\n          compute: {\n            module: t.device.createShaderModule({\n              code: computeShader\n            })\n          }\n        });\n        break;\n      }\n    case GPUConst.ShaderStage.VERTEX:{\n        const vertexShader = `\n        ${bindResourceDeclaration};\n        @vertex\n        fn main() -> @builtin(position) vec4f {\n          ${staticallyUseBinding}\n          return vec4f();\n        }\n        `;\n        t.doCreateRenderPipelineTest(isAsync, success, {\n          layout,\n          vertex: {\n            module: t.device.createShaderModule({\n              code: vertexShader\n            })\n          },\n          depthStencil: { format: 'depth32float', depthWriteEnabled: true, depthCompare: 'always' }\n        });\n        break;\n      }\n    case GPUConst.ShaderStage.FRAGMENT:{\n        const fragmentShader = `\n        ${bindResourceDeclaration};\n        @fragment\n        fn main() -> @location(0) vec4f {\n          ${staticallyUseBinding}\n          return vec4f();\n        }\n        `;\n        t.doCreateRenderPipelineTest(isAsync, success, {\n          layout,\n          vertex: {\n            module: t.device.createShaderModule({\n              code: `\n                @vertex\n                fn main() -> @builtin(position) vec4f {\n                  return vec4f();\n                }`\n            })\n          },\n          fragment: {\n            module: t.device.createShaderModule({\n              code: fragmentShader\n            }),\n            targets: [\n            {\n              format: 'rgba8unorm'\n            }]\n\n          }\n        });\n        break;\n      }\n  }\n});"],"mappings":"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","ignoreList":[]}