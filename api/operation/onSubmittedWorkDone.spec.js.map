{"version":3,"file":"onSubmittedWorkDone.spec.js","names":["description","makeTestGroup","range","GPUTest","g","test","desc","fn","t","queue","onSubmittedWorkDone","buffer","createBufferTracked","size","usage","GPUBufferUsage","COPY_DST","writeBuffer","Uint8Array","i","promises","Promise","all","lastResolved","push","then","expect"],"sources":["../../../../src/webgpu/api/operation/onSubmittedWorkDone.spec.ts"],"sourcesContent":["/**\n* AUTO-GENERATED - DO NOT EDIT. Source: https://github.com/gpuweb/cts\n**/export const description = `\nTests for the behavior of GPUQueue.onSubmittedWorkDone().\n\nNote that any promise timeouts will be detected by the framework.\n`;import { makeTestGroup } from '../../../common/framework/test_group.js';\nimport { range } from '../../../common/util/util.js';\nimport { GPUTest } from '../../gpu_test.js';\n\nexport const g = makeTestGroup(GPUTest);\n\ng.test('without_work').\ndesc(`Await onSubmittedWorkDone once without having submitted any work.`).\nfn(async (t) => {\n  await t.queue.onSubmittedWorkDone();\n});\n\ng.test('with_work').\ndesc(`Await onSubmittedWorkDone once after submitting some work (writeBuffer).`).\nfn(async (t) => {\n  const buffer = t.createBufferTracked({ size: 4, usage: GPUBufferUsage.COPY_DST });\n  t.queue.writeBuffer(buffer, 0, new Uint8Array(4));\n  await t.queue.onSubmittedWorkDone();\n});\n\ng.test('many,serial').\ndesc(`Await 1000 onSubmittedWorkDone calls in serial.`).\nfn(async (t) => {\n  for (let i = 0; i < 1000; ++i) {\n    await t.queue.onSubmittedWorkDone();\n  }\n});\n\ng.test('many,parallel').\ndesc(`Await 1000 onSubmittedWorkDone calls in parallel with Promise.all().`).\nfn(async (t) => {\n  const promises = range(1000, () => t.queue.onSubmittedWorkDone());\n  await Promise.all(promises);\n});\n\ng.test('many,parallel_order').\ndesc(`Issue 200 onSubmittedWorkDone calls and make sure they resolve in the right order.`).\nfn(async (t) => {\n  const promises = [];\n  let lastResolved = -1;\n  for (const i of range(200, (i) => i)) {\n    promises.push(\n      t.queue.onSubmittedWorkDone().then(() => {\n        t.expect(i === lastResolved + 1);\n        lastResolved++;\n      })\n    );\n  }\n  await Promise.all(promises);\n});"],"mappings":";;IAAA;AACA;AACA,GAAG,OAAO,MAAMA,WAAW,GAAG;AAC9B;AACA;AACA;AACA,CAAC,CAAC,SAASC,aAAa,QAAQ,yCAAyC,CACzE,SAASC,KAAK,QAAQ,8BAA8B,CACpD,SAASC,OAAO,QAAQ,mBAAmB;;AAE3C,OAAO,MAAMC,CAAC,GAAGH,aAAa,CAACE,OAAO,CAAC;;AAEvCC,CAAC,CAACC,IAAI,CAAC,cAAc,CAAC;AACtBC,IAAI,CAAC,mEAAmE,CAAC;AACzEC,EAAE,CAAC,OAAOC,CAAC,KAAK;EACd,MAAMA,CAAC,CAACC,KAAK,CAACC,mBAAmB,CAAC,CAAC;AACrC,CAAC,CAAC;;AAEFN,CAAC,CAACC,IAAI,CAAC,WAAW,CAAC;AACnBC,IAAI,CAAC,0EAA0E,CAAC;AAChFC,EAAE,CAAC,OAAOC,CAAC,KAAK;EACd,MAAMG,MAAM,GAAGH,CAAC,CAACI,mBAAmB,CAAC,EAAEC,IAAI,EAAE,CAAC,EAAEC,KAAK,EAAEC,cAAc,CAACC,QAAQ,CAAC,CAAC,CAAC;EACjFR,CAAC,CAACC,KAAK,CAACQ,WAAW,CAACN,MAAM,EAAE,CAAC,EAAE,IAAIO,UAAU,CAAC,CAAC,CAAC,CAAC;EACjD,MAAMV,CAAC,CAACC,KAAK,CAACC,mBAAmB,CAAC,CAAC;AACrC,CAAC,CAAC;;AAEFN,CAAC,CAACC,IAAI,CAAC,aAAa,CAAC;AACrBC,IAAI,CAAC,iDAAiD,CAAC;AACvDC,EAAE,CAAC,OAAOC,CAAC,KAAK;EACd,KAAK,IAAIW,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,EAAE,EAAEA,CAAC,EAAE;IAC7B,MAAMX,CAAC,CAACC,KAAK,CAACC,mBAAmB,CAAC,CAAC;EACrC;AACF,CAAC,CAAC;;AAEFN,CAAC,CAACC,IAAI,CAAC,eAAe,CAAC;AACvBC,IAAI,CAAC,sEAAsE,CAAC;AAC5EC,EAAE,CAAC,OAAOC,CAAC,KAAK;EACd,MAAMY,QAAQ,GAAGlB,KAAK,CAAC,IAAI,EAAE,MAAMM,CAAC,CAACC,KAAK,CAACC,mBAAmB,CAAC,CAAC,CAAC;EACjE,MAAMW,OAAO,CAACC,GAAG,CAACF,QAAQ,CAAC;AAC7B,CAAC,CAAC;;AAEFhB,CAAC,CAACC,IAAI,CAAC,qBAAqB,CAAC;AAC7BC,IAAI,CAAC,oFAAoF,CAAC;AAC1FC,EAAE,CAAC,OAAOC,CAAC,KAAK;EACd,MAAMY,QAAQ,GAAG,EAAE;EACnB,IAAIG,YAAY,GAAG,CAAC,CAAC;EACrB,KAAK,MAAMJ,CAAC,IAAIjB,KAAK,CAAC,GAAG,EAAE,CAACiB,CAAC,KAAKA,CAAC,CAAC,EAAE;IACpCC,QAAQ,CAACI,IAAI;MACXhB,CAAC,CAACC,KAAK,CAACC,mBAAmB,CAAC,CAAC,CAACe,IAAI,CAAC,MAAM;QACvCjB,CAAC,CAACkB,MAAM,CAACP,CAAC,KAAKI,YAAY,GAAG,CAAC,CAAC;QAChCA,YAAY,EAAE;MAChB,CAAC;IACH,CAAC;EACH;EACA,MAAMF,OAAO,CAACC,GAAG,CAACF,QAAQ,CAAC;AAC7B,CAAC,CAAC","ignoreList":[]}