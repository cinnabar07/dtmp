{"version":3,"file":"sample_mask.spec.js","names":["description","makeTestGroup","assert","range","GPUTest","TextureTestMixin","checkElementsPassPredicate","checkElementsEqual","Type","TexelView","kColors","Uint8Array","kDepthClearValue","kDepthWriteValue","kStencilClearValue","kStencilReferenceValue","format","depthStencilFormat","kRenderTargetSize","hasSample","rasterizationMask","sampleMask","fragmentShaderOutputMask","sampleIndex","getExpectedColorData","sampleCount","fragmentShaderOutputMaskOrAlphaToCoverageMask","expectedData","Float32Array","i","o","getExpectedDepthData","s","getExpectedStencilData","Uint32Array","kSampleMaskTestShader","F","init","isCompatibility","skip","kSampleTextureSize","sampleTexture","createTextureFromTexelView","fromTexelsAsBytes","coord","id","x","y","size","usage","GPUTextureUsage","TEXTURE_BINDING","COPY_DST","RENDER_ATTACHMENT","sampler","device","createSampler","magFilter","minFilter","GetTargetTexture","pipeline","uniformBuffer","colorTargetsCount","undefined","uniformBindGroup","createBindGroup","layout","getBindGroupLayout","entries","binding","resource","createView","buffer","renderTargetTextures","resolveTargetTextures","renderTargetTexture","createTextureTracked","width","height","depthOrArrayLayers","mipLevelCount","push","resolveTargetTexture","COPY_SRC","depthStencilTexture","renderPassDescriptor","colorAttachments","map","index","view","resolveTarget","clearValue","r","g","b","a","loadOp","storeOp","depthStencilAttachment","depthClearValue","depthLoadOp","depthStoreOp","stencilClearValue","stencilLoadOp","stencilStoreOp","commandEncoder","globalThis","_TRAMPOLINE_","createCommandEncoder","passEncoder","beginRenderPass","setPipeline","setBindGroup","setStencilReference","draw","end","queue","submit","finish","color","depthStencil","CheckColorAttachmentResult","texture","copy2DTextureToBufferUsingComputePass","f32","expected","expectGPUBufferValuesEqual","CheckDepthStencilResult","aspect","u32","test","desc","params","u","combine","expand","p","maxMask","beginSubcases","fn","t","fragmentMaskUniformBuffer","createBufferTracked","GPUBufferUsage","UNIFORM","writeBuffer","module","createShaderModule","code","createRenderPipeline","vertex","entryPoint","fragment","interpolated","targets","primitive","topology","multisample","count","mask","alphaToCoverageEnabled","depthWriteEnabled","depthCompare","stencilFront","compare","passOp","stencilBack","alpha1","alphaValues","alphaValueUniformBuffer","byteLength","alpha0ParamsArray","colorResultPromises","depthResultPromises","stencilResultPromises","alpha0","colorBuffer","colorResult","readGPUBufferRangeTyped","type","typedLength","BYTES_PER_ELEMENT","depthBuffer","depthResult","stencilBuffer","stencilResult","resultsArray","Promise","all","checkResults","results","getExpectedDataFn","positiveCorrelation","length","result","check","data","expectOK","prevResult","value","cleanup"],"sources":["../../../../../src/webgpu/api/operation/render_pipeline/sample_mask.spec.ts"],"sourcesContent":["/**\n* AUTO-GENERATED - DO NOT EDIT. Source: https://github.com/gpuweb/cts\n**/export const description = `\nTests that the final sample mask is the logical AND of all the relevant masks, including\nthe rasterization mask, sample mask, fragment output mask, and alpha to coverage mask (when alphaToCoverageEnabled === true).\n\nAlso tested:\n- The positions of samples in the standard sample patterns.\n- Per-sample interpolation sampling: @interpolate(perspective, sample).\n\nTODO: Test sample_mask as an input.\n\nTODO: add a test without a 0th color attachment (sparse color attachment), with different color attachments and alpha value output.\nThe cross-platform behavior is unknown. could be any of:\n- coverage is always 100%\n- coverage is always 0%\n- it uses the first non-null attachment\n- it's an error\nDetails could be found at: https://github.com/gpuweb/cts/issues/2201\n`;import { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { assert, range } from '../../../../common/util/util.js';\nimport { GPUTest, TextureTestMixin } from '../../../gpu_test.js';\nimport { checkElementsPassPredicate, checkElementsEqual } from '../../../util/check_contents.js';\nimport { Type } from '../../../util/conversion.js';\nimport { TexelView } from '../../../util/texture/texel_view.js';\n\nconst kColors = [\n// Red\nnew Uint8Array([0xff, 0, 0, 0xff]),\n// Green\nnew Uint8Array([0, 0xff, 0, 0xff]),\n// Blue\nnew Uint8Array([0, 0, 0xff, 0xff]),\n// Yellow\nnew Uint8Array([0xff, 0xff, 0, 0xff])];\n\n\nconst kDepthClearValue = 1.0;\nconst kDepthWriteValue = 0.0;\nconst kStencilClearValue = 0;\nconst kStencilReferenceValue = 0xff;\n\n// Format of the render target and resolve target\nconst format = 'rgba8unorm';\n\n// Format of depth stencil attachment\nconst depthStencilFormat = 'depth24plus-stencil8';\n\nconst kRenderTargetSize = 1;\n\nfunction hasSample(\nrasterizationMask,\nsampleMask,\nfragmentShaderOutputMask,\nsampleIndex = 0)\n{\n  return (rasterizationMask & sampleMask & fragmentShaderOutputMask & 1 << sampleIndex) > 0;\n}\n\nfunction getExpectedColorData(\nsampleCount,\nrasterizationMask,\nsampleMask,\nfragmentShaderOutputMaskOrAlphaToCoverageMask)\n{\n  const expectedData = new Float32Array(sampleCount * 4);\n  if (sampleCount === 1) {\n    if (hasSample(rasterizationMask, sampleMask, fragmentShaderOutputMaskOrAlphaToCoverageMask)) {\n      // Texel 3 is sampled at the pixel center\n      expectedData[0] = kColors[3][0] / 0xff;\n      expectedData[1] = kColors[3][1] / 0xff;\n      expectedData[2] = kColors[3][2] / 0xff;\n      expectedData[3] = kColors[3][3] / 0xff;\n    }\n  } else {\n    for (let i = 0; i < sampleCount; i++) {\n      if (\n      hasSample(rasterizationMask, sampleMask, fragmentShaderOutputMaskOrAlphaToCoverageMask, i))\n      {\n        const o = i * 4;\n        expectedData[o + 0] = kColors[i][0] / 0xff;\n        expectedData[o + 1] = kColors[i][1] / 0xff;\n        expectedData[o + 2] = kColors[i][2] / 0xff;\n        expectedData[o + 3] = kColors[i][3] / 0xff;\n      }\n    }\n  }\n  return expectedData;\n}\n\nfunction getExpectedDepthData(\nsampleCount,\nrasterizationMask,\nsampleMask,\nfragmentShaderOutputMaskOrAlphaToCoverageMask)\n{\n  const expectedData = new Float32Array(sampleCount);\n  for (let i = 0; i < sampleCount; i++) {\n    const s = hasSample(\n      rasterizationMask,\n      sampleMask,\n      fragmentShaderOutputMaskOrAlphaToCoverageMask,\n      i\n    );\n    expectedData[i] = s ? kDepthWriteValue : kDepthClearValue;\n  }\n  return expectedData;\n}\n\nfunction getExpectedStencilData(\nsampleCount,\nrasterizationMask,\nsampleMask,\nfragmentShaderOutputMaskOrAlphaToCoverageMask)\n{\n  const expectedData = new Uint32Array(sampleCount);\n  for (let i = 0; i < sampleCount; i++) {\n    const s = hasSample(\n      rasterizationMask,\n      sampleMask,\n      fragmentShaderOutputMaskOrAlphaToCoverageMask,\n      i\n    );\n    expectedData[i] = s ? kStencilReferenceValue : kStencilClearValue;\n  }\n  return expectedData;\n}\n\nconst kSampleMaskTestShader = `\nstruct Varyings {\n  @builtin(position) Position : vec4<f32>,\n  @location(0) @interpolate(flat, either) uvFlat : vec2<f32>,\n  @location(1) @interpolate(perspective, sample) uvInterpolated : vec2<f32>,\n}\n\n//\n// Vertex shader\n//\n\n@vertex\nfn vmain(@builtin(vertex_index) VertexIndex : u32,\n    @builtin(instance_index) InstanceIndex : u32) -> Varyings {\n  // Standard sample locations within a pixel, where the pixel ranges from (-1,-1) to (1,1), and is\n  // centered at (0,0) (NDC - the test uses a 1x1 render target).\n  // https://learn.microsoft.com/en-us/windows/win32/api/d3d11/ne-d3d11-d3d11_standard_multisample_quality_levels\n  var sampleCenters = array(\n      // sampleCount = 1\n      vec2f(0, 0),\n      // sampleCount = 4\n      vec2f(-2,  6) / 8,\n      vec2f( 6,  2) / 8,\n      vec2f(-6, -2) / 8,\n      vec2f( 2, -6) / 8,\n    );\n  // A tiny quad to draw around the sample center to ensure we hit only the expected point.\n  let kTinyQuadRadius = 1.0 / 32;\n  var tinyQuad = array(\n    vec2f( kTinyQuadRadius,  kTinyQuadRadius),\n    vec2f( kTinyQuadRadius, -kTinyQuadRadius),\n    vec2f(-kTinyQuadRadius, -kTinyQuadRadius),\n    vec2f( kTinyQuadRadius,  kTinyQuadRadius),\n    vec2f(-kTinyQuadRadius, -kTinyQuadRadius),\n    vec2f(-kTinyQuadRadius,  kTinyQuadRadius),\n    );\n\n  var uvsFlat = array(\n      // sampleCount = 1\n      // Note: avoids hitting the point between the 4 texels.\n      vec2f(0.51, 0.51),\n      // sampleCount = 4\n      vec2f(0.25, 0.25),\n      vec2f(0.75, 0.25),\n      vec2f(0.25, 0.75),\n      vec2f(0.75, 0.75),\n    );\n  var uvsInterpolated = array(\n      // center quad\n      // Note: the interpolated point will be exactly in the middle of the 4 texels.\n      // The test expects to get texel 1,1 (the 3rd texel) in this case.\n      vec2f(1.0, 0.0),\n      vec2f(1.0, 1.0),\n      vec2f(0.0, 1.0),\n      vec2f(1.0, 0.0),\n      vec2f(0.0, 1.0),\n      vec2f(0.0, 0.0),\n\n      // top-left quad (texel 0)\n      vec2f(0.5, 0.0),\n      vec2f(0.5, 0.5),\n      vec2f(0.0, 0.5),\n      vec2f(0.5, 0.0),\n      vec2f(0.0, 0.5),\n      vec2f(0.0, 0.0),\n\n      // top-right quad (texel 1)\n      vec2f(1.0, 0.0),\n      vec2f(1.0, 0.5),\n      vec2f(0.5, 0.5),\n      vec2f(1.0, 0.0),\n      vec2f(0.5, 0.5),\n      vec2f(0.5, 0.0),\n\n      // bottom-left quad (texel 2)\n      vec2f(0.5, 0.5),\n      vec2f(0.5, 1.0),\n      vec2f(0.0, 1.0),\n      vec2f(0.5, 0.5),\n      vec2f(0.0, 1.0),\n      vec2f(0.0, 0.5),\n\n      // bottom-right quad (texel 3)\n      vec2f(1.0, 0.5),\n      vec2f(1.0, 1.0),\n      vec2f(0.5, 1.0),\n      vec2f(1.0, 0.5),\n      vec2f(0.5, 1.0),\n      vec2f(0.5, 0.5)\n    );\n\n  var output : Varyings;\n  let pos = sampleCenters[InstanceIndex] + tinyQuad[VertexIndex];\n  output.Position = vec4(pos, ${kDepthWriteValue}, 1.0);\n  output.uvFlat = uvsFlat[InstanceIndex];\n  output.uvInterpolated = uvsInterpolated[InstanceIndex * 6 + VertexIndex];\n  return output;\n}\n\n//\n// Fragment shaders\n//\n\n@group(0) @binding(0) var mySampler: sampler;\n@group(0) @binding(1) var myTexture: texture_2d<f32>;\n\n// For test named 'fragment_output_mask'\n\n@group(0) @binding(2) var<uniform> fragMask: u32;\nstruct FragmentOutput1 {\n  @builtin(sample_mask) mask : u32,\n  @location(0) color : vec4<f32>,\n}\n@fragment fn fmain__fragment_output_mask__flat(varyings: Varyings) -> FragmentOutput1 {\n  return FragmentOutput1(fragMask, textureSample(myTexture, mySampler, varyings.uvFlat));\n}\n@fragment fn fmain__fragment_output_mask__interp(varyings: Varyings) -> FragmentOutput1 {\n  return FragmentOutput1(fragMask, textureSample(myTexture, mySampler, varyings.uvInterpolated));\n}\n\n// For test named 'alpha_to_coverage_mask'\n\nstruct FragmentOutput2 {\n  @location(0) color0 : vec4<f32>,\n  @location(1) color1 : vec4<f32>,\n}\n@group(0) @binding(2) var<uniform> alpha: vec2<f32>;\n@fragment fn fmain__alpha_to_coverage_mask__flat(varyings: Varyings) -> FragmentOutput2 {\n  var c = textureSample(myTexture, mySampler, varyings.uvFlat);\n  return FragmentOutput2(vec4(c.xyz, alpha[0]), vec4(c.xyz, alpha[1]));\n}\n@fragment fn fmain__alpha_to_coverage_mask__interp(varyings: Varyings) -> FragmentOutput2 {\n  var c = textureSample(myTexture, mySampler, varyings.uvInterpolated);\n  return FragmentOutput2(vec4(c.xyz, alpha[0]), vec4(c.xyz, alpha[1]));\n}\n`;\n\nclass F extends TextureTestMixin(GPUTest) {\n\n\n\n  async init() {\n    await super.init();\n    if (this.isCompatibility) {\n      this.skip('WGSL sample_mask is not supported in compatibility mode');\n    }\n    // Create a 2x2 color texture to sample from\n    // texel 0 - Red\n    // texel 1 - Green\n    // texel 2 - Blue\n    // texel 3 - Yellow\n    const kSampleTextureSize = 2;\n    this.sampleTexture = this.createTextureFromTexelView(\n      TexelView.fromTexelsAsBytes(format, (coord) => {\n        const id = coord.x + coord.y * kSampleTextureSize;\n        return kColors[id];\n      }),\n      {\n        size: [kSampleTextureSize, kSampleTextureSize, 1],\n        usage:\n        GPUTextureUsage.TEXTURE_BINDING |\n        GPUTextureUsage.COPY_DST |\n        GPUTextureUsage.RENDER_ATTACHMENT\n      }\n    );\n\n    this.sampler = this.device.createSampler({\n      magFilter: 'nearest',\n      minFilter: 'nearest'\n    });\n  }\n\n  GetTargetTexture(\n  sampleCount,\n  rasterizationMask,\n  pipeline,\n  uniformBuffer,\n  colorTargetsCount = 1)\n  {\n    assert(this.sampleTexture !== undefined);\n    assert(this.sampler !== undefined);\n\n    const uniformBindGroup = this.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [\n      {\n        binding: 0,\n        resource: this.sampler\n      },\n      {\n        binding: 1,\n        resource: this.sampleTexture.createView()\n      },\n      {\n        binding: 2,\n        resource: {\n          buffer: uniformBuffer\n        }\n      }]\n\n    });\n\n    const renderTargetTextures = [];\n    const resolveTargetTextures = [];\n    for (let i = 0; i < colorTargetsCount; i++) {\n      const renderTargetTexture = this.createTextureTracked({\n        format,\n        size: {\n          width: kRenderTargetSize,\n          height: kRenderTargetSize,\n          depthOrArrayLayers: 1\n        },\n        sampleCount,\n        mipLevelCount: 1,\n        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING\n      });\n      renderTargetTextures.push(renderTargetTexture);\n\n      const resolveTargetTexture =\n      sampleCount === 1 ?\n      null :\n      this.createTextureTracked({\n        format,\n        size: {\n          width: kRenderTargetSize,\n          height: kRenderTargetSize,\n          depthOrArrayLayers: 1\n        },\n        sampleCount: 1,\n        mipLevelCount: 1,\n        usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT\n      });\n      resolveTargetTextures.push(resolveTargetTexture);\n    }\n\n    const depthStencilTexture = this.createTextureTracked({\n      size: {\n        width: kRenderTargetSize,\n        height: kRenderTargetSize\n      },\n      format: depthStencilFormat,\n      sampleCount,\n      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING\n    });\n\n    const renderPassDescriptor = {\n      colorAttachments: renderTargetTextures.map((renderTargetTexture, index) => {\n        return {\n          view: renderTargetTexture.createView(),\n          resolveTarget: resolveTargetTextures[index]?.createView(),\n          clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 0.0 },\n          loadOp: 'clear',\n          storeOp: 'store'\n        };\n      }),\n      depthStencilAttachment: {\n        view: depthStencilTexture.createView(),\n        depthClearValue: kDepthClearValue,\n        depthLoadOp: 'clear',\n        depthStoreOp: 'store',\n        stencilClearValue: kStencilClearValue,\n        stencilLoadOp: 'clear',\n        stencilStoreOp: 'store'\n      }\n    };\n    const commandEncoder = globalThis._TRAMPOLINE_(\"createCommandEncoder\", this.device, this.device.createCommandEncoder, [], () => this.device.createCommandEncoder());\n    const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);\n    passEncoder.setPipeline(pipeline);\n    passEncoder.setBindGroup(0, uniformBindGroup);\n    passEncoder.setStencilReference(kStencilReferenceValue);\n\n    if (sampleCount === 1) {\n      if ((rasterizationMask & 1) !== 0) {\n        // draw center quad\n        passEncoder.draw(6, 1, 0, 0);\n      }\n    } else {\n      assert(sampleCount === 4);\n      if ((rasterizationMask & 1) !== 0) {\n        // draw top-left quad\n        passEncoder.draw(6, 1, 0, 1);\n      }\n      if ((rasterizationMask & 2) !== 0) {\n        // draw top-right quad\n        passEncoder.draw(6, 1, 0, 2);\n      }\n      if ((rasterizationMask & 4) !== 0) {\n        // draw bottom-left quad\n        passEncoder.draw(6, 1, 0, 3);\n      }\n      if ((rasterizationMask & 8) !== 0) {\n        // draw bottom-right quad\n        passEncoder.draw(6, 1, 0, 4);\n      }\n    }\n    passEncoder.end();\n    globalThis._TRAMPOLINE_(\"submit\", this.device, this.device.queue.submit, [[commandEncoder.finish()]], () => this.device.queue.submit([commandEncoder.finish()]));\n\n    return {\n      color: renderTargetTextures[0],\n      depthStencil: depthStencilTexture\n    };\n  }\n\n  CheckColorAttachmentResult(\n  texture,\n  sampleCount,\n  rasterizationMask,\n  sampleMask,\n  fragmentShaderOutputMask)\n  {\n    const buffer = this.copy2DTextureToBufferUsingComputePass(\n      Type.f32, // correspond to 'rgba8unorm' format\n      4,\n      texture.createView(),\n      sampleCount\n    );\n\n    const expected = getExpectedColorData(\n      sampleCount,\n      rasterizationMask,\n      sampleMask,\n      fragmentShaderOutputMask\n    );\n    this.expectGPUBufferValuesEqual(buffer, expected);\n  }\n\n  CheckDepthStencilResult(\n  aspect,\n  depthStencilTexture,\n  sampleCount,\n  rasterizationMask,\n  sampleMask,\n  fragmentShaderOutputMask)\n  {\n    const buffer = this.copy2DTextureToBufferUsingComputePass(\n      // Use f32 as the scalar type for depth (depth24plus, depth32float)\n      // Use u32 as the scalar type for stencil (stencil8)\n      aspect === 'depth-only' ? Type.f32 : Type.u32,\n      1,\n      depthStencilTexture.createView({ aspect }),\n      sampleCount\n    );\n\n    const expected =\n    aspect === 'depth-only' ?\n    getExpectedDepthData(sampleCount, rasterizationMask, sampleMask, fragmentShaderOutputMask) :\n    getExpectedStencilData(\n      sampleCount,\n      rasterizationMask,\n      sampleMask,\n      fragmentShaderOutputMask\n    );\n    this.expectGPUBufferValuesEqual(buffer, expected);\n  }\n}\n\nexport const g = makeTestGroup(F);\n\ng.test('fragment_output_mask').\ndesc(\n  `\nTests that the final sample mask is the logical AND of all the relevant masks -- meaning that the samples\nnot included in the final mask are discarded on any attachments including\n- color outputs\n- depth tests\n- stencil operations\n\nThe test draws 0/1/1+ textured quads of which each sample in the standard 4-sample pattern results in a different color:\n- Sample 0, Texel 0, top-left: Red\n- Sample 1, Texel 1, top-left: Green\n- Sample 2, Texel 2, top-left: Blue\n- Sample 3, Texel 3, top-left: Yellow\n\nThe test checks each sample value of the render target texture and depth stencil texture using a compute pass to\ntextureLoad each sample index from the texture and write to a storage buffer to compare with expected values.\n\n- for sampleCount = { 1, 4 } and various combinations of:\n    - rasterization mask = { 0, ..., 2 ** sampleCount - 1 }\n    - sample mask = { 0, 0b0001, 0b0010, 0b0111, 0b1011, 0b1101, 0b1110, 0b1111, 0b11110 }\n    - fragment shader output @builtin(sample_mask) = { 0, 0b0001, 0b0010, 0b0111, 0b1011, 0b1101, 0b1110, 0b1111, 0b11110 }\n- [choosing 0b11110 because the 5th bit should be ignored]\n`\n).\nparams((u) =>\nu.\ncombine('interpolated', [false, true]).\ncombine('sampleCount', [1, 4]).\nexpand('rasterizationMask', function* (p) {\n  const maxMask = 2 ** p.sampleCount - 1;\n  for (let i = 0; i <= maxMask; i++) {\n    yield i;\n  }\n}).\nbeginSubcases().\ncombine('sampleMask', [\n0, 0b0001, 0b0010, 0b0111, 0b1011, 0b1101, 0b1110, 0b1111, 0b11110]\n).\ncombine('fragmentShaderOutputMask', [\n0, 0b0001, 0b0010, 0b0111, 0b1011, 0b1101, 0b1110, 0b1111, 0b11110]\n)\n).\nfn((t) => {\n  const { sampleCount, rasterizationMask, sampleMask, fragmentShaderOutputMask } = t.params;\n\n  const fragmentMaskUniformBuffer = t.createBufferTracked({\n    size: 4,\n    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC\n  });\n  t.device.queue.writeBuffer(\n    fragmentMaskUniformBuffer,\n    0,\n    new Uint32Array([fragmentShaderOutputMask])\n  );\n\n  const module = t.device.createShaderModule({ code: kSampleMaskTestShader });\n  const pipeline = t.device.createRenderPipeline({\n    layout: 'auto',\n    vertex: { module, entryPoint: 'vmain' },\n    fragment: {\n      module,\n      entryPoint: `fmain__fragment_output_mask__${t.params.interpolated ? 'interp' : 'flat'}`,\n      targets: [{ format }]\n    },\n    primitive: { topology: 'triangle-list' },\n    multisample: {\n      count: sampleCount,\n      mask: sampleMask,\n      alphaToCoverageEnabled: false\n    },\n    depthStencil: {\n      format: depthStencilFormat,\n      depthWriteEnabled: true,\n      depthCompare: 'always',\n\n      stencilFront: {\n        compare: 'always',\n        passOp: 'replace'\n      },\n      stencilBack: {\n        compare: 'always',\n        passOp: 'replace'\n      }\n    }\n  });\n\n  const { color, depthStencil } = t.GetTargetTexture(\n    sampleCount,\n    rasterizationMask,\n    pipeline,\n    fragmentMaskUniformBuffer\n  );\n\n  t.CheckColorAttachmentResult(\n    color,\n    sampleCount,\n    rasterizationMask,\n    sampleMask,\n    fragmentShaderOutputMask\n  );\n\n  t.CheckDepthStencilResult(\n    'depth-only',\n    depthStencil,\n    sampleCount,\n    rasterizationMask,\n    sampleMask,\n    fragmentShaderOutputMask\n  );\n\n  t.CheckDepthStencilResult(\n    'stencil-only',\n    depthStencil,\n    sampleCount,\n    rasterizationMask,\n    sampleMask,\n    fragmentShaderOutputMask\n  );\n});\n\ng.test('alpha_to_coverage_mask').\ndesc(\n  `\nTest that alpha_to_coverage_mask is working properly with the alpha output of color target[0].\n\n- for sampleCount = 4, alphaToCoverageEnabled = true and various combinations of:\n  - rasterization masks\n  - increasing alpha0 values of the color0 output including { < 0, = 0, = 1/16, = 2/16, ..., = 15/16, = 1, > 1 }\n  - alpha1 values of the color1 output = { 0, 0.5, 1.0 }.\n- test that for a single pixel in { color0, color1 } { color0, depth, stencil } output the final sample mask is applied to it, moreover:\n  - if alpha0 is 0.0 or less then alpha to coverage mask is 0x0,\n  - if alpha0 is 1.0 or greater then alpha to coverage mask is 0xFFFFFFFF,\n  - that the number of bits in the alpha to coverage mask is non-decreasing,\n  - that the computation of alpha to coverage mask doesn't depend on any other color output than color0,\n  - (not included in the spec): that once a sample is included in the alpha to coverage sample mask\n    it will be included for any alpha greater than or equal to the current value.\n\nThe algorithm of producing the alpha-to-coverage mask is platform-dependent. The test draws a different color\nat each sample point. for any two alpha values (alpha and alpha') where 0 < alpha' < alpha < 1, the color values (color and color') must satisfy\ncolor' <= color.\n`\n).\nparams((u) =>\nu.\ncombine('interpolated', [false, true]).\ncombine('sampleCount', [4]).\nexpand('rasterizationMask', function* (p) {\n  const maxMask = 2 ** p.sampleCount - 1;\n  for (let i = 0; i <= maxMask; i++) {\n    yield i;\n  }\n}).\nbeginSubcases().\ncombine('alpha1', [0.0, 0.5, 1.0])\n).\nfn(async (t) => {\n  const { sampleCount, rasterizationMask, alpha1 } = t.params;\n  const sampleMask = 0xffffffff;\n\n  const alphaValues = new Float32Array(4); // [alpha0, alpha1, 0, 0]\n  const alphaValueUniformBuffer = t.createBufferTracked({\n    size: alphaValues.byteLength,\n    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC\n  });\n\n  const module = t.device.createShaderModule({ code: kSampleMaskTestShader });\n  const pipeline = t.device.createRenderPipeline({\n    layout: 'auto',\n    vertex: { module, entryPoint: 'vmain' },\n    fragment: {\n      module,\n      entryPoint: `fmain__alpha_to_coverage_mask__${t.params.interpolated ? 'interp' : 'flat'}`,\n      targets: [{ format }, { format }]\n    },\n    primitive: { topology: 'triangle-list' },\n    multisample: {\n      count: sampleCount,\n      mask: sampleMask,\n      alphaToCoverageEnabled: true\n    },\n    depthStencil: {\n      format: depthStencilFormat,\n      depthWriteEnabled: true,\n      depthCompare: 'always',\n\n      stencilFront: {\n        compare: 'always',\n        passOp: 'replace'\n      },\n      stencilBack: {\n        compare: 'always',\n        passOp: 'replace'\n      }\n    }\n  });\n\n  // { < 0, = 0, = 1/16, = 2/16, ..., = 15/16, = 1, > 1 }\n  const alpha0ParamsArray = [-0.1, ...range(16, (i) => i / 16), 1.0, 1.1];\n\n  const colorResultPromises = [];\n  const depthResultPromises = [];\n  const stencilResultPromises = [];\n\n  for (const alpha0 of alpha0ParamsArray) {\n    alphaValues[0] = alpha0;\n    alphaValues[1] = alpha1;\n    t.device.queue.writeBuffer(alphaValueUniformBuffer, 0, alphaValues);\n\n    const { color, depthStencil } = t.GetTargetTexture(\n      sampleCount,\n      rasterizationMask,\n      pipeline,\n      alphaValueUniformBuffer,\n      2\n    );\n\n    const colorBuffer = t.copy2DTextureToBufferUsingComputePass(\n      Type.f32, // correspond to 'rgba8unorm' format\n      4,\n      color.createView(),\n      sampleCount\n    );\n    const colorResult = t.readGPUBufferRangeTyped(colorBuffer, {\n      type: Float32Array,\n      typedLength: colorBuffer.size / Float32Array.BYTES_PER_ELEMENT\n    });\n    colorResultPromises.push(colorResult);\n\n    const depthBuffer = t.copy2DTextureToBufferUsingComputePass(\n      Type.f32, // correspond to 'depth24plus-stencil8' format\n      1,\n      depthStencil.createView({ aspect: 'depth-only' }),\n      sampleCount\n    );\n    const depthResult = t.readGPUBufferRangeTyped(depthBuffer, {\n      type: Float32Array,\n      typedLength: depthBuffer.size / Float32Array.BYTES_PER_ELEMENT\n    });\n    depthResultPromises.push(depthResult);\n\n    const stencilBuffer = t.copy2DTextureToBufferUsingComputePass(\n      Type.u32, // correspond to 'depth24plus-stencil8' format\n      1,\n      depthStencil.createView({ aspect: 'stencil-only' }),\n      sampleCount\n    );\n    const stencilResult = t.readGPUBufferRangeTyped(stencilBuffer, {\n      type: Uint32Array,\n      typedLength: stencilBuffer.size / Uint32Array.BYTES_PER_ELEMENT\n    });\n    stencilResultPromises.push(stencilResult);\n  }\n\n  const resultsArray = await Promise.all([\n  Promise.all(colorResultPromises),\n  Promise.all(depthResultPromises),\n  Promise.all(stencilResultPromises)]\n  );\n\n  const checkResults = (\n  results,\n  getExpectedDataFn,\n\n\n\n\n\n\n\n\n  positiveCorrelation) =>\n  {\n    for (let i = 0; i < results.length; i++) {\n      const result = results[i];\n      const alpha0 = alpha0ParamsArray[i];\n\n      if (alpha0 <= 0) {\n        const expected = getExpectedDataFn(sampleCount, rasterizationMask, sampleMask, 0x0);\n        const check = checkElementsEqual(result.data, expected);\n        t.expectOK(check);\n      } else if (alpha0 >= 1) {\n        const expected = getExpectedDataFn(\n          sampleCount,\n          rasterizationMask,\n          sampleMask,\n          0xffffffff\n        );\n        const check = checkElementsEqual(result.data, expected);\n        t.expectOK(check);\n      } else {\n        assert(i > 0);\n        const prevResult = results[i - 1];\n        const check = checkElementsPassPredicate(\n          result.data,\n          (index, value) =>\n          positiveCorrelation ?\n          value >= prevResult.data[index] :\n          value <= prevResult.data[index],\n          {}\n        );\n        t.expectOK(check);\n      }\n    }\n\n    for (const result of results) {\n      result.cleanup();\n    }\n  };\n\n  // Check color results\n  checkResults(resultsArray[0], getExpectedColorData, true);\n\n  // Check depth results\n  checkResults(resultsArray[1], getExpectedDepthData, false);\n\n  // Check stencil results\n  checkResults(resultsArray[2], getExpectedStencilData, true);\n});"],"mappings":"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AAC,GAAGJ,WAAW,EAAEI,CAAC,EAAE,EAAE;IACpC,MAAMG,CAAC,GAAGb,SAAS;MACjBC,iBAAiB;MACjBC,UAAU;MACVK,6CAA6C;MAC7CG;IACF,CAAC;IACDF,YAAY,CAACE,CAAC,CAAC,GAAGG,CAAC,GAAGnB,gBAAgB,GAAGD,gBAAgB;EAC3D;EACA,OAAOe,YAAY;AACrB;;AAEA,SAASM,sBAAsBA;AAC/BR,WAAW;AACXL,iBAAiB;AACjBC,UAAU;AACVK,6CAA6C;AAC7C;EACE,MAAMC,YAAY,GAAG,IAAIO,WAAW,CAACT,WAAW,CAAC;EACjD,KAAK,IAAII,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,WAAW,EAAEI,CAAC,EAAE,EAAE;IACpC,MAAMG,CAAC,GAAGb,SAAS;MACjBC,iBAAiB;MACjBC,UAAU;MACVK,6CAA6C;MAC7CG;IACF,CAAC;IACDF,YAAY,CAACE,CAAC,CAAC,GAAGG,CAAC,GAAGjB,sBAAsB,GAAGD,kBAAkB;EACnE;EACA,OAAOa,YAAY;AACrB;;AAEA,MAAMQ,qBAAqB,GAAG;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgCtB,gBAAgB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA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","ignoreList":[]}