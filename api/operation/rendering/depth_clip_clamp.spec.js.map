{"version":3,"file":"depth_clip_clamp.spec.js","names":["description","makeTestGroup","assert","kDepthStencilFormats","kTextureFormatInfo","GPUTest","checkElementsBetween","checkElementsPassPredicate","g","test","desc","params","u","combine","filter","p","format","depth","undefined","beforeAllSubcases","t","info","selectDeviceOrSkipTestCase","unclippedDepth","feature","fn","writeDepth","multisampled","kNumDepthValues","kNumTestPoints","kViewportMinDepth","kViewportMaxDepth","shaderSource","module","device","createShaderModule","code","testPipeline","createRenderPipeline","layout","vertex","entryPoint","primitive","topology","depthStencil","depthWriteEnabled","depthCompare","multisample","count","fragment","targets","checkPipeline","dsTexture","createTextureTracked","size","usage","GPUTextureUsage","RENDER_ATTACHMENT","COPY_SRC","sampleCount","dsTextureView","createView","checkTextureDesc","checkTexture","checkTextureView","checkTextureMSView","dsActual","bytes","createBufferTracked","GPUBufferUsage","COPY_DST","MAP_READ","dsExpected","checkBuffer","fragInputZFailedBuffer","STORAGE","testBindGroup","createBindGroup","getBindGroupLayout","entries","binding","resource","buffer","enc","globalThis","_TRAMPOLINE_","createCommandEncoder","pass","beginRenderPass","colorAttachments","depthStencilAttachment","view","depthClearValue","depthLoadOp","depthStoreOp","stencilClearValue","stencil","stencilLoadOp","stencilStoreOp","setPipeline","setBindGroup","setViewport","draw","end","copyTextureToBuffer","texture","aspect","clearValue","resolveTarget","loadOp","storeOp","queue","submit","finish","expectGPUBufferValuesPassCheck","a","type","Float32Array","typedLength","kCheckPassedValue","predicatePrinter","leftHeader","getValueForCell","_index","Promise","all","mapAsync","GPUMapMode","READ","act","getMappedRange","exp","push","index","toFixed","value","Uint8Array","method","initPipeline","testTextureDesc","testTexture","testTextureView","testTextureMSView","resultBuffer","expectGPUBufferValuesEqual"],"sources":["../../../../../src/webgpu/api/operation/rendering/depth_clip_clamp.spec.ts"],"sourcesContent":["/**\n* AUTO-GENERATED - DO NOT EDIT. Source: https://github.com/gpuweb/cts\n**/export const description = `\nTests for depth clipping, depth clamping (at various points in the pipeline), and maybe extended\ndepth ranges as well.\n`;import { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { assert } from '../../../../common/util/util.js';\nimport { kDepthStencilFormats, kTextureFormatInfo } from '../../../format_info.js';\nimport { GPUTest } from '../../../gpu_test.js';\nimport {\n  checkElementsBetween,\n  checkElementsPassPredicate } from\n\n'../../../util/check_contents.js';\n\nexport const g = makeTestGroup(GPUTest);\n\ng.test('depth_clamp_and_clip').\ndesc(\n  `\nDepth written to the depth attachment should always be in the range of the viewport depth,\neven if it was written by the fragment shader (using frag_depth). If depth clipping is enabled,\nprimitives should be clipped to the viewport depth before rasterization; if not, these fragments\nshould be rasterized, and the fragment shader should receive out-of-viewport position.z values.\n\nTo test this, render NxN points, with N vertex depth values, by (if writeDepth=true) N\nfrag_depth values with the viewport depth set to [0.25,0.75].\n\nWhile rendering, check the fragment input position.z has the expected value (for all fragments that\nwere produced by the rasterizer) by writing the diff to a storage buffer, which is later checked to\nbe all (near) 0.\n\nThen, run another pass (which outputs every point at z=0.5 to avoid clipping) to verify the depth\nbuffer contents by outputting the expected depth with depthCompare:'not-equal': any fragments that\nhave unexpected values then get drawn to the color buffer, which is later checked to be empty.`\n).\nparams((u) =>\nu //\n.combine('format', kDepthStencilFormats).\nfilter((p) => !!kTextureFormatInfo[p.format].depth).\ncombine('unclippedDepth', [undefined, false, true]).\ncombine('writeDepth', [false, true]).\ncombine('multisampled', [false, true])\n).\nbeforeAllSubcases((t) => {\n  const info = kTextureFormatInfo[t.params.format];\n\n  t.selectDeviceOrSkipTestCase([\n  t.params.unclippedDepth ? 'depth-clip-control' : undefined,\n  info.feature]\n  );\n}).\nfn(async (t) => {\n  const { format, unclippedDepth, writeDepth, multisampled } = t.params;\n  const info = kTextureFormatInfo[format];\n  assert(!!info.depth);\n\n  /** Number of depth values to test for both vertex output and frag_depth output. */\n  const kNumDepthValues = 8;\n  /** Test every combination of vertex output and frag_depth output. */\n  const kNumTestPoints = kNumDepthValues * kNumDepthValues;\n  const kViewportMinDepth = 0.25;\n  const kViewportMaxDepth = 0.75;\n\n  const shaderSource = `\n      // Test depths, with viewport range corresponding to [0,1].\n      var<private> kDepths: array<f32, ${kNumDepthValues}> = array<f32, ${kNumDepthValues}>(\n          -1.0, -0.5, 0.0, 0.25, 0.75, 1.0, 1.5, 2.0);\n\n      const vpMin: f32 = ${kViewportMinDepth};\n      const vpMax: f32 = ${kViewportMaxDepth};\n\n      // Draw the points in a straight horizontal row, one per pixel.\n      fn vertexX(idx: u32) -> f32 {\n        return (f32(idx) + 0.5) * 2.0 / ${kNumTestPoints}.0 - 1.0;\n      }\n\n      // Test vertex shader's position.z output.\n      // Here, the viewport range corresponds to position.z in [0,1].\n      fn vertexZ(idx: u32) -> f32 {\n        return kDepths[idx / ${kNumDepthValues}u];\n      }\n\n      // Test fragment shader's expected position.z input.\n      // Here, the viewport range corresponds to position.z in [vpMin,vpMax], but\n      // unclipped values extend beyond that range.\n      fn expectedFragPosZ(idx: u32) -> f32 {\n        return vpMin + vertexZ(idx) * (vpMax - vpMin);\n      }\n\n      //////// \"Test\" entry points\n\n      struct VFTest {\n        @builtin(position) pos: vec4<f32>,\n        @location(0) @interpolate(flat, either) vertexIndex: u32,\n      };\n\n      @vertex\n      fn vtest(@builtin(vertex_index) idx: u32) -> VFTest {\n        var vf: VFTest;\n        vf.pos = vec4<f32>(vertexX(idx), 0.0, vertexZ(idx), 1.0);\n        vf.vertexIndex = idx;\n        return vf;\n      }\n\n      struct Output {\n        // Each fragment (that didn't get clipped) writes into one element of this output.\n        // (Anything that doesn't get written is already zero.)\n        fragInputZDiff: array<f32, ${kNumTestPoints}>\n      };\n      @group(0) @binding(0) var <storage, read_write> output: Output;\n\n      fn checkZ(vf: VFTest) {\n        output.fragInputZDiff[vf.vertexIndex] = vf.pos.z - expectedFragPosZ(vf.vertexIndex);\n      }\n\n      @fragment\n      fn ftest_WriteDepth(vf: VFTest) -> @builtin(frag_depth) f32 {\n        checkZ(vf);\n        return kDepths[vf.vertexIndex % ${kNumDepthValues}u];\n      }\n\n      @fragment\n      fn ftest_NoWriteDepth(vf: VFTest) {\n        checkZ(vf);\n      }\n\n      //////// \"Check\" entry points\n\n      struct VFCheck {\n        @builtin(position) pos: vec4<f32>,\n        @location(0) @interpolate(flat, either) vertexIndex: u32,\n      };\n\n      @vertex\n      fn vcheck(@builtin(vertex_index) idx: u32) -> VFCheck {\n        var vf: VFCheck;\n        // Depth=0.5 because we want to render every point, not get clipped.\n        vf.pos = vec4<f32>(vertexX(idx), 0.0, 0.5, 1.0);\n        vf.vertexIndex = idx;\n        return vf;\n      }\n\n      struct FCheck {\n        @builtin(frag_depth) depth: f32,\n        @location(0) color: f32,\n      };\n\n      @fragment\n      fn fcheck(vf: VFCheck) -> FCheck {\n        let vertZ = vertexZ(vf.vertexIndex);\n        let outOfRange = vertZ < 0.0 || vertZ > 1.0;\n        let expFragPosZ = expectedFragPosZ(vf.vertexIndex);\n\n        let writtenDepth = kDepths[vf.vertexIndex % ${kNumDepthValues}u];\n\n        let expectedDepthWriteInput = ${writeDepth ? 'writtenDepth' : 'expFragPosZ'};\n        var expectedDepthBufferValue = clamp(expectedDepthWriteInput, vpMin, vpMax);\n        if (${!unclippedDepth} && outOfRange) {\n          // Test fragment should have been clipped; expect the depth attachment to\n          // have its clear value (0.5).\n          expectedDepthBufferValue = 0.5;\n        }\n\n        var f: FCheck;\n        f.depth = expectedDepthBufferValue;\n        f.color = 1.0; // Color written if the resulting depth is unexpected.\n        return f;\n      }\n    `;\n  const module = t.device.createShaderModule({ code: shaderSource });\n\n  // Draw points at different vertex depths and fragment depths into the depth attachment,\n  // with a viewport of [0.25,0.75].\n  const testPipeline = t.device.createRenderPipeline({\n    layout: 'auto',\n    vertex: { module, entryPoint: 'vtest' },\n    primitive: {\n      topology: 'point-list',\n      unclippedDepth\n    },\n    depthStencil: { format, depthWriteEnabled: true, depthCompare: 'always' },\n    multisample: multisampled ? { count: 4 } : undefined,\n    fragment: {\n      module,\n      entryPoint: writeDepth ? 'ftest_WriteDepth' : 'ftest_NoWriteDepth',\n      targets: []\n    }\n  });\n\n  // Use depth comparison to check that the depth attachment now has the expected values.\n  const checkPipeline = t.device.createRenderPipeline({\n    layout: 'auto',\n    vertex: { module, entryPoint: 'vcheck' },\n    primitive: { topology: 'point-list' },\n    depthStencil: {\n      format,\n      // NOTE: This check is probably very susceptible to floating point error. If it fails, maybe\n      // replace it with two checks (less + greater) with an epsilon applied in the check shader?\n      depthCompare: 'not-equal', // Expect every depth value to be exactly equal.\n      depthWriteEnabled: true // If the check failed, overwrite with the expected result.\n    },\n    multisample: multisampled ? { count: 4 } : undefined,\n    fragment: { module, entryPoint: 'fcheck', targets: [{ format: 'r8unorm' }] }\n  });\n\n  const dsTexture = t.createTextureTracked({\n    format,\n    size: [kNumTestPoints],\n    usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n    sampleCount: multisampled ? 4 : 1\n  });\n  const dsTextureView = dsTexture.createView();\n\n  const checkTextureDesc = {\n    format: 'r8unorm',\n    size: [kNumTestPoints],\n    usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC\n  };\n  const checkTexture = t.createTextureTracked(checkTextureDesc);\n  const checkTextureView = checkTexture.createView();\n  const checkTextureMSView = multisampled ?\n  t.createTextureTracked({ ...checkTextureDesc, sampleCount: 4 }).createView() :\n  undefined;\n\n  const dsActual =\n  !multisampled && info.depth.bytes ?\n  t.createBufferTracked({\n    size: kNumTestPoints * info.depth.bytes,\n    usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ\n  }) :\n  undefined;\n  const dsExpected =\n  !multisampled && info.depth.bytes ?\n  t.createBufferTracked({\n    size: kNumTestPoints * info.depth.bytes,\n    usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ\n  }) :\n  undefined;\n  const checkBuffer = t.createBufferTracked({\n    size: kNumTestPoints,\n    usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ\n  });\n\n  const fragInputZFailedBuffer = t.createBufferTracked({\n    size: 4 * kNumTestPoints,\n    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC\n  });\n  const testBindGroup = t.device.createBindGroup({\n    layout: testPipeline.getBindGroupLayout(0),\n    entries: [{ binding: 0, resource: { buffer: fragInputZFailedBuffer } }]\n  });\n\n  const enc = globalThis._TRAMPOLINE_(\"createCommandEncoder\", t.device, t.device.createCommandEncoder, [], () => t.device.createCommandEncoder());\n  {\n    const pass = enc.beginRenderPass({\n      colorAttachments: [],\n      depthStencilAttachment: {\n        view: dsTextureView,\n        depthClearValue: 0.5, // Will see this depth value if the fragment was clipped.\n        depthLoadOp: 'clear',\n        depthStoreOp: 'store',\n        stencilClearValue: info.stencil ? 0 : undefined,\n        stencilLoadOp: info.stencil ? 'clear' : undefined,\n        stencilStoreOp: info.stencil ? 'discard' : undefined\n      }\n    });\n    pass.setPipeline(testPipeline);\n    pass.setBindGroup(0, testBindGroup);\n    pass.setViewport(0, 0, kNumTestPoints, 1, kViewportMinDepth, kViewportMaxDepth);\n    pass.draw(kNumTestPoints);\n    pass.end();\n  }\n  if (dsActual) {\n    enc.copyTextureToBuffer({ texture: dsTexture, aspect: 'depth-only' }, { buffer: dsActual }, [\n    kNumTestPoints]\n    );\n  }\n  {\n    const clearValue = [0, 0, 0, 0]; // Will see this color if the check passed.\n    const pass = enc.beginRenderPass({\n      colorAttachments: [\n      checkTextureMSView ?\n      {\n        view: checkTextureMSView,\n        resolveTarget: checkTextureView,\n        clearValue,\n        loadOp: 'clear',\n        storeOp: 'discard'\n      } :\n      { view: checkTextureView, clearValue, loadOp: 'clear', storeOp: 'store' }],\n\n      depthStencilAttachment: {\n        view: dsTextureView,\n        depthLoadOp: 'load',\n        depthStoreOp: 'store',\n        stencilClearValue: info.stencil ? 0 : undefined,\n        stencilLoadOp: info.stencil ? 'clear' : undefined,\n        stencilStoreOp: info.stencil ? 'discard' : undefined\n      }\n    });\n    pass.setPipeline(checkPipeline);\n    pass.setViewport(0, 0, kNumTestPoints, 1, 0.0, 1.0);\n    pass.draw(kNumTestPoints);\n    pass.end();\n  }\n  enc.copyTextureToBuffer({ texture: checkTexture }, { buffer: checkBuffer }, [kNumTestPoints]);\n  if (dsExpected) {\n    enc.copyTextureToBuffer(\n      { texture: dsTexture, aspect: 'depth-only' },\n      { buffer: dsExpected },\n      [kNumTestPoints]\n    );\n  }\n  globalThis._TRAMPOLINE_(\"submit\", t.device, t.device.queue.submit, [[enc.finish()]], () => t.device.queue.submit([enc.finish()]));\n\n  t.expectGPUBufferValuesPassCheck(\n    fragInputZFailedBuffer,\n    (a) => checkElementsBetween(a, [() => -1e-5, () => 1e-5]),\n    { type: Float32Array, typedLength: kNumTestPoints }\n  );\n\n  const kCheckPassedValue = 0;\n  const predicatePrinter = [\n  { leftHeader: 'expected ==', getValueForCell: (_index) => kCheckPassedValue }];\n\n  if (dsActual && dsExpected && format === 'depth32float') {\n    await Promise.all([globalThis._TRAMPOLINE_(\"mapAsync\", dsActual, dsActual.mapAsync, [GPUMapMode.READ], () => dsActual.mapAsync(GPUMapMode.READ)), globalThis._TRAMPOLINE_(\"mapAsync\", dsExpected, dsExpected.mapAsync, [GPUMapMode.READ], () => dsExpected.mapAsync(GPUMapMode.READ))]);\n    const act = new Float32Array(dsActual.getMappedRange());\n    const exp = new Float32Array(dsExpected.getMappedRange());\n    predicatePrinter.push(\n      { leftHeader: 'act ==', getValueForCell: (index) => act[index].toFixed(2) },\n      { leftHeader: 'exp ==', getValueForCell: (index) => exp[index].toFixed(2) }\n    );\n  }\n  t.expectGPUBufferValuesPassCheck(\n    checkBuffer,\n    (a) =>\n    checkElementsPassPredicate(a, (_index, value) => value === kCheckPassedValue, {\n      predicatePrinter\n    }),\n    { type: Uint8Array, typedLength: kNumTestPoints, method: 'map' }\n  );\n});\n\ng.test('depth_test_input_clamped').\ndesc(\n  `\nInput to the depth test should always be in the range of viewport depth, even if it was written by\nthe fragment shader (using frag_depth).\n\nTo test this, first initialize the depth buffer with N expected values (by writing frag_depth, with\nthe default viewport). These expected values are clamped by the shader to [0.25, 0.75].\n\nThen, run another pass with the viewport depth set to [0.25,0.75], and output various (unclamped)\nfrag_depth values from its fragment shader with depthCompare:'not-equal'. These should get clamped;\nany fragments that have unexpected values then get drawn to the color buffer, which is later checked\nto be empty.`\n).\nparams((u) =>\nu //\n.combine('format', kDepthStencilFormats).\nfilter((p) => !!kTextureFormatInfo[p.format].depth).\ncombine('unclippedDepth', [false, true]).\ncombine('multisampled', [false, true])\n).\nbeforeAllSubcases((t) => {\n  const info = kTextureFormatInfo[t.params.format];\n\n  t.selectDeviceOrSkipTestCase([\n  t.params.unclippedDepth ? 'depth-clip-control' : undefined,\n  info.feature]\n  );\n}).\nfn((t) => {\n  const { format, unclippedDepth, multisampled } = t.params;\n  const info = kTextureFormatInfo[format];\n\n  const kNumDepthValues = 8;\n  const kViewportMinDepth = 0.25;\n  const kViewportMaxDepth = 0.75;\n\n  const shaderSource = `\n      // Test depths, with viewport range corresponding to [0,1].\n      var<private> kDepths: array<f32, ${kNumDepthValues}> = array<f32, ${kNumDepthValues}>(\n          -1.0, -0.5, 0.0, 0.25, 0.75, 1.0, 1.5, 2.0);\n\n      const vpMin: f32 = ${kViewportMinDepth};\n      const vpMax: f32 = ${kViewportMaxDepth};\n\n      // Draw the points in a straight horizontal row, one per pixel.\n      fn vertexX(idx: u32) -> f32 {\n        return (f32(idx) + 0.5) * 2.0 / ${kNumDepthValues}.0 - 1.0;\n      }\n\n      struct VF {\n        @builtin(position) pos: vec4<f32>,\n        @location(0) @interpolate(flat, either) vertexIndex: u32,\n      };\n\n      @vertex\n      fn vmain(@builtin(vertex_index) idx: u32) -> VF {\n        var vf: VF;\n        // Depth=0.5 because we want to render every point, not get clipped.\n        vf.pos = vec4<f32>(vertexX(idx), 0.0, 0.5, 1.0);\n        vf.vertexIndex = idx;\n        return vf;\n      }\n\n      @fragment\n      fn finit(vf: VF) -> @builtin(frag_depth) f32 {\n        // Expected values of the ftest pipeline.\n        return clamp(kDepths[vf.vertexIndex], vpMin, vpMax);\n      }\n\n      struct FTest {\n        @builtin(frag_depth) depth: f32,\n        @location(0) color: f32,\n      };\n\n      @fragment\n      fn ftest(vf: VF) -> FTest {\n        var f: FTest;\n        f.depth = kDepths[vf.vertexIndex]; // Should get clamped to the viewport.\n        f.color = 1.0; // Color written if the resulting depth is unexpected.\n        return f;\n      }\n    `;\n\n  const module = t.device.createShaderModule({ code: shaderSource });\n\n  // Initialize depth attachment with expected values, in [0.25,0.75].\n  const initPipeline = t.device.createRenderPipeline({\n    layout: 'auto',\n    vertex: { module, entryPoint: 'vmain' },\n    primitive: { topology: 'point-list' },\n    depthStencil: { format, depthWriteEnabled: true, depthCompare: 'always' },\n    multisample: multisampled ? { count: 4 } : undefined,\n    fragment: { module, entryPoint: 'finit', targets: [] }\n  });\n\n  // With a viewport set to [0.25,0.75], output values in [0.0,1.0] and check they're clamped\n  // before the depth test, regardless of whether unclippedDepth is enabled.\n  const testPipeline = t.device.createRenderPipeline({\n    layout: 'auto',\n    vertex: { module, entryPoint: 'vmain' },\n    primitive: {\n      topology: 'point-list',\n      unclippedDepth\n    },\n    depthStencil: { format, depthCompare: 'not-equal', depthWriteEnabled: false },\n    multisample: multisampled ? { count: 4 } : undefined,\n    fragment: { module, entryPoint: 'ftest', targets: [{ format: 'r8unorm' }] }\n  });\n\n  const dsTexture = t.createTextureTracked({\n    format,\n    size: [kNumDepthValues],\n    usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n    sampleCount: multisampled ? 4 : 1\n  });\n  const dsTextureView = dsTexture.createView();\n\n  const testTextureDesc = {\n    format: 'r8unorm',\n    size: [kNumDepthValues],\n    usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC\n  };\n  const testTexture = t.createTextureTracked(testTextureDesc);\n  const testTextureView = testTexture.createView();\n  const testTextureMSView = multisampled ?\n  t.createTextureTracked({ ...testTextureDesc, sampleCount: 4 }).createView() :\n  undefined;\n\n  const resultBuffer = t.createBufferTracked({\n    size: kNumDepthValues,\n    usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ\n  });\n\n  const enc = globalThis._TRAMPOLINE_(\"createCommandEncoder\", t.device, t.device.createCommandEncoder, [], () => t.device.createCommandEncoder());\n  {\n    const pass = enc.beginRenderPass({\n      colorAttachments: [],\n      depthStencilAttachment: {\n        view: dsTextureView,\n        depthClearValue: 1.0,\n        depthLoadOp: 'clear',\n        depthStoreOp: 'store',\n        stencilClearValue: info.stencil ? 0 : undefined,\n        stencilLoadOp: info.stencil ? 'clear' : undefined,\n        stencilStoreOp: info.stencil ? 'discard' : undefined\n      }\n    });\n    pass.setPipeline(initPipeline);\n    pass.draw(kNumDepthValues);\n    pass.end();\n  }\n  {\n    const clearValue = [0, 0, 0, 0]; // Will see this color if the test passed.\n    const pass = enc.beginRenderPass({\n      colorAttachments: [\n      testTextureMSView ?\n      {\n        view: testTextureMSView,\n        resolveTarget: testTextureView,\n        clearValue,\n        loadOp: 'clear',\n        storeOp: 'discard'\n      } :\n      { view: testTextureView, clearValue, loadOp: 'clear', storeOp: 'store' }],\n\n      depthStencilAttachment: {\n        view: dsTextureView,\n        depthLoadOp: 'load',\n        depthStoreOp: 'store',\n        stencilClearValue: info.stencil ? 0 : undefined,\n        stencilLoadOp: info.stencil ? 'clear' : undefined,\n        stencilStoreOp: info.stencil ? 'discard' : undefined\n      }\n    });\n    pass.setPipeline(testPipeline);\n    pass.setViewport(0, 0, kNumDepthValues, 1, kViewportMinDepth, kViewportMaxDepth);\n    pass.draw(kNumDepthValues);\n    pass.end();\n  }\n  enc.copyTextureToBuffer({ texture: testTexture }, { buffer: resultBuffer }, [kNumDepthValues]);\n  globalThis._TRAMPOLINE_(\"submit\", t.device, t.device.queue.submit, [[enc.finish()]], () => t.device.queue.submit([enc.finish()]));\n\n  t.expectGPUBufferValuesEqual(resultBuffer, new Uint8Array(kNumDepthValues), 0, {\n    method: 'map'\n  });\n});"],"mappings":";;IAAA;AACA;AACA,GAAG,OAAO,MAAMA,WAAW,GAAG;AAC9B;AACA;AACA,CAAC,CAAC,SAASC,aAAa,QAAQ,4CAA4C,CAC5E,SAASC,MAAM,QAAQ,iCAAiC,CACxD,SAASC,oBAAoB,EAAEC,kBAAkB,QAAQ,yBAAyB;AAClF,SAASC,OAAO,QAAQ,sBAAsB;AAC9C;EACEC,oBAAoB;EACpBC,0BAA0B;;AAE5B,iCAAiC;;AAEjC,OAAO,MAAMC,CAAC,GAAGP,aAAa,CAACI,OAAO,CAAC;;AAEvCG,CAAC,CAACC,IAAI,CAAC,sBAAsB,CAAC;AAC9BC,IAAI;EACF;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACDC,MAAM,CAAC,CAACC,CAAC;AACTA,CAAC,CAAC;AAAA,CACDC,OAAO,CAAC,QAAQ,EAAEV,oBAAoB,CAAC;AACxCW,MAAM,CAAC,CAACC,CAAC,KAAK,CAAC,CAACX,kBAAkB,CAACW,CAAC,CAACC,MAAM,CAAC,CAACC,KAAK,CAAC;AACnDJ,OAAO,CAAC,gBAAgB,EAAE,CAACK,SAAS,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;AACnDL,OAAO,CAAC,YAAY,EAAE,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;AACpCA,OAAO,CAAC,cAAc,EAAE,CAAC,KAAK,EAAE,IAAI,CAAC;AACrC,CAAC;AACDM,iBAAiB,CAAC,CAACC,CAAC,KAAK;EACvB,MAAMC,IAAI,GAAGjB,kBAAkB,CAACgB,CAAC,CAACT,MAAM,CAACK,MAAM,CAAC;;EAEhDI,CAAC,CAACE,0BAA0B,CAAC;EAC7BF,CAAC,CAACT,MAAM,CAACY,cAAc,GAAG,oBAAoB,GAAGL,SAAS;EAC1DG,IAAI,CAACG,OAAO;EACZ,CAAC;AACH,CAAC,CAAC;AACFC,EAAE,CAAC,OAAOL,CAAC,KAAK;EACd,MAAM,EAAEJ,MAAM,EAAEO,cAAc,EAAEG,UAAU,EAAEC,YAAY,CAAC,CAAC,GAAGP,CAAC,CAACT,MAAM;EACrE,MAAMU,IAAI,GAAGjB,kBAAkB,CAACY,MAAM,CAAC;EACvCd,MAAM,CAAC,CAAC,CAACmB,IAAI,CAACJ,KAAK,CAAC;;EAEpB;EACA,MAAMW,eAAe,GAAG,CAAC;EACzB;EACA,MAAMC,cAAc,GAAGD,eAAe,GAAGA,eAAe;EACxD,MAAME,iBAAiB,GAAG,IAAI;EAC9B,MAAMC,iBAAiB,GAAG,IAAI;;EAE9B,MAAMC,YAAY,GAAG;AACvB;AACA,yCAAyCJ,eAAe,kBAAkBA,eAAe;AACzF;AACA;AACA,2BAA2BE,iBAAiB;AAC5C,2BAA2BC,iBAAiB;AAC5C;AACA;AACA;AACA,0CAA0CF,cAAc;AACxD;AACA;AACA;AACA;AACA;AACA,+BAA+BD,eAAe;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqCC,cAAc;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0CD,eAAe;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsDA,eAAe;AACrE;AACA,wCAAwCF,UAAU,GAAG,cAAc,GAAG,aAAa;AACnF;AACA,cAAc,CAACH,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;EACH,MAAMU,MAAM,GAAGb,CAAC,CAACc,MAAM,CAACC,kBAAkB,CAAC,EAAEC,IAAI,EAAEJ,YAAY,CAAC,CAAC,CAAC;;EAElE;EACA;EACA,MAAMK,YAAY,GAAGjB,CAAC,CAACc,MAAM,CAACI,oBAAoB,CAAC;IACjDC,MAAM,EAAE,MAAM;IACdC,MAAM,EAAE,EAAEP,MAAM,EAAEQ,UAAU,EAAE,OAAO,CAAC,CAAC;IACvCC,SAAS,EAAE;MACTC,QAAQ,E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","ignoreList":[]}