{"version":3,"file":"correctness.spec.js","names":["description","makeTestGroup","assert","filterUniqueValueTestVariants","makeValueTestVariant","memcpy","unreachable","kPerStageBindingLimits","kVertexFormatInfo","kVertexFormats","GPUTest","float32ToFloat16Bits","normalizedIntegerAsFloat","align","clamp","mapBufferAttribs","buffer","f","newAttributes","a","attributes","push","shaderLocation","mapStateAttribs","buffers","map","b","makeRgb10a2","rgba","r","g","normalizeRgb10a2","index","normalizationFactor","VertexStateTest","makeTestWGSL","vertexCount","instanceCount","maxUniformBuffers","getDefaultLimit","maxLimit","device","limits","maxVertexAttributes","vsInputs","vsChecks","vsBindings","format","shaderComponentCount","componentCount","i","shaderType","shaderBaseType","maxCount","indexBuiltin","stepMode","storageType","component","expected","attribComponent","providedData","type","floatTolerance","makeTestPipeline","module","createShaderModule","code","bufferLayouts","slot","createRenderPipeline","layout","vertex","entryPoint","primitive","topology","fragment","targets","submitRenderPass","pipeline","expectedData","testTexture","createTextureTracked","size","usage","GPUTextureUsage","RENDER_ATTACHMENT","COPY_SRC","encoder","globalThis","_TRAMPOLINE_","createCommandEncoder","pass","beginRenderPass","colorAttachments","view","createView","clearValue","loadOp","storeOp","setPipeline","setBindGroup","setVertexBuffer","vbOffset","draw","end","queue","submit","finish","expectSingleColor","exp","R","generateTestData","formatInfo","bitSize","bytesPerComponent","data","Float32Array","vertexData","Uint16Array","testComponentCount","length","Math","pow","Int32Array","Int16Array","Int8Array","Uint32Array","Uint8Array","v","flat","expandTestData","vertexComponentSize","byteLength","expectedComponentSize","expandedVertexData","expandedExpectedData","targetVertexOffset","sourceVertexOffset","src","start","dst","targetExpectedOffset","sourceExpectedOffset","interleaveVertexDataInto","target","targetStride","offset","srcStart","dstStart","createTestAndPipelineData","state","attrib","testData","createExpectedBG","bgEntries","expectedDataBuffer","makeBufferWithContents","GPUBufferUsage","UNIFORM","STORAGE","binding","resource","createBindGroup","getBindGroupLayout","entries","createVertexBuffers","vertexBuffers","ArrayBuffer","arrayStride","fill","byteSize","VERTEX","runTest","expectedDataBG","test","desc","params","u","combine","beginSubcases","mult","add","fn","t","slotVariant","shaderLocationVariant","makeLimitVariant","expand","p","formatSize","Set","arrayStrideVariant","offsetVariant","min","max","paramsSubcasesOnly","stepModes","vbCountVariant","additionalVBOffset","vbCount","kVertexCount","kInstanceCount","formatByteSize","alignedFormatByteSize","baseDataVertexCount","baseData","vertexBuffer","baseTestData","expectedDataBytesPerVertex","slice","attribs","maxVertexBuffers","deviceMaxVertexAttributes","isCompatibility","attributesPerBuffer","ceil","attributesEmitted","j","kCount","stride0TestData","stride0VertexBuffer","originalData","expandedData","set","varyingTestData","varyingVertexBuffer"],"sources":["../../../../../src/webgpu/api/operation/vertex_state/correctness.spec.ts"],"sourcesContent":["/**\n* AUTO-GENERATED - DO NOT EDIT. Source: https://github.com/gpuweb/cts\n**/export const description = `\nTODO: Test more corner case values for Float16 / Float32 (INF, NaN, ...) and reduce the\nfloat tolerance.\n`;import { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport {\n  assert,\n  filterUniqueValueTestVariants,\n  makeValueTestVariant,\n  memcpy,\n  unreachable } from\n'../../../../common/util/util.js';\nimport {\n  kPerStageBindingLimits,\n  kVertexFormatInfo,\n  kVertexFormats } from\n'../../../capability_info.js';\nimport { GPUTest } from '../../../gpu_test.js';\nimport { float32ToFloat16Bits, normalizedIntegerAsFloat } from '../../../util/conversion.js';\nimport { align, clamp } from '../../../util/math.js';\n\n// These types mirror the structure of GPUVertexBufferLayout but allow defining the extra\n// dictionary members at the GPUVertexBufferLayout and GPUVertexAttribute level. The are used\n// like so:\n//\n//   VertexState<{arrayStride: number}, {format: VertexFormat}>\n//   VertexBuffer<{arrayStride: number}, {format: VertexFormat}>\n//   VertexAttrib<{format: VertexFormat}>\n\n\n\n\n\n\n\n\n\n\n\n\nfunction mapBufferAttribs(\nbuffer,\nf)\n{\n  const newAttributes = [];\n  for (const a of buffer.attributes) {\n    newAttributes.push({\n      shaderLocation: a.shaderLocation,\n      ...f(buffer, a)\n    });\n  }\n\n  return { ...buffer, attributes: newAttributes };\n}\n\nfunction mapStateAttribs(\nbuffers,\nf)\n{\n  return buffers.map((b) => mapBufferAttribs(b, f));\n}\n\nfunction makeRgb10a2(rgba) {\n  const [r, g, b, a] = rgba;\n  assert((r & 0x3ff) === r);\n  assert((g & 0x3ff) === g);\n  assert((b & 0x3ff) === b);\n  assert((a & 0x3) === a);\n  return r | g << 10 | b << 20 | a << 30;\n}\n\nfunction normalizeRgb10a2(rgba, index) {\n  const normalizationFactor = index % 4 === 3 ? 3 : 1023;\n  return rgba / normalizationFactor;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass VertexStateTest extends GPUTest {\n  // Generate for VS + FS (entrypoints vsMain / fsMain) that for each attribute will check that its\n  // value corresponds to what's expected (as provided by a uniform buffer per attribute) and then\n  // renders each vertex at position (vertexIndex, instanceindex) with either 1 (success) or\n  // a negative number corresponding to the check number (in case you need to debug a failure).\n  makeTestWGSL(\n  buffers,\n\n\n\n\n\n\n\n\n  vertexCount,\n  instanceCount)\n  {\n    // In the base WebGPU spec maxVertexAttributes is larger than maxUniformBufferPerStage. We'll\n    // use a combination of uniform and storage buffers to cover all possible attributes. This\n    // happens to work because maxUniformBuffer + maxStorageBuffer = 12 + 8 = 20 which is larger\n    // than maxVertexAttributes = 16.\n    // However this might not work in the future for implementations that allow even more vertex\n    // attributes so there will need to be larger changes when that happens.\n    const maxUniformBuffers = this.getDefaultLimit(kPerStageBindingLimits['uniformBuf'].maxLimit);\n    assert(\n      maxUniformBuffers + this.getDefaultLimit(kPerStageBindingLimits['storageBuf'].maxLimit) >=\n      this.device.limits.maxVertexAttributes\n    );\n\n    let vsInputs = '';\n    let vsChecks = '';\n    let vsBindings = '';\n\n    for (const b of buffers) {\n      for (const a of b.attributes) {\n        const format = kVertexFormatInfo[a.format];\n        const shaderComponentCount = a.shaderComponentCount ?? format.componentCount;\n        const i = a.shaderLocation;\n\n        // shaderType is either a scalar type like f32 or a vecN<scalarType>\n        let shaderType = a.shaderBaseType;\n        if (shaderComponentCount !== 1) {\n          shaderType = `vec${shaderComponentCount}<${shaderType}>`;\n        }\n\n        let maxCount = `${vertexCount}`;\n        let indexBuiltin = `input.vertexIndex`;\n        if (b.stepMode === 'instance') {\n          maxCount = `${instanceCount}`;\n          indexBuiltin = `input.instanceIndex`;\n        }\n\n        // Start using storage buffers when we run out of uniform buffers.\n        let storageType = 'uniform';\n        if (i >= maxUniformBuffers) {\n          storageType = 'storage, read';\n        }\n\n        vsInputs += `  @location(${i}) attrib${i} : ${shaderType},\\n`;\n        vsBindings += `struct S${i} { data : array<vec4<${a.shaderBaseType}>, ${maxCount}> };\\n`;\n        vsBindings += `@group(0) @binding(${i}) var<${storageType}> providedData${i} : S${i};\\n`;\n\n        // Generate the all the checks for the attributes.\n        for (let component = 0; component < shaderComponentCount; component++) {\n          // Components are filled with (0, 0, 0, 1) if they aren't provided data from the pipeline.\n          if (component >= format.componentCount) {\n            const expected = component === 3 ? '1' : '0';\n            vsChecks += `  check(input.attrib${i}[${component}] == ${a.shaderBaseType}(${expected}));\\n`;\n            continue;\n          }\n\n          // Check each component individually, with special handling of tolerance for floats.\n          const attribComponent =\n          shaderComponentCount === 1 ? `input.attrib${i}` : `input.attrib${i}[${component}]`;\n          const providedData = `providedData${i}.data[${indexBuiltin}][${component}]`;\n          if (format.type === 'uint' || format.type === 'sint') {\n            vsChecks += `  check(${attribComponent} == ${providedData});\\n`;\n          } else {\n            vsChecks += `  check(floatsSimilar(${attribComponent}, ${providedData}, f32(${\n            a.floatTolerance ?? 0})));\\n`;\n\n          }\n        }\n      }\n    }\n\n    return `\nstruct Inputs {\n${vsInputs}\n  @builtin(vertex_index) vertexIndex: u32,\n  @builtin(instance_index) instanceIndex: u32,\n};\n\n${vsBindings}\n\nvar<private> vsResult : i32 = 1;\nvar<private> checkIndex : i32 = 0;\nfn check(success : bool) {\n  if (!success) {\n    vsResult = -checkIndex;\n  }\n  checkIndex = checkIndex + 1;\n}\n\nfn floatsSimilar(a : f32, b : f32, tolerance : f32) -> bool {\n  // Note: -0.0 and 0.0 have different bit patterns, but compare as equal.\n  return abs(a - b) < tolerance;\n}\n\nfn doTest(input : Inputs) {\n${vsChecks}\n}\n\nstruct VSOutputs {\n  @location(0) @interpolate(flat, either) result : i32,\n  @builtin(position) position : vec4<f32>,\n};\n\n@vertex fn vsMain(input : Inputs) -> VSOutputs {\n  doTest(input);\n\n  // Place that point at pixel (vertexIndex, instanceIndex) in a framebuffer of size\n  // (vertexCount , instanceCount).\n  var output : VSOutputs;\n  output.position = vec4<f32>(\n    ((f32(input.vertexIndex) + 0.5) / ${vertexCount}.0 * 2.0) - 1.0,\n    ((f32(input.instanceIndex) + 0.5) / ${instanceCount}.0 * 2.0) - 1.0,\n    0.0, 1.0\n  );\n  output.result = vsResult;\n  return output;\n}\n\n@fragment fn fsMain(@location(0) @interpolate(flat, either) result : i32)\n  -> @location(0) i32 {\n  return result;\n}\n    `;\n  }\n\n  makeTestPipeline(\n  buffers,\n\n\n\n\n\n\n\n\n\n  vertexCount,\n  instanceCount)\n  {\n    const module = this.device.createShaderModule({\n      code: this.makeTestWGSL(buffers, vertexCount, instanceCount)\n    });\n\n    const bufferLayouts = [];\n    for (const b of buffers) {\n      bufferLayouts[b.slot] = b;\n    }\n\n    return this.device.createRenderPipeline({\n      layout: 'auto',\n      vertex: {\n        module,\n        entryPoint: 'vsMain',\n        buffers: bufferLayouts\n      },\n      primitive: {\n        topology: 'point-list'\n      },\n      fragment: {\n        module,\n        entryPoint: 'fsMain',\n        targets: [\n        {\n          format: 'r32sint'\n        }]\n\n      }\n    });\n  }\n\n  // Runs the render pass drawing points in a vertexCount*instanceCount rectangle, then check each\n  // of produced a value of 1 which means that the tests in the shader passed.\n  submitRenderPass(\n  pipeline,\n  buffers,\n  expectedData,\n  vertexCount,\n  instanceCount)\n  {\n    const testTexture = this.createTextureTracked({\n      format: 'r32sint',\n      size: [vertexCount, instanceCount],\n      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC\n    });\n\n    const encoder = globalThis._TRAMPOLINE_(\"createCommandEncoder\", this.device, this.device.createCommandEncoder, [], () => this.device.createCommandEncoder());\n    const pass = encoder.beginRenderPass({\n      colorAttachments: [\n      {\n        view: testTexture.createView(),\n        clearValue: [0, 0, 0, 0],\n        loadOp: 'clear',\n        storeOp: 'store'\n      }]\n\n    });\n\n    pass.setPipeline(pipeline);\n    pass.setBindGroup(0, expectedData);\n    for (const buffer of buffers) {\n      pass.setVertexBuffer(buffer.slot, buffer.buffer, buffer.vbOffset ?? 0);\n    }\n    pass.draw(vertexCount, instanceCount);\n    pass.end();\n\n    globalThis._TRAMPOLINE_(\"submit\", this.device, this.device.queue.submit, [[encoder.finish()]], () => this.device.queue.submit([encoder.finish()]));\n\n    this.expectSingleColor(testTexture, 'r32sint', {\n      size: [vertexCount, instanceCount, 1],\n      exp: { R: 1 }\n    });\n  }\n\n  // Generate TestData for the format with interesting test values.\n  // MAINTENANCE_TODO cache the result on the fixture?\n  // Note that the test data always starts with an interesting value, so that using the first\n  // test value in a test is still meaningful.\n  generateTestData(format) {\n    const formatInfo = kVertexFormatInfo[format];\n    const bitSize =\n    formatInfo.bytesPerComponent === 'packed' ? 0 : formatInfo.bytesPerComponent * 8;\n\n    switch (formatInfo.type) {\n      case 'float':{\n          // -0.0 and +0.0 have different bit patterns, but compare as equal.\n          const data = [42.42, 0.0, -0.0, 1.0, -1.0, 1000, -18.7, 25.17];\n          const expectedData = new Float32Array(data).buffer;\n          const vertexData =\n          bitSize === 32 ?\n          expectedData :\n          bitSize === 16 ?\n          new Uint16Array(data.map(float32ToFloat16Bits)).buffer :\n          unreachable();\n\n          return {\n            shaderBaseType: 'f32',\n            testComponentCount: data.length,\n            expectedData,\n            vertexData,\n            floatTolerance: 0.05\n          };\n        }\n\n      case 'sint':{\n\n          const data = [\n          42,\n          0, 1, 2, 3, 4, 5,\n          -1, -2, -3, -4, -5,\n          Math.pow(2, bitSize - 2),\n          Math.pow(2, bitSize - 1) - 1, // max value\n          -Math.pow(2, bitSize - 2),\n          -Math.pow(2, bitSize - 1) // min value\n          ];\n          const expectedData = new Int32Array(data).buffer;\n          const vertexData =\n          bitSize === 32 ?\n          expectedData :\n          bitSize === 16 ?\n          new Int16Array(data).buffer :\n          new Int8Array(data).buffer;\n\n          return {\n            shaderBaseType: 'i32',\n            testComponentCount: data.length,\n            expectedData,\n            vertexData\n          };\n        }\n\n      case 'uint':{\n\n          const data = [\n          42,\n          0, 1, 2, 3, 4, 5,\n          Math.pow(2, bitSize - 1),\n          Math.pow(2, bitSize) - 1 // max value\n          ];\n          const expectedData = new Uint32Array(data).buffer;\n          const vertexData =\n          bitSize === 32 ?\n          expectedData :\n          bitSize === 16 ?\n          new Uint16Array(data).buffer :\n          new Uint8Array(data).buffer;\n\n          return {\n            shaderBaseType: 'u32',\n            testComponentCount: data.length,\n            expectedData,\n            vertexData\n          };\n        }\n\n      case 'snorm':{\n\n          const data = [\n          42,\n          0, 1, 2, 3, 4, 5,\n          -1, -2, -3, -4, -5,\n          Math.pow(2, bitSize - 2),\n          Math.pow(2, bitSize - 1) - 1, // max value\n          -Math.pow(2, bitSize - 2),\n          -Math.pow(2, bitSize - 1) // min value\n          ];\n          const vertexData =\n          bitSize === 16 ?\n          new Int16Array(data).buffer :\n          bitSize === 8 ?\n          new Int8Array(data).buffer :\n          unreachable();\n\n          return {\n            shaderBaseType: 'f32',\n            testComponentCount: data.length,\n            expectedData: new Float32Array(data.map((v) => normalizedIntegerAsFloat(v, bitSize, true))).\n            buffer,\n            vertexData,\n            floatTolerance: 0.1 * normalizedIntegerAsFloat(1, bitSize, true)\n          };\n        }\n\n      case 'unorm':{\n          if (formatInfo.bytesPerComponent === 'packed') {\n            assert(bitSize === 0);\n\n            switch (format) {\n              case 'unorm10-10-10-2':{\n\n                  const data = [\n                  [0, 0, 0, 0],\n                  [1023, 1023, 1023, 3],\n                  [243, 567, 765, 2]];\n\n                  const vertexData = new Uint32Array(data.map(makeRgb10a2)).buffer;\n                  const expectedData = new Float32Array(data.flat().map(normalizeRgb10a2)).buffer;\n\n                  return {\n                    shaderBaseType: 'f32',\n                    testComponentCount: data.flat().length,\n                    expectedData,\n                    vertexData,\n                    floatTolerance: 0.1 / 1023\n                  };\n                }\n\n              case 'unorm8x4-bgra':{\n                  const data = [42, 0, 1, 2, 3, 4, 128, 255];\n                  const vertexData = new Uint8Array(data).buffer;\n                  const expectedData = new Float32Array(\n                    data.map((v) => normalizedIntegerAsFloat(v, 8, false))\n                  );\n\n                  for (let i = 0; i + 2 < expectedData.length; i += 4) {\n                    const r = expectedData[i + 0];\n                    const b = expectedData[i + 2];\n                    expectedData[i + 0] = b;\n                    expectedData[i + 2] = r;\n                  }\n\n                  return {\n                    shaderBaseType: 'f32',\n                    testComponentCount: data.length,\n                    expectedData: expectedData.buffer,\n                    vertexData,\n                    floatTolerance: 0.1 / 255\n                  };\n                }\n            }\n          }\n\n\n          const data = [\n          42,\n          0, 1, 2, 3, 4, 5,\n          Math.pow(2, bitSize - 1),\n          Math.pow(2, bitSize) - 1 // max value\n          ];\n          const vertexData =\n          bitSize === 16 ?\n          new Uint16Array(data).buffer :\n          bitSize === 8 ?\n          new Uint8Array(data).buffer :\n          unreachable();\n\n          return {\n            shaderBaseType: 'f32',\n            testComponentCount: data.length,\n            expectedData: new Float32Array(data.map((v) => normalizedIntegerAsFloat(v, bitSize, false))).\n            buffer,\n            vertexData,\n            floatTolerance: 0.1 * normalizedIntegerAsFloat(1, bitSize, false)\n          };\n        }\n    }\n  }\n\n  // The TestData generated for a format might not contain enough data for all the vertices we are\n  // going to draw, so we expand them by adding additional copies of the vertexData as needed.\n  // expectedData is a bit different because it also needs to be unpacked to have `componentCount`\n  // components every 4 components (because the shader uses vec4 for the expected data).\n  expandTestData(data, maxCount, componentCount) {\n    const vertexComponentSize = data.vertexData.byteLength / data.testComponentCount;\n    const expectedComponentSize = data.expectedData.byteLength / data.testComponentCount;\n\n    const expandedVertexData = new Uint8Array(maxCount * componentCount * vertexComponentSize);\n    const expandedExpectedData = new Uint8Array(4 * maxCount * expectedComponentSize);\n\n    for (let index = 0; index < maxCount; index++) {\n      for (let component = 0; component < componentCount; component++) {\n        // If only we had some builtin JS memcpy function between ArrayBuffers...\n        const targetVertexOffset = (index * componentCount + component) * vertexComponentSize;\n        const sourceVertexOffset = targetVertexOffset % data.vertexData.byteLength;\n        memcpy(\n          { src: data.vertexData, start: sourceVertexOffset, length: vertexComponentSize },\n          { dst: expandedVertexData, start: targetVertexOffset }\n        );\n\n        const targetExpectedOffset = (index * 4 + component) * expectedComponentSize;\n        const sourceExpectedOffset =\n        (index * componentCount + component) * expectedComponentSize %\n        data.expectedData.byteLength;\n        memcpy(\n          { src: data.expectedData, start: sourceExpectedOffset, length: expectedComponentSize },\n          { dst: expandedExpectedData, start: targetExpectedOffset }\n        );\n      }\n    }\n\n    return {\n      shaderBaseType: data.shaderBaseType,\n      testComponentCount: maxCount * componentCount,\n      floatTolerance: data.floatTolerance,\n      expectedData: expandedExpectedData.buffer,\n      vertexData: expandedVertexData.buffer\n    };\n  }\n\n  // Copies `size` bytes from `source` to `target` starting at `offset` each `targetStride`.\n  // (the data in `source` is assumed packed)\n  interleaveVertexDataInto(\n  target,\n  src,\n  { targetStride, offset, size })\n  {\n    const dst = new Uint8Array(target);\n    for (\n    let srcStart = 0, dstStart = offset;\n    srcStart < src.byteLength;\n    srcStart += size, dstStart += targetStride)\n    {\n      memcpy({ src, start: srcStart, length: size }, { dst, start: dstStart });\n    }\n  }\n\n  createTestAndPipelineData(\n  state,\n  vertexCount,\n  instanceCount)\n  {\n    // Gather the test data and some additional test state for attribs.\n    return mapStateAttribs(state, (buffer, attrib) => {\n      const maxCount = buffer.stepMode === 'instance' ? instanceCount : vertexCount;\n      const formatInfo = kVertexFormatInfo[attrib.format];\n\n      let testData = this.generateTestData(attrib.format);\n      testData = this.expandTestData(testData, maxCount, formatInfo.componentCount);\n\n      return {\n        ...testData,\n        ...attrib\n      };\n    });\n  }\n\n  createExpectedBG(state, pipeline) {\n    // Create the bindgroups from that test data\n    const bgEntries = [];\n\n    for (const buffer of state) {\n      for (const attrib of buffer.attributes) {\n        const expectedDataBuffer = this.makeBufferWithContents(\n          new Uint8Array(attrib.expectedData),\n          GPUBufferUsage.UNIFORM | GPUBufferUsage.STORAGE\n        );\n        bgEntries.push({\n          binding: attrib.shaderLocation,\n          resource: { buffer: expectedDataBuffer }\n        });\n      }\n    }\n\n    return this.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: bgEntries\n    });\n  }\n\n  createVertexBuffers(\n  state,\n  vertexCount,\n  instanceCount)\n  {\n    // Create the vertex buffers\n    const vertexBuffers = [];\n\n    for (const buffer of state) {\n      const maxCount = buffer.stepMode === 'instance' ? instanceCount : vertexCount;\n\n      // Fill the vertex data with garbage so that we don't get `0` (which could be a test value)\n      // if the vertex shader loads the vertex data incorrectly.\n      const vertexData = new ArrayBuffer(\n        align(buffer.arrayStride * maxCount + (buffer.vbOffset ?? 0), 4)\n      );\n      new Uint8Array(vertexData).fill(0xc4);\n\n      for (const attrib of buffer.attributes) {\n        const formatInfo = kVertexFormatInfo[attrib.format];\n        this.interleaveVertexDataInto(vertexData, attrib.vertexData, {\n          targetStride: buffer.arrayStride,\n          offset: (buffer.vbOffset ?? 0) + attrib.offset,\n          size: formatInfo.byteSize\n        });\n      }\n\n      vertexBuffers.push({\n        slot: buffer.slot,\n        buffer: this.makeBufferWithContents(new Uint8Array(vertexData), GPUBufferUsage.VERTEX),\n        vbOffset: buffer.vbOffset,\n        attributes: []\n      });\n    }\n\n    return vertexBuffers;\n  }\n\n  runTest(\n  buffers,\n  // Default to using 20 vertices and 20 instances so that we cover each of the test data at least\n  // once (at the time of writing the largest testData has 16 values).\n  vertexCount = 20,\n  instanceCount = 20)\n  {\n    const testData = this.createTestAndPipelineData(buffers, vertexCount, instanceCount);\n    const pipeline = this.makeTestPipeline(testData, vertexCount, instanceCount);\n    const expectedDataBG = this.createExpectedBG(testData, pipeline);\n    const vertexBuffers = this.createVertexBuffers(testData, vertexCount, instanceCount);\n    this.submitRenderPass(pipeline, vertexBuffers, expectedDataBG, vertexCount, instanceCount);\n  }\n}\n\nexport const g = makeTestGroup(VertexStateTest);\n\ng.test('vertex_format_to_shader_format_conversion').\ndesc(\n  `Test that the raw data passed in vertex buffers is correctly converted to the input type in the shader. Test for:\n  - all formats\n  - 1 to 4 components in the shader's input type (unused components are filled with 0 and except the 4th with 1)\n  - various locations\n  - various slots`\n).\nparams((u) =>\nu //\n.combine('format', kVertexFormats).\ncombine('shaderComponentCount', [1, 2, 3, 4]).\nbeginSubcases().\ncombine('slotVariant', [\n{ mult: 0, add: 0 },\n{ mult: 0, add: 1 },\n{ mult: 1, add: -1 }]\n).\ncombine('shaderLocationVariant', [\n{ mult: 0, add: 0 },\n{ mult: 0, add: 1 },\n{ mult: 1, add: -1 }]\n)\n).\nfn((t) => {\n  const { format, shaderComponentCount, slotVariant, shaderLocationVariant } = t.params;\n  const slot = t.makeLimitVariant('maxVertexBuffers', slotVariant);\n  const shaderLocation = t.makeLimitVariant('maxVertexAttributes', shaderLocationVariant);\n  t.runTest([\n  {\n    slot,\n    arrayStride: 16,\n    stepMode: 'vertex',\n    attributes: [\n    {\n      shaderLocation,\n      format,\n      offset: 0,\n      shaderComponentCount\n    }]\n\n  }]\n  );\n});\n\ng.test('setVertexBuffer_offset_and_attribute_offset').\ndesc(\n  `Test that the vertex buffer offset and attribute offset in the vertex state are applied correctly. Test for:\n  - all formats\n  - various setVertexBuffer offsets\n  - various attribute offsets in a fixed arrayStride`\n).\nparams((u) =>\nu //\n.combine('format', kVertexFormats).\nbeginSubcases().\ncombine('vbOffset', [0, 4, 400, 1004]).\ncombine('arrayStride', [128]).\nexpand('offset', (p) => {\n  const formatInfo = kVertexFormatInfo[p.format];\n  const formatSize = formatInfo.byteSize;\n  return new Set([\n  0,\n  4,\n  8,\n  formatSize,\n  formatSize * 2,\n  p.arrayStride / 2,\n  p.arrayStride - formatSize - 4,\n  p.arrayStride - formatSize - 8,\n  p.arrayStride - formatSize - formatSize,\n  p.arrayStride - formatSize - formatSize * 2,\n  p.arrayStride - formatSize]\n  );\n})\n).\nfn((t) => {\n  const { format, vbOffset, arrayStride, offset } = t.params;\n  t.runTest([\n  {\n    slot: 0,\n    arrayStride,\n    stepMode: 'vertex',\n    vbOffset,\n    attributes: [\n    {\n      shaderLocation: 0,\n      format,\n      offset\n    }]\n\n  }]\n  );\n});\n\ng.test('non_zero_array_stride_and_attribute_offset').\ndesc(\n  `Test that the array stride and attribute offset in the vertex state are applied correctly. Test for:\n  - all formats\n  - various array strides\n  - various attribute offsets in a fixed arrayStride`\n).\nparams((u) =>\nu //\n.combine('format', kVertexFormats).\nbeginSubcases().\nexpand('arrayStrideVariant', (p) => {\n  const formatInfo = kVertexFormatInfo[p.format];\n  const formatSize = formatInfo.byteSize;\n\n  return [\n  { mult: 0, add: align(formatSize, 4) },\n  { mult: 0, add: align(formatSize, 4) + 4 },\n  { mult: 1, add: 0 }];\n\n}).\nexpand('offsetVariant', function* (p) {\n  const formatInfo = kVertexFormatInfo[p.format];\n  const formatSize = formatInfo.byteSize;\n  yield { mult: 0, add: 0 };\n  yield { mult: 0, add: 4 };\n  if (formatSize !== 4) yield { mult: 0, add: formatSize };\n  yield { mult: 0.5, add: 0 };\n  yield { mult: 1, add: -formatSize * 2 };\n  if (formatSize !== 4) yield { mult: 1, add: -formatSize - 4 };\n  yield { mult: 1, add: -formatSize };\n})\n).\nfn((t) => {\n  const { format, arrayStrideVariant, offsetVariant } = t.params;\n  const arrayStride = t.makeLimitVariant('maxVertexBufferArrayStride', arrayStrideVariant);\n  const formatInfo = kVertexFormatInfo[format];\n  const formatSize = formatInfo.byteSize;\n  const offset = clamp(makeValueTestVariant(arrayStride, offsetVariant), {\n    min: 0,\n    max: arrayStride - formatSize\n  });\n\n  t.runTest([\n  {\n    slot: 0,\n    arrayStride,\n    stepMode: 'vertex',\n    attributes: [\n    {\n      shaderLocation: 0,\n      format,\n      offset\n    }]\n\n  }]\n  );\n});\n\ng.test('buffers_with_varying_step_mode').\ndesc(\n  `Test buffers with varying step modes in the same vertex state.\n  - Various combination of step modes`\n).\nparamsSubcasesOnly((u) =>\nu //\n.combine('stepModes', [\n['instance'],\n['vertex', 'vertex', 'instance'],\n['instance', 'vertex', 'instance'],\n['vertex', 'instance', 'vertex', 'vertex']]\n)\n).\nfn((t) => {\n  const { stepModes } = t.params;\n  const state = stepModes.map((stepMode, i) => ({\n    slot: i,\n    arrayStride: 4,\n    stepMode,\n    attributes: [\n    {\n      shaderLocation: i,\n      format: 'float32',\n      offset: 0\n    }]\n\n  }));\n  t.runTest(state);\n});\n\ng.test('vertex_buffer_used_multiple_times_overlapped').\ndesc(\n  `Test using the same vertex buffer in for multiple \"vertex buffers\", with data from each buffer overlapping.\n  - For each vertex format.\n  - For various numbers of vertex buffers [2, 3, max]`\n).\nparams((u) =>\nu //\n.combine('format', kVertexFormats).\nbeginSubcases().\ncombine('vbCountVariant', [\n{ mult: 0, add: 2 },\n{ mult: 0, add: 3 },\n{ mult: 1, add: 0 }]\n).\ncombine('additionalVBOffset', [0, 4, 120])\n).\nfn((t) => {\n  const { format, vbCountVariant, additionalVBOffset } = t.params;\n  const vbCount = t.makeLimitVariant('maxVertexBuffers', vbCountVariant);\n  const kVertexCount = 20;\n  const kInstanceCount = 1;\n  const formatInfo = kVertexFormatInfo[format];\n  const formatByteSize = formatInfo.byteSize;\n  // We need to align so the offset for non-0 setVertexBuffer don't fail validation.\n  const alignedFormatByteSize = align(formatByteSize, 4);\n\n  // In this test we want to test using the same vertex buffer for multiple different attributes.\n  // For example if vbCount is 3, we will create a vertex buffer containing the following data:\n  //    a0, a1, a2, a3, ..., a<baseDataVertexCount>\n  // We also create the expected data for the vertex fetching from that buffer so we can modify it\n  // below.\n  const baseDataVertexCount = kVertexCount + vbCount - 1;\n  const baseData = t.createTestAndPipelineData(\n    [\n    {\n      slot: 0,\n      arrayStride: alignedFormatByteSize,\n      stepMode: 'vertex',\n      vbOffset: additionalVBOffset,\n      attributes: [{ shaderLocation: 0, format, offset: 0 }]\n    }],\n\n    baseDataVertexCount,\n    kInstanceCount\n  );\n  const vertexBuffer = t.createVertexBuffers(baseData, baseDataVertexCount, kInstanceCount)[0].\n  buffer;\n\n  // We are going to bind the vertex buffer multiple times, each time at a different offset that's\n  // a multiple of the data size. So what should be fetched by the vertex shader is:\n  //    - attrib0: a0, a1, ..., a19\n  //    - attrib1: a1, a2, ..., a20\n  //    - attrib2: a2, a3, ..., a21\n  //    etc.\n  // We re-create the test data by:\n  //   1) creating multiple \"vertex buffers\" that all point at the GPUBuffer above but at\n  //      different offsets.\n  //   2) selecting what parts of the expectedData each attribute will see in the expectedData for\n  //      the full vertex buffer.\n  const baseTestData = baseData[0].attributes[0];\n  assert(baseTestData.testComponentCount === formatInfo.componentCount * baseDataVertexCount);\n  const expectedDataBytesPerVertex = baseTestData.expectedData.byteLength / baseDataVertexCount;\n\n  const testData = [];\n  const vertexBuffers = [];\n  for (let i = 0; i < vbCount; i++) {\n    vertexBuffers.push({\n      buffer: vertexBuffer,\n      slot: i,\n      vbOffset: additionalVBOffset + i * alignedFormatByteSize,\n      attributes: []\n    });\n\n    testData.push({\n      slot: i,\n      arrayStride: alignedFormatByteSize,\n      stepMode: 'vertex',\n      attributes: [\n      {\n        shaderLocation: i,\n        format,\n        offset: 0,\n\n        shaderBaseType: baseTestData.shaderBaseType,\n        floatTolerance: baseTestData.floatTolerance,\n        // Select vertices [i, i + kVertexCount]\n        testComponentCount: kVertexCount * formatInfo.componentCount,\n        expectedData: baseTestData.expectedData.slice(\n          expectedDataBytesPerVertex * i,\n          expectedDataBytesPerVertex * (kVertexCount + i)\n        ),\n        vertexData: new ArrayBuffer(0)\n      }]\n\n    });\n  }\n\n  // Run the test with the modified test data.\n  const pipeline = t.makeTestPipeline(testData, kVertexCount, kInstanceCount);\n  const expectedDataBG = t.createExpectedBG(testData, pipeline);\n  t.submitRenderPass(pipeline, vertexBuffers, expectedDataBG, kVertexCount, kInstanceCount);\n});\n\ng.test('vertex_buffer_used_multiple_times_interleaved').\ndesc(\n  `Test using the same vertex buffer in for multiple \"vertex buffers\", with data from each buffer interleaved.\n  - For each vertex format.\n  - For various numbers of vertex buffers [2, 3, max]`\n).\nparams((u) =>\nu //\n.combine('format', kVertexFormats).\nbeginSubcases().\ncombine('vbCountVariant', [\n{ mult: 0, add: 2 },\n{ mult: 0, add: 3 },\n{ mult: 1, add: 0 }]\n).\ncombine('additionalVBOffset', [0, 4, 120])\n).\nfn((t) => {\n  const { format, vbCountVariant, additionalVBOffset } = t.params;\n  const vbCount = t.makeLimitVariant('maxVertexBuffers', vbCountVariant);\n  const kVertexCount = 20;\n  const kInstanceCount = 1;\n  const formatInfo = kVertexFormatInfo[format];\n  const formatByteSize = formatInfo.byteSize;\n  // We need to align so the offset for non-0 setVertexBuffer don't fail validation.\n  const alignedFormatByteSize = align(formatByteSize, 4);\n\n  // Create data for a single vertex buffer with many attributes, that will be split between\n  // many vertex buffers set at different offsets.\n\n  // In this test we want to test using the same vertex buffer for multiple different attributes.\n  // For example if vbCount is 3, we will create a vertex buffer containing the following data:\n  //    a0, a0, a0, a1, a1, a1, ...\n  // To do that we create a single vertex buffer with `vbCount` attributes that all have the same\n  // format.\n  const attribs = [];\n  for (let i = 0; i < vbCount; i++) {\n    attribs.push({ format, offset: i * alignedFormatByteSize, shaderLocation: i });\n  }\n  const baseData = t.createTestAndPipelineData(\n    [\n    {\n      slot: 0,\n      arrayStride: alignedFormatByteSize * vbCount,\n      stepMode: 'vertex',\n      vbOffset: additionalVBOffset,\n      attributes: attribs\n    }],\n\n    // Request one vertex more than what we need so we have an extra full stride. Otherwise WebGPU\n    // validation of vertex being in bounds will fail for all vertex buffers at an offset that's\n    // not 0 (since their last stride will go beyond the data for vertex kVertexCount -1).\n    kVertexCount + 1,\n    kInstanceCount\n  );\n  const vertexBuffer = t.createVertexBuffers(baseData, kVertexCount + 1, kInstanceCount)[0].\n  buffer;\n\n  // Then we recreate test data by:\n  //   1) creating multiple \"vertex buffers\" that all point at the GPUBuffer above but at\n  //      different offsets.\n  //   2) have multiple vertex buffer, each with one attributes that will expect a0, a1, ...\n  const testData = [];\n  const vertexBuffers = [];\n  for (let i = 0; i < vbCount; i++) {\n    vertexBuffers.push({\n      slot: i,\n      buffer: vertexBuffer,\n      vbOffset: additionalVBOffset + i * alignedFormatByteSize,\n      attributes: []\n    });\n    testData.push({\n      ...baseData[0],\n      slot: i,\n      attributes: [{ ...baseData[0].attributes[i], offset: 0 }]\n    });\n  }\n\n  // Run the test with the modified test data.\n  const pipeline = t.makeTestPipeline(testData, kVertexCount, kInstanceCount);\n  const expectedDataBG = t.createExpectedBG(testData, pipeline);\n  t.submitRenderPass(pipeline, vertexBuffers, expectedDataBG, kVertexCount, kInstanceCount);\n});\n\ng.test('max_buffers_and_attribs').\ndesc(\n  `Test a vertex state that loads as many attributes and buffers as possible.\n  - For each format.\n  `\n).\nparams((u) => u.combine('format', kVertexFormats)).\nfn((t) => {\n  const { format } = t.params;\n  // In compat mode, @builtin(vertex_index) and @builtin(instance_index) each take an attribute\n  const maxVertexBuffers = t.device.limits.maxVertexBuffers;\n  const deviceMaxVertexAttributes = t.device.limits.maxVertexAttributes;\n  const maxVertexAttributes = deviceMaxVertexAttributes - (t.isCompatibility ? 2 : 0);\n  const attributesPerBuffer = Math.ceil(maxVertexAttributes / maxVertexBuffers);\n  let attributesEmitted = 0;\n\n  const state = [];\n  for (let i = 0; i < maxVertexBuffers; i++) {\n    const attributes = [];\n    for (let j = 0; j < attributesPerBuffer && attributesEmitted < maxVertexAttributes; j++) {\n      attributes.push({ format, offset: 0, shaderLocation: attributesEmitted });\n      attributesEmitted++;\n    }\n    state.push({\n      slot: i,\n      stepMode: 'vertex',\n      arrayStride: 32,\n      attributes\n    });\n  }\n  t.runTest(state);\n});\n\ng.test('array_stride_zero').\ndesc(\n  `Test that arrayStride 0 correctly uses the same data for all vertex/instances, while another test vertex buffer with arrayStride != 0 gets different data.\n  - Test for all formats\n  - Test for both step modes`\n).\nparams((u) =>\nu //\n.combine('format', kVertexFormats).\nbeginSubcases().\ncombine('stepMode', ['vertex', 'instance']).\nexpand('offsetVariant', (p) => {\n  const formatInfo = kVertexFormatInfo[p.format];\n  const formatSize = formatInfo.byteSize;\n  return filterUniqueValueTestVariants([\n  { mult: 0, add: 0 },\n  { mult: 0, add: 4 },\n  { mult: 0, add: 8 },\n  { mult: 0, add: formatSize },\n  { mult: 0, add: formatSize * 2 },\n  { mult: 0.5, add: 0 },\n  { mult: 1, add: -formatSize - 4 },\n  { mult: 1, add: -formatSize - 8 },\n  { mult: 1, add: -formatSize },\n  { mult: 1, add: -formatSize * 2 }]\n  );\n})\n).\nfn((t) => {\n  const { format, stepMode, offsetVariant } = t.params;\n  const offset = t.makeLimitVariant('maxVertexBufferArrayStride', offsetVariant);\n  const kCount = 10;\n\n  // Create the stride 0 part of the test, first by faking a single vertex being drawn and\n  // then expanding the data to cover kCount vertex / instances\n  const stride0TestData = t.createTestAndPipelineData(\n    [\n    {\n      slot: 0,\n      arrayStride: 2048,\n      stepMode,\n      vbOffset: offset, // used to push data in the vertex buffer\n      attributes: [{ format, offset: 0, shaderLocation: 0 }]\n    }],\n\n    1,\n    1\n  )[0];\n  const stride0VertexBuffer = t.createVertexBuffers([stride0TestData], kCount, kCount)[0];\n\n  // Expand the stride0 test data to have kCount values for expectedData.\n  const originalData = stride0TestData.attributes[0].expectedData;\n  const expandedData = new ArrayBuffer(kCount * originalData.byteLength);\n  for (let i = 0; i < kCount; i++) {\n    new Uint8Array(expandedData, originalData.byteLength * i).set(new Uint8Array(originalData));\n  }\n\n  // Fixup stride0TestData to use arrayStride 0.\n  stride0TestData.attributes[0].offset = offset;\n  stride0TestData.attributes[0].expectedData = expandedData;\n  stride0TestData.attributes[0].testComponentCount *= kCount;\n  stride0TestData.arrayStride = 0;\n  stride0VertexBuffer.vbOffset = 0;\n\n  // Create the part of the state that will be varying for each vertex / instance\n  const varyingTestData = t.createTestAndPipelineData(\n    [\n    {\n      slot: 1,\n      arrayStride: 32,\n      stepMode,\n      attributes: [{ format, offset: 0, shaderLocation: 1 }]\n    }],\n\n    kCount,\n    kCount\n  )[0];\n  const varyingVertexBuffer = t.createVertexBuffers([varyingTestData], kCount, kCount)[0];\n\n  // Run the test with the merged test state.\n  const state = [stride0TestData, varyingTestData];\n  const vertexBuffers = [stride0VertexBuffer, varyingVertexBuffer];\n\n  const pipeline = t.makeTestPipeline(state, kCount, kCount);\n  const expectedDataBG = t.createExpectedBG(state, pipeline);\n  t.submitRenderPass(pipeline, vertexBuffers, expectedDataBG, kCount, kCount);\n});\n\ng.test('discontiguous_location_and_attribs').\ndesc('Test that using far away slots / shaderLocations works as expected').\nfn((t) => {\n  t.runTest([\n  {\n    slot: t.device.limits.maxVertexBuffers - 1,\n    arrayStride: 4,\n    stepMode: 'vertex',\n    attributes: [\n    { format: 'uint8x2', offset: 2, shaderLocation: 0 },\n    { format: 'uint8x2', offset: 0, shaderLocation: 8 }]\n\n  },\n  {\n    slot: 1,\n    arrayStride: 16,\n    stepMode: 'instance',\n    vbOffset: 1000,\n    attributes: [\n    {\n      format: 'uint32x4',\n      offset: 0,\n      shaderLocation: t.device.limits.maxVertexAttributes - 1\n    }]\n\n  }]\n  );\n});\n\ng.test('overlapping_attributes').\ndesc(\n  `Test that overlapping attributes in the same vertex buffer works\n   - Test for all formats`\n).\nparams((u) => u.combine('format', kVertexFormats)).\nfn((t) => {\n  const { format } = t.params;\n\n  // In compat mode, @builtin(vertex_index) and @builtin(instance_index) each take an attribute\n  const maxVertexAttributes = t.device.limits.maxVertexAttributes - (t.isCompatibility ? 2 : 0);\n  const attributes = [];\n  for (let i = 0; i < maxVertexAttributes; i++) {\n    attributes.push({ format, offset: 0, shaderLocation: i });\n  }\n\n  t.runTest([\n  {\n    slot: 0,\n    stepMode: 'vertex',\n    arrayStride: 32,\n    attributes\n  }]\n  );\n});"],"mappings":"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","ignoreList":[]}