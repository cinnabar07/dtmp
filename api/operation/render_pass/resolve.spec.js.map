{"version":3,"file":"resolve.spec.js","names":["description","makeTestGroup","GPUTest","TextureTestMixin","kSlotsToResolve","kSize","kFormat","g","test","params","u","combine","beginSubcases","fn","t","targets","i","numColorAttachments","push","format","pipeline","device","createRenderPipeline","layout","vertex","module","createShaderModule","code","entryPoint","fragment","primitive","topology","multisample","count","resolveTargets","renderPassColorAttachments","kResolveTargetSize","resolveTargetBaseMipLevel","colorAttachment","createTextureTracked","size","width","height","depthOrArrayLayers","sampleCount","mipLevelCount","usage","GPUTextureUsage","COPY_DST","COPY_SRC","RENDER_ATTACHMENT","slotsToResolve","includes","resolveTarget","resolveTargetBaseArrayLayer","view","createView","clearValue","r","b","a","loadOp","storeOp","storeOperation","baseMipLevel","baseArrayLayer","encoder","globalThis","_TRAMPOLINE_","createCommandEncoder","pass","beginRenderPass","colorAttachments","setPipeline","draw","end","queue","submit","finish","z","expectSinglePixelComparisonsAreOkInTexture","texture","mipLevel","coord","x","y","exp","R","G","B","A"],"sources":["../../../../../src/webgpu/api/operation/render_pass/resolve.spec.ts"],"sourcesContent":["/**\n* AUTO-GENERATED - DO NOT EDIT. Source: https://github.com/gpuweb/cts\n**/export const description = `API Operation Tests for RenderPass StoreOp.\nTests a render pass with a resolveTarget resolves correctly for many combinations of:\n  - number of color attachments, some with and some without a resolveTarget\n  - renderPass storeOp set to {'store', 'discard'}\n  - resolveTarget mip level {0, >0} (TODO?: different mip level from colorAttachment)\n  - resolveTarget {2d array layer, TODO: 3d slice} {0, >0} with {2d, TODO: 3d} resolveTarget\n    (TODO?: different z from colorAttachment)\n  - TODO: test all renderable color formats\n  - TODO: test that any not-resolved attachments are rendered to correctly.\n  - TODO: test different loadOps\n  - TODO?: resolveTarget mip level {0, >0} (TODO?: different mip level from colorAttachment)\n  - TODO?: resolveTarget {2d array layer, TODO: 3d slice} {0, >0} with {2d, TODO: 3d} resolveTarget\n    (different z from colorAttachment)\n`;import { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { GPUTest, TextureTestMixin } from '../../../gpu_test.js';\n\nconst kSlotsToResolve = [\n[0, 2],\n[1, 3],\n[0, 1, 2, 3]];\n\n\nconst kSize = 4;\nconst kFormat = 'rgba8unorm';\n\nexport const g = makeTestGroup(TextureTestMixin(GPUTest));\n\ng.test('render_pass_resolve').\nparams((u) =>\nu.\ncombine('storeOperation', ['discard', 'store']).\nbeginSubcases().\ncombine('numColorAttachments', [2, 4]).\ncombine('slotsToResolve', kSlotsToResolve).\ncombine('resolveTargetBaseMipLevel', [0, 1]).\ncombine('resolveTargetBaseArrayLayer', [0, 1])\n).\nfn((t) => {\n  const targets = [];\n  for (let i = 0; i < t.params.numColorAttachments; i++) {\n    targets.push({ format: kFormat });\n  }\n\n  // These shaders will draw a white triangle into a texture. After draw, the top left\n  // half of the texture will be white, and the bottom right half will be unchanged. When this\n  // texture is resolved, there will be two distinct colors in each portion of the texture, as\n  // well as a line between the portions that contain the midpoint color due to the multisample\n  // resolve.\n  const pipeline = t.device.createRenderPipeline({\n    layout: 'auto',\n    vertex: {\n      module: t.device.createShaderModule({\n        code: `\n            @vertex fn main(\n              @builtin(vertex_index) VertexIndex : u32\n              ) -> @builtin(position) vec4<f32> {\n              var pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(\n                  vec2<f32>(-1.0, -1.0),\n                  vec2<f32>(-1.0,  1.0),\n                  vec2<f32>( 1.0,  1.0));\n              return vec4<f32>(pos[VertexIndex], 0.0, 1.0);\n            }`\n      }),\n      entryPoint: 'main'\n    },\n    fragment: {\n      module: t.device.createShaderModule({\n        code: `\n            struct Output {\n              @location(0) fragColor0 : vec4<f32>,\n              @location(1) fragColor1 : vec4<f32>,\n              @location(2) fragColor2 : vec4<f32>,\n              @location(3) fragColor3 : vec4<f32>,\n            };\n\n            @fragment fn main() -> Output {\n              return Output(\n                vec4<f32>(1.0, 1.0, 1.0, 1.0),\n                vec4<f32>(1.0, 1.0, 1.0, 1.0),\n                vec4<f32>(1.0, 1.0, 1.0, 1.0),\n                vec4<f32>(1.0, 1.0, 1.0, 1.0)\n              );\n            }`\n      }),\n      entryPoint: 'main',\n      targets\n    },\n    primitive: { topology: 'triangle-list' },\n    multisample: { count: 4 }\n  });\n\n  const resolveTargets = [];\n  const renderPassColorAttachments = [];\n\n  // The resolve target must be the same size as the color attachment. If we're resolving to mip\n  // level 1, the resolve target base mip level should be 2x the color attachment size.\n  const kResolveTargetSize = kSize << t.params.resolveTargetBaseMipLevel;\n\n  for (let i = 0; i < t.params.numColorAttachments; i++) {\n    const colorAttachment = t.createTextureTracked({\n      format: kFormat,\n      size: { width: kSize, height: kSize, depthOrArrayLayers: 1 },\n      sampleCount: 4,\n      mipLevelCount: 1,\n      usage:\n      GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT\n    });\n\n    if (t.params.slotsToResolve.includes(i)) {\n      const colorAttachment = t.createTextureTracked({\n        format: kFormat,\n        size: { width: kSize, height: kSize, depthOrArrayLayers: 1 },\n        sampleCount: 4,\n        mipLevelCount: 1,\n        usage:\n        GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT\n      });\n\n      const resolveTarget = t.createTextureTracked({\n        format: kFormat,\n        size: {\n          width: kResolveTargetSize,\n          height: kResolveTargetSize,\n          depthOrArrayLayers: t.params.resolveTargetBaseArrayLayer + 1\n        },\n        sampleCount: 1,\n        mipLevelCount: t.params.resolveTargetBaseMipLevel + 1,\n        usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT\n      });\n\n      // Clear to black for the load operation. After the draw, the top left half of the attachment\n      // will be white and the bottom right half will be black.\n      renderPassColorAttachments.push({\n        view: colorAttachment.createView(),\n        clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 0.0 },\n        loadOp: 'clear',\n        storeOp: t.params.storeOperation,\n        resolveTarget: resolveTarget.createView({\n          baseMipLevel: t.params.resolveTargetBaseMipLevel,\n          baseArrayLayer: t.params.resolveTargetBaseArrayLayer\n        })\n      });\n\n      resolveTargets.push(resolveTarget);\n    } else {\n      renderPassColorAttachments.push({\n        view: colorAttachment.createView(),\n        clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 0.0 },\n        loadOp: 'clear',\n        storeOp: t.params.storeOperation\n      });\n    }\n  }\n\n  const encoder = globalThis._TRAMPOLINE_(\"createCommandEncoder\", t.device, t.device.createCommandEncoder, [], () => t.device.createCommandEncoder());\n\n  const pass = encoder.beginRenderPass({\n    colorAttachments: renderPassColorAttachments\n  });\n  pass.setPipeline(pipeline);\n  pass.draw(3);\n  pass.end();\n  globalThis._TRAMPOLINE_(\"submit\", t.device, t.device.queue.submit, [[encoder.finish()]], () => t.device.queue.submit([encoder.finish()]));\n\n  // Verify the resolve targets contain the correct values. Note that we use z to specify the\n  // array layer from which to pull the pixels for testing.\n  const z = t.params.resolveTargetBaseArrayLayer;\n  for (const resolveTarget of resolveTargets) {\n    t.expectSinglePixelComparisonsAreOkInTexture(\n      { texture: resolveTarget, mipLevel: t.params.resolveTargetBaseMipLevel },\n      [\n      // Top left pixel should be {1.0, 1.0, 1.0, 1.0}.\n      { coord: { x: 0, y: 0, z }, exp: { R: 1.0, G: 1.0, B: 1.0, A: 1.0 } },\n      // Bottom right pixel should be {0, 0, 0, 0}.\n      { coord: { x: kSize - 1, y: kSize - 1, z }, exp: { R: 0, G: 0, B: 0, A: 0 } },\n      // Top right pixel should be {0.5, 0.5, 0.5, 0.5} due to the multisampled resolve.\n      { coord: { x: kSize - 1, y: 0, z }, exp: { R: 0.5, G: 0.5, B: 0.5, A: 0.5 } }]\n\n    );\n  }\n});"],"mappings":"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","ignoreList":[]}