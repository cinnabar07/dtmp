{"version":3,"file":"error_test.js","names":["Fixture","getGPU","assert","raceWithRejectOnTimeout","ErrorTest","_device","undefined","device","init","gpu","rec","adapter","globalThis","_TRAMPOLINE_","requestAdapter","requestDeviceTracked","requiredLimits","maxTextureDimension2D","limits","maxTextureArrayLayers","generateError","filter","trackForCleanup","createTexture","format","usage","GPUTextureUsage","COPY_DST","size","createBuffer","queue","submit","isInstanceOfError","error","GPUOutOfMemoryError","GPUValidationError","GPUInternalError","expectUncapturedError","fn","immediateAsyncExpectation","TIMEOUT_IN_MS","promise","Promise","resolve","eventListener","event","debug","addEventListener","once"],"sources":["../../src/webgpu/error_test.ts"],"sourcesContent":["/**\n* AUTO-GENERATED - DO NOT EDIT. Source: https://github.com/gpuweb/cts\n**/import { Fixture } from '../common/framework/fixture.js';import { getGPU } from '../common/util/navigator_gpu.js';import { assert, raceWithRejectOnTimeout } from '../common/util/util.js';\n\n/**\n * A test class to help test error scopes and uncapturederror events.\n */\nexport class ErrorTest extends Fixture {\n  _device = undefined;\n\n  get device() {\n    assert(this._device !== undefined);\n    return this._device;\n  }\n\n  async init() {\n    await super.init();\n    const gpu = getGPU(this.rec);\n    const adapter = await globalThis._TRAMPOLINE_(\"requestAdapter\", gpu, gpu.requestAdapter, [], () => gpu.requestAdapter());\n    assert(adapter !== null);\n\n    // We need to max out the adapter limits related to texture dimensions to more reliably cause an\n    // OOM error when asked for it, so set that on the device now.\n    const device = await this.requestDeviceTracked(adapter, {\n      requiredLimits: {\n        maxTextureDimension2D: adapter.limits.maxTextureDimension2D,\n        maxTextureArrayLayers: adapter.limits.maxTextureArrayLayers\n      }\n    });\n    assert(device !== null);\n    this._device = device;\n  }\n\n  /**\n   * Generates an error of the given filter type. For now, the errors are generated by calling a\n   * known code-path to cause the error. This can be updated in the future should there be a more\n   * direct way to inject errors.\n   */\n  generateError(filter) {\n    switch (filter) {\n      case 'out-of-memory':\n        this.trackForCleanup(\n          this.device.createTexture({\n            // One of the largest formats. With the base limits, the texture will be 256 GiB.\n            format: 'rgba32float',\n            usage: GPUTextureUsage.COPY_DST,\n            size: [\n            this.device.limits.maxTextureDimension2D,\n            this.device.limits.maxTextureDimension2D,\n            this.device.limits.maxTextureArrayLayers]\n\n          })\n        );\n        break;\n      case 'validation':\n        // Generating a validation error by passing in an invalid usage when creating a buffer.\n        this.trackForCleanup(globalThis._TRAMPOLINE_(\"createBuffer\",\n        this.device, this.device.createBuffer, [{\n          size: 1024,\n          usage: 0xffff // Invalid GPUBufferUsage\n        }], () => this.device.createBuffer({ size: 1024, usage: 0xffff }))\n        );\n        break;\n    }\n    // MAINTENANCE_TODO: This is a workaround for Chromium not flushing. Remove when not needed.\n    globalThis._TRAMPOLINE_(\"submit\", this.device, this.device.queue.submit, [[]], () => this.device.queue.submit([]));\n  }\n\n  /**\n   * Checks whether the error is of the type expected given the filter.\n   */\n  isInstanceOfError(filter, error) {\n    switch (filter) {\n      case 'out-of-memory':\n        return error instanceof GPUOutOfMemoryError;\n      case 'validation':\n        return error instanceof GPUValidationError;\n      case 'internal':\n        return error instanceof GPUInternalError;\n    }\n  }\n\n  /**\n   * Expect an uncapturederror event to occur. Note: this MUST be awaited, because\n   * otherwise it could erroneously pass by capturing an error from later in the test.\n   */\n  async expectUncapturedError(fn) {\n    return this.immediateAsyncExpectation(() => {\n      // MAINTENANCE_TODO: Make arbitrary timeout value a test runner variable\n      const TIMEOUT_IN_MS = 1000;\n\n      const promise = new Promise((resolve) => {\n        const eventListener = (event) => {\n          this.debug(`Got uncaptured error event with ${event.error}`);\n          resolve(event);\n        };\n\n        this.device.addEventListener('uncapturederror', eventListener, { once: true });\n      });\n\n      fn();\n\n      return raceWithRejectOnTimeout(\n        promise,\n        TIMEOUT_IN_MS,\n        'Timeout occurred waiting for uncaptured error'\n      );\n    });\n  }\n}"],"mappings":"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","ignoreList":[]}