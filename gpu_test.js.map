{"version":3,"file":"gpu_test.js","names":["Fixture","SkipTestCase","SubcaseBatchState","globalTestConfig","getGPU","assert","makeValueTestVariant","memcpy","range","unreachable","getDefaultLimits","kQueryTypeInfo","kTextureFormatInfo","kEncodableTextureFormats","resolvePerAspectFormat","isCompressedTextureFormat","isTextureFormatUsableAsStorageFormat","checkElementsEqual","checkElementsBetween","CommandBufferMaker","DevicePool","align","roundDown","physicalMipSizeFromTexture","virtualMipSize","bytesInACompleteRow","getTextureCopyLayout","getTextureSubCopyLayout","kTexelRepresentationInfo","TexelView","textureContentIsOKByT2B","createTextureFromTexelViews","reifyExtent3D","reifyOrigin3D","devicePool","mismatchedDevicePool","kResourceStateValues","kResourceStates","initUncanonicalizedDeviceDescriptor","descriptor","requiredFeatures","Array","filter","f","undefined","GPUTestSubcaseBatchState","postInit","acquireProvider","finalize","Promise","all","provider","then","x","release","mismatchedProvider","selectDeviceOrSkipTestCase","isCompatibility","compatibility","descriptorModifierFn","acquire","recorder","catch","selectDeviceForTextureFormatOrSkipTestCase","formats","isArray","features","Set","format","skipIfTextureFormatNotSupported","add","feature","from","selectDeviceForQueryTypeOrSkipTestCase","types","map","t","acquireMismatchedProvider","selectMismatchedDeviceOrSkipTestCase","skip","msg","skipIf","cond","skipIfCopyTextureToTextureNotSupportedForFormat","skipIfTextureViewDimensionNotSupported","dimensions","dimension","skipIfTextureFormatNotUsableAsStorageTexture","skipIfTextureLoadNotSupportedForTextureType","type","skipIfInterpolationTypeOrSamplingNotSupported","sampling","skipIfDepthTextureCanNotBeUsedWithNonComparisonSampler","skipIfLanguageFeatureNotSupported","langFeature","hasLanguageFeature","skipIfLanguageFeatureSupported","lf","wgslLanguageFeatures","has","GPUTestBase","MakeSharedState","params","device","queue","getDefaultLimit","limit","default","makeLimitVariant","variant","limits","canCallCopyTextureToBufferWithTextureFormat","createCopyForMapRead","src","srcOffset","size","dst","createBufferTracked","usage","GPUBufferUsage","MAP_READ","COPY_DST","c","globalThis","_TRAMPOLINE_","createCommandEncoder","copyBufferToBuffer","submit","finish","createAlignedCopyForMapRead","offset","alignedOffset","subarrayByteStart","alignedSize","mappable","readGPUBufferRangeTyped","srcByteOffset","method","typedLength","BYTES_PER_ELEMENT","byteLength","mapOffset","mapSize","subarrayStart","mapAsync","GPUMapMode","READ","mapped","getMappedRange","data","subarray","cleanup","unmap","destroy","rec","expectGPUBufferValuesPassCheck","check","mode","readbackPromise","eventualAsyncExpectation","niceStack","readback","expectOK","expectGPUBufferValuesEqual","expected","a","constructor","length","expectGPUBufferRepeatsSingleValue","buffer","expectedValue","numRows","minBytesPerRow","bytesPerRow","valueSize","kMaxBufferSizeToCheckOnCpu","bufferSize","valueBytes","Uint8Array","rowValues","fill","rowBytes","concat","expectedContents","row","set","storageBuffer","STORAGE","expectedDataSize","Math","max","expectedDataBuffer","mappedAtCreation","expectedData","Uint32Array","value","values","min","padding","expectedBytes","Uint16Array","expectedWords","resultBuffer","COPY_SRC","readsPerRow","ceil","reducer","pipeline","createComputePipeline","layout","compute","module","createShaderModule","code","entryPoint","bindGroup","createBindGroup","getBindGroupLayout","entries","binding","resource","commandEncoder","pass","beginComputePass","setPipeline","setBindGroup","dispatchWorkgroups","end","expectedResults","expectSingleColor","exp","slice","aspect","rowsPerImage","mipSize","copySize","rep","expectedTexelData","pack","encode","copyTextureToBuffer","texture","mipLevel","origin","y","z","readSinglePixelFrom2DTexture","expectSinglePixelBetweenTwoValuesIn2DTexture","generateWarningOnly","checkElementsBetweenFn","act","b","i","copy2DTextureToBufferUsingComputePass","componentCount","textureView","sampleCount","extent_","origin_","extent","width","height","kWorkgroupSizeX","kWorkgroupSizeY","textureSrcCode","computePipeline","uniformBuffer","makeBufferWithContents","UNIFORM","uniformBindGroup","encoder","floor","expectGPUError","fn","shouldError","pushErrorScope","returnValue","promise","popErrorScope","error","failed","GPUOutOfMemoryError","GPUValidationError","message","expectationFailed","debug","expectValidationError","gpuValidationError","validationFailed","trackForCleanup","createBuffer","createTextureTracked","createTexture","createQuerySetTracked","createQuerySet","dataArray","createEncoder","encoderType","attachmentInfo","occlusionQuerySet","fullAttachmentInfo","colorFormats","rbEncoder","createRenderBundleEncoder","executeBundles","makeAttachmentView","GPUTextureUsage","RENDER_ATTACHMENT","createView","depthStencilAttachment","depthStencilFormat","view","depthReadOnly","stencilReadOnly","depth","depthClearValue","depthLoadOp","depthStoreOp","stencil","stencilClearValue","stencilLoadOp","stencilStoreOp","passDesc","colorAttachments","clearValue","loadOp","storeOp","beginRenderPass","GPUTest","init","sharedState","adapter","mismatchedDevice","expectDeviceLost","reason","getAdapterLimitsAsDeviceRequiredLimits","requiredLimits","adapterLimits","key","setAllLimitsToAdapterLimits","desc","descWithMaxLimits","defaultQueue","MaxLimitsGPUTestSubcaseBatchState","wrapper","MaxLimitsTest","s_deviceToResourcesMap","WeakMap","getPipelineToRenderTextureToRGB8UnormTexture","pipelineByPipelineType","Map","get","pipelineType","depthOrArrayLayers","textureType","layerCode","createRenderPipeline","vertex","fragment","targets","TextureTestMixin","Base","TextureExpectations","createTextureFromTexelView","texelView","createTextureFromTexelViewsMultipleMipmaps","texelViews","expectTexelViewComparisonIsOkInTexture","comparisonOptions","maxIntDiff","maxDiffULPsForNormFormat","maxDiffULPsForFloatFormat","eventualExpectOK","expTexelView","expectSinglePixelComparisonsAreOkInTexture","includes","lowerCorner","upperCorner","expMap","coords","e","coord","coordKey","JSON","stringify","push","Symbol","iterator","fromTexelsAsBytes","res","fromTexelsAsColors","coordsF","expectTexturesToMatchByRendering","actualTexture","expectedTexture","readbackPromisesPerTexturePerLayer","ndx","attachmentSize","attachment","label","sampler","createSampler","numLayers","readbackPromisesPerLayer","layer","viewDescriptor","baseMipLevel","mipLevelCount","baseArrayLayer","arrayLayerCount","writeBuffer","draw","copyWholeTextureToNewBufferSimple","readbacksPerTexturePerLayer","readbackPromises","arrayNotAllTheSameValue","arr","first","findIndex","v","Error","actualReadbacksPerLayer","expectedReadbacksPerLayer","actualReadback","expectedReadback","sameOk","blockWidth","blockHeight","bytesPerBlock","blocksPerRow","blocksPerColumn","copyWholeTextureToNewBuffer","resultDataLayout","updateLinearTextureDataSubBox","copyParams","dest","rowLength","texel","iterateBlockRows","srcOffsetElements","getTexelOffsetInBytes","dataLayout","dstOffsetElements","start","textureDataLayout","info","bytesPerImage","color","bytes"],"sources":["../../src/webgpu/gpu_test.ts"],"sourcesContent":["/**\n* AUTO-GENERATED - DO NOT EDIT. Source: https://github.com/gpuweb/cts\n**/import { Fixture,\n\n\n  SkipTestCase,\n  SubcaseBatchState } from\n\n\n'../common/framework/fixture.js';\nimport { globalTestConfig } from '../common/framework/test_config.js';\nimport { getGPU } from '../common/util/navigator_gpu.js';\nimport {\n  assert,\n  makeValueTestVariant,\n  memcpy,\n  range,\n\n\n\n  unreachable } from\n'../common/util/util.js';\n\nimport {\n  getDefaultLimits,\n\n  kQueryTypeInfo } from\n\n'./capability_info.js';\n\nimport {\n  kTextureFormatInfo,\n  kEncodableTextureFormats,\n  resolvePerAspectFormat,\n\n\n  isCompressedTextureFormat,\n\n  isTextureFormatUsableAsStorageFormat } from\n'./format_info.js';\nimport { checkElementsEqual, checkElementsBetween } from './util/check_contents.js';\nimport { CommandBufferMaker } from './util/command_buffer_maker.js';\n\nimport {\n\n\n  DevicePool } from\n\n\n'./util/device_pool.js';\nimport { align, roundDown } from './util/math.js';\nimport { physicalMipSizeFromTexture, virtualMipSize } from './util/texture/base.js';\nimport {\n  bytesInACompleteRow,\n  getTextureCopyLayout,\n  getTextureSubCopyLayout } from\n\n'./util/texture/layout.js';\nimport { kTexelRepresentationInfo } from './util/texture/texel_data.js';\nimport { TexelView } from './util/texture/texel_view.js';\nimport {\n\n\n\n  textureContentIsOKByT2B } from\n'./util/texture/texture_ok.js';\nimport { createTextureFromTexelViews } from './util/texture.js';\nimport { reifyExtent3D, reifyOrigin3D } from './util/unions.js';\n\nconst devicePool = new DevicePool();\n\n// MAINTENANCE_TODO: When DevicePool becomes able to provide multiple devices at once, use the\n// usual one instead of a new one.\nconst mismatchedDevicePool = new DevicePool();\n\nconst kResourceStateValues = ['valid', 'invalid', 'destroyed'];\n\nexport const kResourceStates = kResourceStateValues;\n\n/** Various \"convenient\" shorthands for GPUDeviceDescriptors for selectDevice functions. */\n\n\n\n\n\n\nexport function initUncanonicalizedDeviceDescriptor(\ndescriptor)\n{\n  if (typeof descriptor === 'string') {\n    return { requiredFeatures: [descriptor] };\n  } else if (descriptor instanceof Array) {\n    return {\n      requiredFeatures: descriptor.filter((f) => f !== undefined)\n    };\n  } else {\n    return descriptor;\n  }\n}\n\nexport class GPUTestSubcaseBatchState extends SubcaseBatchState {\n  /** Provider for default device. */\n\n  /** Provider for mismatched device. */\n\n\n  async postInit() {\n    // Skip all subcases if there's no device.\n    await this.acquireProvider();\n  }\n\n  async finalize() {\n    await super.finalize();\n\n    // Ensure devicePool.release is called for both providers even if one rejects.\n    await Promise.all([\n    this.provider?.then((x) => devicePool.release(x)),\n    this.mismatchedProvider?.then((x) => devicePool.release(x))]\n    );\n  }\n\n  /** @internal MAINTENANCE_TODO: Make this not visible to test code? */\n  acquireProvider() {\n    if (this.provider === undefined) {\n      this.selectDeviceOrSkipTestCase(undefined);\n    }\n    assert(this.provider !== undefined);\n    return this.provider;\n  }\n\n  get isCompatibility() {\n    return globalTestConfig.compatibility;\n  }\n\n  getDefaultLimits() {\n    return getDefaultLimits(this.isCompatibility ? 'compatibility' : 'core');\n  }\n\n  /**\n   * Some tests or cases need particular feature flags or limits to be enabled.\n   * Call this function with a descriptor or feature name (or `undefined`) to select a\n   * GPUDevice with matching capabilities. If this isn't called, a default device is provided.\n   *\n   * If the request isn't supported, throws a SkipTestCase exception to skip the entire test case.\n   */\n  selectDeviceOrSkipTestCase(\n  descriptor,\n  descriptorModifierFn)\n  {\n    assert(this.provider === undefined, \"Can't selectDeviceOrSkipTestCase() multiple times\");\n    this.provider = devicePool.acquire(\n      this.recorder,\n      initUncanonicalizedDeviceDescriptor(descriptor),\n      descriptorModifierFn\n    );\n    // Suppress uncaught promise rejection (we'll catch it later).\n    this.provider.catch(() => {});\n  }\n\n  /**\n   * Convenience function for {@link selectDeviceOrSkipTestCase}.\n   * Select a device with the features required by these texture format(s).\n   * If the device creation fails, then skip the test case.\n   */\n  selectDeviceForTextureFormatOrSkipTestCase(\n  formats)\n  {\n    if (!Array.isArray(formats)) {\n      formats = [formats];\n    }\n    const features = new Set();\n    for (const format of formats) {\n      if (format !== undefined) {\n        this.skipIfTextureFormatNotSupported(format);\n        features.add(kTextureFormatInfo[format].feature);\n      }\n    }\n\n    this.selectDeviceOrSkipTestCase(Array.from(features));\n  }\n\n  /**\n   * Convenience function for {@link selectDeviceOrSkipTestCase}.\n   * Select a device with the features required by these query type(s).\n   * If the device creation fails, then skip the test case.\n   */\n  selectDeviceForQueryTypeOrSkipTestCase(types) {\n    if (!Array.isArray(types)) {\n      types = [types];\n    }\n    const features = types.map((t) => kQueryTypeInfo[t].feature);\n    this.selectDeviceOrSkipTestCase(features);\n  }\n\n  /** @internal MAINTENANCE_TODO: Make this not visible to test code? */\n  acquireMismatchedProvider() {\n    return this.mismatchedProvider;\n  }\n\n  /**\n   * Some tests need a second device which is different from the first.\n   * This requests a second device so it will be available during the test. If it is not called,\n   * no second device will be available.\n   *\n   * If the request isn't supported, throws a SkipTestCase exception to skip the entire test case.\n   */\n  selectMismatchedDeviceOrSkipTestCase(descriptor) {\n    assert(\n      this.mismatchedProvider === undefined,\n      \"Can't selectMismatchedDeviceOrSkipTestCase() multiple times\"\n    );\n\n    this.mismatchedProvider = mismatchedDevicePool.acquire(\n      this.recorder,\n      initUncanonicalizedDeviceDescriptor(descriptor),\n      undefined\n    );\n    // Suppress uncaught promise rejection (we'll catch it later).\n    this.mismatchedProvider.catch(() => {});\n  }\n\n  /** Throws an exception marking the subcase as skipped. */\n  skip(msg) {\n    throw new SkipTestCase(msg);\n  }\n\n  /** Throws an exception making the subcase as skipped if condition is true */\n  skipIf(cond, msg = '') {\n    if (cond) {\n      this.skip(typeof msg === 'function' ? msg() : msg);\n    }\n  }\n\n  /**\n   * Skips test if any format is not supported.\n   */\n  skipIfTextureFormatNotSupported(...formats) {\n    if (this.isCompatibility) {\n      for (const format of formats) {\n        if (format === 'bgra8unorm-srgb') {\n          this.skip(`texture format '${format} is not supported`);\n        }\n      }\n    }\n  }\n\n  skipIfCopyTextureToTextureNotSupportedForFormat(...formats) {\n    if (this.isCompatibility) {\n      for (const format of formats) {\n        if (format && isCompressedTextureFormat(format)) {\n          this.skip(`copyTextureToTexture with ${format} is not supported`);\n        }\n      }\n    }\n  }\n\n  skipIfTextureViewDimensionNotSupported(...dimensions) {\n    if (this.isCompatibility) {\n      for (const dimension of dimensions) {\n        if (dimension === 'cube-array') {\n          this.skip(`texture view dimension '${dimension}' is not supported`);\n        }\n      }\n    }\n  }\n\n  skipIfTextureFormatNotUsableAsStorageTexture(...formats) {\n    for (const format of formats) {\n      if (format && !isTextureFormatUsableAsStorageFormat(format, this.isCompatibility)) {\n        this.skip(`Texture with ${format} is not usable as a storage texture`);\n      }\n    }\n  }\n\n  skipIfTextureLoadNotSupportedForTextureType(...types) {\n    if (this.isCompatibility) {\n      for (const type of types) {\n        switch (type) {\n          case 'texture_depth_2d':\n          case 'texture_depth_2d_array':\n          case 'texture_depth_multisampled_2d':\n            this.skip(`${type} is not supported by textureLoad in compatibility mode`);\n        }\n      }\n    }\n  }\n\n  /**\n   * Skips test if the given interpolation type or sampling is not supported.\n   */\n  skipIfInterpolationTypeOrSamplingNotSupported({\n    type,\n    sampling\n\n\n\n  }) {\n    if (this.isCompatibility) {\n      this.skipIf(\n        type === 'linear',\n        'interpolation type linear is not supported in compatibility mode'\n      );\n      this.skipIf(\n        sampling === 'sample',\n        'interpolation type linear is not supported in compatibility mode'\n      );\n      this.skipIf(\n        type === 'flat' && (!sampling || sampling === 'first'),\n        'interpolation type flat with sampling not set to either is not supported in compatibility mode'\n      );\n    }\n  }\n\n  /** Skips this test case if a depth texture can not be used with a non-comparison sampler. */\n  skipIfDepthTextureCanNotBeUsedWithNonComparisonSampler() {\n    this.skipIf(\n      this.isCompatibility,\n      'depth textures are not usable with non-comparison samplers in compatibility mode'\n    );\n  }\n\n  /** Skips this test case if the `langFeature` is *not* supported. */\n  skipIfLanguageFeatureNotSupported(langFeature) {\n    if (!this.hasLanguageFeature(langFeature)) {\n      this.skip(`WGSL language feature '${langFeature}' is not supported`);\n    }\n  }\n\n  /** Skips this test case if the `langFeature` is supported. */\n  skipIfLanguageFeatureSupported(langFeature) {\n    if (this.hasLanguageFeature(langFeature)) {\n      this.skip(`WGSL language feature '${langFeature}' is supported`);\n    }\n  }\n\n  /** returns true iff the `langFeature` is supported  */\n  hasLanguageFeature(langFeature) {\n    const lf = getGPU(this.recorder).wgslLanguageFeatures;\n    return lf !== undefined && lf.has(langFeature);\n  }\n}\n\n/**\n * Base fixture for WebGPU tests.\n *\n * This class is a Fixture + a getter that returns a GPUDevice\n * as well as helpers that use that device.\n */\nexport class GPUTestBase extends Fixture {\n  static MakeSharedState(\n  recorder,\n  params)\n  {\n    return new GPUTestSubcaseBatchState(recorder, params);\n  }\n\n  // This must be overridden in derived classes\n  get device() {\n    unreachable();\n    return null;\n  }\n\n  /** GPUQueue for the test to use. (Same as `t.device.queue`.) */\n  get queue() {\n    return this.device.queue;\n  }\n\n  get isCompatibility() {\n    return globalTestConfig.compatibility;\n  }\n\n  getDefaultLimits() {\n    return getDefaultLimits(this.isCompatibility ? 'compatibility' : 'core');\n  }\n\n  getDefaultLimit(limit) {\n    return this.getDefaultLimits()[limit].default;\n  }\n\n  makeLimitVariant(limit, variant) {\n    return makeValueTestVariant(this.device.limits[limit], variant);\n  }\n\n  canCallCopyTextureToBufferWithTextureFormat(format) {\n    return !this.isCompatibility || !isCompressedTextureFormat(format);\n  }\n\n  /** Snapshot a GPUBuffer's contents, returning a new GPUBuffer with the `MAP_READ` usage. */\n  createCopyForMapRead(src, srcOffset, size) {\n    assert(srcOffset % 4 === 0);\n    assert(size % 4 === 0);\n\n    const dst = this.createBufferTracked({\n      size,\n      usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST\n    });\n\n    const c = globalThis._TRAMPOLINE_(\"createCommandEncoder\", this.device, this.device.createCommandEncoder, [], () => this.device.createCommandEncoder());\n    c.copyBufferToBuffer(src, srcOffset, dst, 0, size);\n    globalThis._TRAMPOLINE_(\"submit\", this, this.queue.submit, [[c.finish()]], () => this.queue.submit([c.finish()]));\n\n    return dst;\n  }\n\n  /**\n   * Offset and size passed to createCopyForMapRead must be divisible by 4. For that\n   * we might need to copy more bytes from the buffer than we want to map.\n   * begin and end values represent the part of the copied buffer that stores the contents\n   * we initially wanted to map.\n   * The copy will not cause an OOB error because the buffer size must be 4-aligned.\n   */\n  createAlignedCopyForMapRead(\n  src,\n  size,\n  offset)\n  {\n    const alignedOffset = roundDown(offset, 4);\n    const subarrayByteStart = offset - alignedOffset;\n    const alignedSize = align(size + subarrayByteStart, 4);\n    const mappable = this.createCopyForMapRead(src, alignedOffset, alignedSize);\n    return { mappable, subarrayByteStart };\n  }\n\n  /**\n   * Snapshot the current contents of a range of a GPUBuffer, and return them as a TypedArray.\n   * Also provides a cleanup() function to unmap and destroy the staging buffer.\n   */\n  async readGPUBufferRangeTyped(\n  src,\n  {\n    srcByteOffset = 0,\n    method = 'copy',\n    type,\n    typedLength\n\n\n\n\n\n  })\n  {\n    assert(\n      srcByteOffset % type.BYTES_PER_ELEMENT === 0,\n      'srcByteOffset must be a multiple of BYTES_PER_ELEMENT'\n    );\n\n    const byteLength = typedLength * type.BYTES_PER_ELEMENT;\n    let mappable;\n    let mapOffset, mapSize, subarrayByteStart;\n    if (method === 'copy') {\n      ({ mappable, subarrayByteStart } = this.createAlignedCopyForMapRead(\n        src,\n        byteLength,\n        srcByteOffset\n      ));\n    } else if (method === 'map') {\n      mappable = src;\n      mapOffset = roundDown(srcByteOffset, 8);\n      mapSize = align(byteLength, 4);\n      subarrayByteStart = srcByteOffset - mapOffset;\n    } else {\n      unreachable();\n    }\n\n    assert(subarrayByteStart % type.BYTES_PER_ELEMENT === 0);\n    const subarrayStart = subarrayByteStart / type.BYTES_PER_ELEMENT;\n\n    // 2. Map the staging buffer, and create the TypedArray from it.\n    await globalThis._TRAMPOLINE_(\"mapAsync\", mappable, mappable.mapAsync, [GPUMapMode.READ, mapOffset, mapSize], () => mappable.mapAsync(GPUMapMode.READ, mapOffset, mapSize));\n    const mapped = new type(mappable.getMappedRange(mapOffset, mapSize));\n    const data = mapped.subarray(subarrayStart, typedLength);\n\n    return {\n      data,\n      cleanup() {\n        mappable.unmap();\n        globalThis._TRAMPOLINE_(\"destroy\", mappable, mappable.destroy, [], () => mappable.destroy());\n      }\n    };\n  }\n\n  /**\n   * Skips test if any format is not supported.\n   */\n  skipIfTextureFormatNotSupported(...formats) {\n    if (this.isCompatibility) {\n      for (const format of formats) {\n        if (format === 'bgra8unorm-srgb') {\n          this.skip(`texture format '${format} is not supported`);\n        }\n      }\n    }\n  }\n\n  skipIfTextureViewDimensionNotSupported(...dimensions) {\n    if (this.isCompatibility) {\n      for (const dimension of dimensions) {\n        if (dimension === 'cube-array') {\n          this.skip(`texture view dimension '${dimension}' is not supported`);\n        }\n      }\n    }\n  }\n\n  skipIfCopyTextureToTextureNotSupportedForFormat(...formats) {\n    if (this.isCompatibility) {\n      for (const format of formats) {\n        if (format && isCompressedTextureFormat(format)) {\n          this.skip(`copyTextureToTexture with ${format} is not supported`);\n        }\n      }\n    }\n  }\n\n  skipIfTextureFormatNotUsableAsStorageTexture(...formats) {\n    for (const format of formats) {\n      if (format && !isTextureFormatUsableAsStorageFormat(format, this.isCompatibility)) {\n        this.skip(`Texture with ${format} is not usable as a storage texture`);\n      }\n    }\n  }\n\n  /** Skips this test case if the `langFeature` is *not* supported. */\n  skipIfLanguageFeatureNotSupported(langFeature) {\n    if (!this.hasLanguageFeature(langFeature)) {\n      this.skip(`WGSL language feature '${langFeature}' is not supported`);\n    }\n  }\n\n  /** Skips this test case if the `langFeature` is supported. */\n  skipIfLanguageFeatureSupported(langFeature) {\n    if (this.hasLanguageFeature(langFeature)) {\n      this.skip(`WGSL language feature '${langFeature}' is supported`);\n    }\n  }\n\n  /** returns true iff the `langFeature` is supported  */\n  hasLanguageFeature(langFeature) {\n    const lf = getGPU(this.rec).wgslLanguageFeatures;\n    return lf !== undefined && lf.has(langFeature);\n  }\n\n  /**\n   * Expect a GPUBuffer's contents to pass the provided check.\n   *\n   * A library of checks can be found in {@link webgpu/util/check_contents}.\n   */\n  expectGPUBufferValuesPassCheck(\n  src,\n  check,\n  {\n    srcByteOffset = 0,\n    type,\n    typedLength,\n    method = 'copy',\n    mode = 'fail'\n\n\n\n\n\n\n  })\n  {\n    const readbackPromise = this.readGPUBufferRangeTyped(src, {\n      srcByteOffset,\n      type,\n      typedLength,\n      method\n    });\n    this.eventualAsyncExpectation(async (niceStack) => {\n      const readback = await readbackPromise;\n      this.expectOK(check(readback.data), { mode, niceStack });\n      readback.cleanup();\n    });\n  }\n\n  /**\n   * Expect a GPUBuffer's contents to equal the values in the provided TypedArray.\n   */\n  expectGPUBufferValuesEqual(\n  src,\n  expected,\n  srcByteOffset = 0,\n  { method = 'copy', mode = 'fail' } = {})\n  {\n    this.expectGPUBufferValuesPassCheck(src, (a) => checkElementsEqual(a, expected), {\n      srcByteOffset,\n      type: expected.constructor,\n      typedLength: expected.length,\n      method,\n      mode\n    });\n  }\n\n  /**\n   * Expect a buffer to consist exclusively of rows of some repeated expected value. The size of\n   * `expectedValue` must be 1, 2, or any multiple of 4 bytes. Rows in the buffer are expected to be\n   * zero-padded out to `bytesPerRow`. `minBytesPerRow` is the number of bytes per row that contain\n   * actual (non-padding) data and must be an exact multiple of the byte-length of `expectedValue`.\n   */\n  expectGPUBufferRepeatsSingleValue(\n  buffer,\n  {\n    expectedValue,\n    numRows,\n    minBytesPerRow,\n    bytesPerRow\n\n\n\n\n\n  })\n  {\n    const valueSize = expectedValue.byteLength;\n    assert(valueSize === 1 || valueSize === 2 || valueSize % 4 === 0);\n    assert(minBytesPerRow % valueSize === 0);\n    assert(bytesPerRow % 4 === 0);\n\n    // If the buffer is small enough, just generate the full expected buffer contents and check\n    // against them on the CPU.\n    const kMaxBufferSizeToCheckOnCpu = 256 * 1024;\n    const bufferSize = bytesPerRow * (numRows - 1) + minBytesPerRow;\n    if (bufferSize <= kMaxBufferSizeToCheckOnCpu) {\n      const valueBytes = Array.from(new Uint8Array(expectedValue));\n      const rowValues = new Array(minBytesPerRow / valueSize).fill(valueBytes);\n      const rowBytes = new Uint8Array([].concat(...rowValues));\n      const expectedContents = new Uint8Array(bufferSize);\n      range(numRows, (row) => expectedContents.set(rowBytes, row * bytesPerRow));\n      this.expectGPUBufferValuesEqual(buffer, expectedContents);\n      return;\n    }\n\n    // Copy into a buffer suitable for STORAGE usage.\n    const storageBuffer = this.createBufferTracked({\n      size: bufferSize,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST\n    });\n\n    // This buffer conveys the data we expect to see for a single value read. Since we read 32 bits at\n    // a time, for values smaller than 32 bits we pad this expectation with repeated value data, or\n    // with zeroes if the width of a row in the buffer is less than 4 bytes. For value sizes larger\n    // than 32 bits, we assume they're a multiple of 32 bits and expect to read exact matches of\n    // `expectedValue` as-is.\n    const expectedDataSize = Math.max(4, valueSize);\n    const expectedDataBuffer = this.createBufferTracked({\n      size: expectedDataSize,\n      usage: GPUBufferUsage.STORAGE,\n      mappedAtCreation: true\n    });\n    const expectedData = new Uint32Array(expectedDataBuffer.getMappedRange());\n    if (valueSize === 1) {\n      const value = new Uint8Array(expectedValue)[0];\n      const values = new Array(Math.min(4, minBytesPerRow)).fill(value);\n      const padding = new Array(Math.max(0, 4 - values.length)).fill(0);\n      const expectedBytes = new Uint8Array(expectedData.buffer);\n      expectedBytes.set([...values, ...padding]);\n    } else if (valueSize === 2) {\n      const value = new Uint16Array(expectedValue)[0];\n      const expectedWords = new Uint16Array(expectedData.buffer);\n      expectedWords.set([value, minBytesPerRow > 2 ? value : 0]);\n    } else {\n      expectedData.set(new Uint32Array(expectedValue));\n    }\n    expectedDataBuffer.unmap();\n\n    // The output buffer has one 32-bit entry per buffer row. An entry's value will be 1 if every\n    // read from the corresponding row matches the expected data derived above, or 0 otherwise.\n    const resultBuffer = this.createBufferTracked({\n      size: numRows * 4,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC\n    });\n\n    const readsPerRow = Math.ceil(minBytesPerRow / expectedDataSize);\n    const reducer = `\n    struct Buffer { data: array<u32>, };\n    @group(0) @binding(0) var<storage, read> expected: Buffer;\n    @group(0) @binding(1) var<storage, read> in: Buffer;\n    @group(0) @binding(2) var<storage, read_write> out: Buffer;\n    @compute @workgroup_size(1) fn reduce(\n        @builtin(global_invocation_id) id: vec3<u32>) {\n      let rowBaseIndex = id.x * ${bytesPerRow / 4}u;\n      let readSize = ${expectedDataSize / 4}u;\n      out.data[id.x] = 1u;\n      for (var i: u32 = 0u; i < ${readsPerRow}u; i = i + 1u) {\n        let elementBaseIndex = rowBaseIndex + i * readSize;\n        for (var j: u32 = 0u; j < readSize; j = j + 1u) {\n          if (in.data[elementBaseIndex + j] != expected.data[j]) {\n            out.data[id.x] = 0u;\n            return;\n          }\n        }\n      }\n    }\n    `;\n\n    const pipeline = this.device.createComputePipeline({\n      layout: 'auto',\n      compute: {\n        module: this.device.createShaderModule({ code: reducer }),\n        entryPoint: 'reduce'\n      }\n    });\n\n    const bindGroup = this.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [\n      { binding: 0, resource: { buffer: expectedDataBuffer } },\n      { binding: 1, resource: { buffer: storageBuffer } },\n      { binding: 2, resource: { buffer: resultBuffer } }]\n\n    });\n\n    const commandEncoder = globalThis._TRAMPOLINE_(\"createCommandEncoder\", this.device, this.device.createCommandEncoder, [], () => this.device.createCommandEncoder());\n    commandEncoder.copyBufferToBuffer(buffer, 0, storageBuffer, 0, bufferSize);\n    const pass = commandEncoder.beginComputePass();\n    pass.setPipeline(pipeline);\n    pass.setBindGroup(0, bindGroup);\n    pass.dispatchWorkgroups(numRows);\n    pass.end();\n    globalThis._TRAMPOLINE_(\"submit\", this.device, this.device.queue.submit, [[commandEncoder.finish()]], () => this.device.queue.submit([commandEncoder.finish()]));\n\n    const expectedResults = new Array(numRows).fill(1);\n    this.expectGPUBufferValuesEqual(resultBuffer, new Uint32Array(expectedResults));\n  }\n\n  // MAINTENANCE_TODO: add an expectContents for textures, which logs data: uris on failure\n\n  /**\n   * Expect an entire GPUTexture to have a single color at the given mip level (defaults to 0).\n   * MAINTENANCE_TODO: Remove this and/or replace it with a helper in TextureTestMixin.\n   */\n  expectSingleColor(\n  src,\n  format,\n  {\n    size,\n    exp,\n    dimension = '2d',\n    slice = 0,\n    layout\n\n\n\n\n\n\n  })\n  {\n    assert(\n      slice === 0 || dimension === '2d',\n      'texture slices are only implemented for 2d textures'\n    );\n\n    format = resolvePerAspectFormat(format, layout?.aspect);\n    const { byteLength, minBytesPerRow, bytesPerRow, rowsPerImage, mipSize } = getTextureCopyLayout(\n      format,\n      dimension,\n      size,\n      layout\n    );\n    // MAINTENANCE_TODO: getTextureCopyLayout does not return the proper size for array textures,\n    // i.e. it will leave the z/depth value as is instead of making it 1 when dealing with 2d\n    // texture arrays. Since we are passing in the dimension, we should update it to return the\n    // corrected size.\n    const copySize = [\n    mipSize[0],\n    dimension !== '1d' ? mipSize[1] : 1,\n    dimension === '3d' ? mipSize[2] : 1];\n\n\n    const rep = kTexelRepresentationInfo[format];\n    const expectedTexelData = rep.pack(rep.encode(exp));\n\n    const buffer = this.createBufferTracked({\n      size: byteLength,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST\n    });\n\n    const commandEncoder = globalThis._TRAMPOLINE_(\"createCommandEncoder\", this.device, this.device.createCommandEncoder, [], () => this.device.createCommandEncoder());\n    commandEncoder.copyTextureToBuffer(\n      {\n        texture: src,\n        mipLevel: layout?.mipLevel,\n        origin: { x: 0, y: 0, z: slice },\n        aspect: layout?.aspect\n      },\n      { buffer, bytesPerRow, rowsPerImage },\n      copySize\n    );\n    globalThis._TRAMPOLINE_(\"submit\", this, this.queue.submit, [[commandEncoder.finish()]], () => this.queue.submit([commandEncoder.finish()]));\n\n    this.expectGPUBufferRepeatsSingleValue(buffer, {\n      expectedValue: expectedTexelData,\n      numRows: rowsPerImage * copySize[2],\n      minBytesPerRow,\n      bytesPerRow\n    });\n  }\n\n  /**\n   * Return a GPUBuffer that data are going to be written into.\n   * MAINTENANCE_TODO: Remove this once expectSinglePixelBetweenTwoValuesIn2DTexture is removed.\n   */\n  readSinglePixelFrom2DTexture(\n  src,\n  format,\n  { x, y },\n  { slice = 0, layout })\n  {\n    const { byteLength, bytesPerRow, rowsPerImage } = getTextureSubCopyLayout(\n      format,\n      [1, 1],\n      layout\n    );\n    const buffer = this.createBufferTracked({\n      size: byteLength,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST\n    });\n\n    const commandEncoder = globalThis._TRAMPOLINE_(\"createCommandEncoder\", this.device, this.device.createCommandEncoder, [], () => this.device.createCommandEncoder());\n    commandEncoder.copyTextureToBuffer(\n      { texture: src, mipLevel: layout?.mipLevel, origin: { x, y, z: slice } },\n      { buffer, bytesPerRow, rowsPerImage },\n      [1, 1]\n    );\n    globalThis._TRAMPOLINE_(\"submit\", this, this.queue.submit, [[commandEncoder.finish()]], () => this.queue.submit([commandEncoder.finish()]));\n\n    return buffer;\n  }\n\n  /**\n   * Take a single pixel of a 2D texture, interpret it using a TypedArray of the `expected` type,\n   * and expect each value in that array to be between the corresponding \"expected\" values\n   * (either `a[i] <= actual[i] <= b[i]` or `a[i] >= actual[i] => b[i]`).\n   * MAINTENANCE_TODO: Remove this once there is a way to deal with undefined lerp-ed values.\n   */\n  expectSinglePixelBetweenTwoValuesIn2DTexture(\n  src,\n  format,\n  { x, y },\n  {\n    exp,\n    slice = 0,\n    layout,\n    generateWarningOnly = false,\n    checkElementsBetweenFn = (act, [a, b]) =>\n    checkElementsBetween(act, [(i) => a[i], (i) => b[i]])\n\n\n\n\n\n\n\n\n\n  })\n  {\n    assert(exp[0].constructor === exp[1].constructor);\n    const constructor = exp[0].constructor;\n    assert(exp[0].length === exp[1].length);\n    const typedLength = exp[0].length;\n\n    const buffer = this.readSinglePixelFrom2DTexture(src, format, { x, y }, { slice, layout });\n    this.expectGPUBufferValuesPassCheck(buffer, (a) => checkElementsBetweenFn(a, exp), {\n      type: constructor,\n      typedLength,\n      mode: generateWarningOnly ? 'warn' : 'fail'\n    });\n  }\n\n  /**\n   * Emulate a texture to buffer copy by using a compute shader\n   * to load texture values of a subregion of a 2d texture and write to a storage buffer.\n   * For sample count == 1, the buffer contains extent[0] * extent[1] of the sample.\n   * For sample count > 1, the buffer contains extent[0] * extent[1] * (N = sampleCount) values sorted\n   * in the order of their sample index [0, sampleCount - 1]\n   *\n   * This can be useful when the texture to buffer copy is not available to the texture format\n   * e.g. (depth24plus), or when the texture is multisampled.\n   *\n   * MAINTENANCE_TODO: extend texture dimension to 1d and 3d.\n   *\n   * @returns storage buffer containing the copied value from the texture.\n   */\n  copy2DTextureToBufferUsingComputePass(\n  type,\n  componentCount,\n  textureView,\n  sampleCount = 1,\n  extent_ = [1, 1, 1],\n  origin_ = [0, 0, 0])\n  {\n    const origin = reifyOrigin3D(origin_);\n    const extent = reifyExtent3D(extent_);\n    const width = extent.width;\n    const height = extent.height;\n    const kWorkgroupSizeX = 8;\n    const kWorkgroupSizeY = 8;\n    const textureSrcCode =\n    sampleCount === 1 ?\n    `@group(0) @binding(0) var src: texture_2d<${type}>;` :\n    `@group(0) @binding(0) var src: texture_multisampled_2d<${type}>;`;\n    const code = `\n      struct Buffer {\n        data: array<${type}>,\n      };\n\n      ${textureSrcCode}\n      @group(0) @binding(1) var<storage, read_write> dst : Buffer;\n\n      struct Params {\n        origin: vec2u,\n        extent: vec2u,\n      };\n      @group(0) @binding(2) var<uniform> params : Params;\n\n      @compute @workgroup_size(${kWorkgroupSizeX}, ${kWorkgroupSizeY}, 1) fn main(@builtin(global_invocation_id) id : vec3u) {\n        let boundary = params.origin + params.extent;\n        let coord = params.origin + id.xy;\n        if (any(coord >= boundary)) {\n          return;\n        }\n        let offset = (id.x + id.y * params.extent.x) * ${componentCount} * ${sampleCount};\n        for (var sampleIndex = 0u; sampleIndex < ${sampleCount};\n          sampleIndex = sampleIndex + 1) {\n          let o = offset + sampleIndex * ${componentCount};\n          let v = textureLoad(src, coord.xy, sampleIndex);\n          for (var component = 0u; component < ${componentCount}; component = component + 1) {\n            dst.data[o + component] = v[component];\n          }\n        }\n      }\n    `;\n    const computePipeline = this.device.createComputePipeline({\n      layout: 'auto',\n      compute: {\n        module: this.device.createShaderModule({\n          code\n        }),\n        entryPoint: 'main'\n      }\n    });\n\n    const storageBuffer = this.createBufferTracked({\n      size: sampleCount * type.size * componentCount * width * height,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC\n    });\n\n    const uniformBuffer = this.makeBufferWithContents(\n      new Uint32Array([origin.x, origin.y, width, height]),\n      GPUBufferUsage.UNIFORM\n    );\n\n    const uniformBindGroup = this.device.createBindGroup({\n      layout: computePipeline.getBindGroupLayout(0),\n      entries: [\n      {\n        binding: 0,\n        resource: textureView\n      },\n      {\n        binding: 1,\n        resource: {\n          buffer: storageBuffer\n        }\n      },\n      {\n        binding: 2,\n        resource: {\n          buffer: uniformBuffer\n        }\n      }]\n\n    });\n\n    const encoder = globalThis._TRAMPOLINE_(\"createCommandEncoder\", this.device, this.device.createCommandEncoder, [], () => this.device.createCommandEncoder());\n    const pass = encoder.beginComputePass();\n    pass.setPipeline(computePipeline);\n    pass.setBindGroup(0, uniformBindGroup);\n    pass.dispatchWorkgroups(\n      Math.floor((width + kWorkgroupSizeX - 1) / kWorkgroupSizeX),\n      Math.floor((height + kWorkgroupSizeY - 1) / kWorkgroupSizeY),\n      1\n    );\n    pass.end();\n    globalThis._TRAMPOLINE_(\"submit\", this.device, this.device.queue.submit, [[encoder.finish()]], () => this.device.queue.submit([encoder.finish()]));\n\n    return storageBuffer;\n  }\n\n  /**\n   * Expect the specified WebGPU error to be generated when running the provided function.\n   */\n  expectGPUError(filter, fn, shouldError = true) {\n    // If no error is expected, we let the scope surrounding the test catch it.\n    if (!shouldError) {\n      return fn();\n    }\n\n    this.device.pushErrorScope(filter);\n    const returnValue = fn();\n    const promise = this.device.popErrorScope();\n\n    this.eventualAsyncExpectation(async (niceStack) => {\n      const error = await promise;\n\n      let failed = false;\n      switch (filter) {\n        case 'out-of-memory':\n          failed = !(error instanceof GPUOutOfMemoryError);\n          break;\n        case 'validation':\n          failed = !(error instanceof GPUValidationError);\n          break;\n      }\n\n      if (failed) {\n        niceStack.message = `Expected ${filter} error`;\n        this.rec.expectationFailed(niceStack);\n      } else {\n        niceStack.message = `Captured ${filter} error`;\n        if (error instanceof GPUValidationError) {\n          niceStack.message += ` - ${error.message}`;\n        }\n        this.rec.debug(niceStack);\n      }\n    });\n\n    return returnValue;\n  }\n\n  /**\n   * Expect a validation error inside the callback.\n   *\n   * Tests should always do just one WebGPU call in the callback, to make sure that's what's tested.\n   */\n  expectValidationError(fn, shouldError = true) {\n    // If no error is expected, we let the scope surrounding the test catch it.\n    if (shouldError) {\n      this.device.pushErrorScope('validation');\n    }\n\n    // Note: A return value is not allowed for the callback function. This is to avoid confusion\n    // about what the actual behavior would be; either of the following could be reasonable:\n    //   - Make expectValidationError async, and have it await on fn(). This causes an async split\n    //     between pushErrorScope and popErrorScope, so if the caller doesn't `await` on\n    //     expectValidationError (either accidentally or because it doesn't care to do so), then\n    //     other test code will be (nondeterministically) caught by the error scope.\n    //   - Make expectValidationError NOT await fn(), but just execute its first block (until the\n    //     first await) and return the return value (a Promise). This would be confusing because it\n    //     would look like the error scope includes the whole async function, but doesn't.\n    // If we do decide we need to return a value, we should use the latter semantic.\n    const returnValue = fn();\n    assert(\n      returnValue === undefined,\n      'expectValidationError callback should not return a value (or be async)'\n    );\n\n    if (shouldError) {\n      const promise = this.device.popErrorScope();\n\n      this.eventualAsyncExpectation(async (niceStack) => {\n        const gpuValidationError = await promise;\n        if (!gpuValidationError) {\n          niceStack.message = 'Validation succeeded unexpectedly.';\n          this.rec.validationFailed(niceStack);\n        } else if (gpuValidationError instanceof GPUValidationError) {\n          niceStack.message = `Validation failed, as expected - ${gpuValidationError.message}`;\n          this.rec.debug(niceStack);\n        }\n      });\n    }\n  }\n\n  /** Create a GPUBuffer and track it for cleanup at the end of the test. */\n  createBufferTracked(descriptor) {\n    return this.trackForCleanup(globalThis._TRAMPOLINE_(\"createBuffer\", this.device, this.device.createBuffer, [descriptor], () => this.device.createBuffer(descriptor)));\n  }\n\n  /** Create a GPUTexture and track it for cleanup at the end of the test. */\n  createTextureTracked(descriptor) {\n    return this.trackForCleanup(this.device.createTexture(descriptor));\n  }\n\n  /** Create a GPUQuerySet and track it for cleanup at the end of the test. */\n  createQuerySetTracked(descriptor) {\n    return this.trackForCleanup(this.device.createQuerySet(descriptor));\n  }\n\n  /**\n   * Creates a buffer with the contents of some TypedArray.\n   * The buffer size will always be aligned to 4 as we set mappedAtCreation === true when creating the\n   * buffer.\n   *\n   * MAINTENANCE_TODO: Several call sites would be simplified if this took ArrayBuffer as well.\n   */\n  makeBufferWithContents(dataArray, usage) {\n    const buffer = this.createBufferTracked({\n      mappedAtCreation: true,\n      size: align(dataArray.byteLength, 4),\n      usage\n    });\n    memcpy({ src: dataArray }, { dst: buffer.getMappedRange() });\n    buffer.unmap();\n    return buffer;\n  }\n\n  /**\n   * Returns a GPUCommandEncoder, GPUComputePassEncoder, GPURenderPassEncoder, or\n   * GPURenderBundleEncoder, and a `finish` method returning a GPUCommandBuffer.\n   * Allows testing methods which have the same signature across multiple encoder interfaces.\n   *\n   * @example\n   * ```\n   * g.test('popDebugGroup')\n   *   .params(u => u.combine('encoderType', kEncoderTypes))\n   *   .fn(t => {\n   *     const { encoder, finish } = t.createEncoder(t.params.encoderType);\n   *     encoder.popDebugGroup();\n   *   });\n   *\n   * g.test('writeTimestamp')\n   *   .params(u => u.combine('encoderType', ['non-pass', 'compute pass', 'render pass'] as const)\n   *   .fn(t => {\n   *     const { encoder, finish } = t.createEncoder(t.params.encoderType);\n   *     // Encoder type is inferred, so `writeTimestamp` can be used even though it doesn't exist\n   *     // on GPURenderBundleEncoder.\n   *     encoder.writeTimestamp(args);\n   *   });\n   * ```\n   */\n  createEncoder(\n  encoderType,\n  {\n    attachmentInfo,\n    occlusionQuerySet\n\n\n\n  } = {})\n  {\n    const fullAttachmentInfo = {\n      // Defaults if not overridden:\n      colorFormats: ['rgba8unorm'],\n      sampleCount: 1,\n      // Passed values take precedent.\n      ...attachmentInfo\n    };\n\n    switch (encoderType) {\n      case 'non-pass':{\n          const encoder = globalThis._TRAMPOLINE_(\"createCommandEncoder\", this.device, this.device.createCommandEncoder, [], () => this.device.createCommandEncoder());\n\n          return new CommandBufferMaker(this, encoder, () => {\n            return encoder.finish();\n          });\n        }\n      case 'render bundle':{\n          const device = this.device;\n          const rbEncoder = device.createRenderBundleEncoder(fullAttachmentInfo);\n          const pass = this.createEncoder('render pass', { attachmentInfo });\n\n          return new CommandBufferMaker(this, rbEncoder, () => {\n            pass.encoder.executeBundles([rbEncoder.finish()]);\n            return pass.finish();\n          });\n        }\n      case 'compute pass':{\n          const commandEncoder = globalThis._TRAMPOLINE_(\"createCommandEncoder\", this.device, this.device.createCommandEncoder, [], () => this.device.createCommandEncoder());\n          const encoder = commandEncoder.beginComputePass();\n\n          return new CommandBufferMaker(this, encoder, () => {\n            encoder.end();\n            return commandEncoder.finish();\n          });\n        }\n      case 'render pass':{\n          const makeAttachmentView = (format) =>\n          this.createTextureTracked({\n            size: [16, 16, 1],\n            format,\n            usage: GPUTextureUsage.RENDER_ATTACHMENT,\n            sampleCount: fullAttachmentInfo.sampleCount\n          }).createView();\n\n          let depthStencilAttachment = undefined;\n          if (fullAttachmentInfo.depthStencilFormat !== undefined) {\n            depthStencilAttachment = {\n              view: makeAttachmentView(fullAttachmentInfo.depthStencilFormat),\n              depthReadOnly: fullAttachmentInfo.depthReadOnly,\n              stencilReadOnly: fullAttachmentInfo.stencilReadOnly\n            };\n            if (\n            kTextureFormatInfo[fullAttachmentInfo.depthStencilFormat].depth &&\n            !fullAttachmentInfo.depthReadOnly)\n            {\n              depthStencilAttachment.depthClearValue = 0;\n              depthStencilAttachment.depthLoadOp = 'clear';\n              depthStencilAttachment.depthStoreOp = 'discard';\n            }\n            if (\n            kTextureFormatInfo[fullAttachmentInfo.depthStencilFormat].stencil &&\n            !fullAttachmentInfo.stencilReadOnly)\n            {\n              depthStencilAttachment.stencilClearValue = 1;\n              depthStencilAttachment.stencilLoadOp = 'clear';\n              depthStencilAttachment.stencilStoreOp = 'discard';\n            }\n          }\n          const passDesc = {\n            colorAttachments: Array.from(fullAttachmentInfo.colorFormats, (format) =>\n            format ?\n            {\n              view: makeAttachmentView(format),\n              clearValue: [0, 0, 0, 0],\n              loadOp: 'clear',\n              storeOp: 'store'\n            } :\n            null\n            ),\n            depthStencilAttachment,\n            occlusionQuerySet\n          };\n\n          const commandEncoder = globalThis._TRAMPOLINE_(\"createCommandEncoder\", this.device, this.device.createCommandEncoder, [], () => this.device.createCommandEncoder());\n          const encoder = commandEncoder.beginRenderPass(passDesc);\n          return new CommandBufferMaker(this, encoder, () => {\n            encoder.end();\n            return commandEncoder.finish();\n          });\n        }\n    }\n    unreachable();\n  }\n}\n\n/**\n * Fixture for WebGPU tests that uses a DeviceProvider\n */\nexport class GPUTest extends GPUTestBase {\n  // Should never be undefined in a test. If it is, init() must not have run/finished.\n\n\n\n  async init() {\n    await super.init();\n\n    this.provider = await this.sharedState.acquireProvider();\n    this.mismatchedProvider = await this.sharedState.acquireMismatchedProvider();\n  }\n\n  /** GPUAdapter that the device was created from. */\n  get adapter() {\n    assert(this.provider !== undefined, 'internal error: DeviceProvider missing');\n    return this.provider.adapter;\n  }\n\n  /**\n   * GPUDevice for the test to use.\n   */\n  get device() {\n    assert(this.provider !== undefined, 'internal error: DeviceProvider missing');\n    return this.provider.device;\n  }\n\n  /**\n   * GPUDevice for tests requiring a second device different from the default one,\n   * e.g. for creating objects for by device_mismatch validation tests.\n   */\n  get mismatchedDevice() {\n    assert(\n      this.mismatchedProvider !== undefined,\n      'selectMismatchedDeviceOrSkipTestCase was not called in beforeAllSubcases'\n    );\n    return this.mismatchedProvider.device;\n  }\n\n  /**\n   * Expects that the device should be lost for a particular reason at the teardown of the test.\n   */\n  expectDeviceLost(reason) {\n    assert(this.provider !== undefined, 'internal error: GPUDevice missing?');\n    this.provider.expectDeviceLost(reason);\n  }\n}\n\n/**\n * Gets the adapter limits as a standard JavaScript object.\n */\nfunction getAdapterLimitsAsDeviceRequiredLimits(adapter) {\n  const requiredLimits = {};\n  const adapterLimits = adapter.limits;\n  for (const key in adapter.limits) {\n    // MAINTENANCE_TODO: Remove this once minSubgroupSize is removed from\n    // chromium.\n    if (key === 'maxSubgroupSize' || key === 'minSubgroupSize') {\n      continue;\n    }\n    requiredLimits[key] = adapterLimits[key];\n  }\n  return requiredLimits;\n}\n\nfunction setAllLimitsToAdapterLimits(\nadapter,\ndesc)\n{\n  const descWithMaxLimits = {\n    requiredFeatures: [],\n    defaultQueue: {},\n    ...desc,\n    requiredLimits: getAdapterLimitsAsDeviceRequiredLimits(adapter)\n  };\n  return descWithMaxLimits;\n}\n\n/**\n * Used by MaxLimitsTest to request a device with all the max limits of the adapter.\n */\nexport class MaxLimitsGPUTestSubcaseBatchState extends GPUTestSubcaseBatchState {\n  selectDeviceOrSkipTestCase(\n  descriptor,\n  descriptorModifierFn)\n  {\n    const wrapper = (adapter, desc) => {\n      desc = descriptorModifierFn ? descriptorModifierFn(adapter, desc) : desc;\n      return setAllLimitsToAdapterLimits(adapter, desc);\n    };\n    super.selectDeviceOrSkipTestCase(initUncanonicalizedDeviceDescriptor(descriptor), wrapper);\n  }\n}\n\n/**\n * A Test that requests all the max limits from the adapter on the device.\n */\nexport class MaxLimitsTest extends GPUTest {\n  static MakeSharedState(\n  recorder,\n  params)\n  {\n    return new MaxLimitsGPUTestSubcaseBatchState(recorder, params);\n  }\n}\n\n/**\n * Texture expectation mixin can be applied on top of GPUTest to add texture\n * related expectation helpers.\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst s_deviceToResourcesMap = new WeakMap();\n\n/**\n * Gets a (cached) pipeline to render a texture to an rgba8unorm texture\n */\nfunction getPipelineToRenderTextureToRGB8UnormTexture(\ndevice,\ntexture,\nisCompatibility)\n{\n  if (!s_deviceToResourcesMap.has(device)) {\n    s_deviceToResourcesMap.set(device, {\n      pipelineByPipelineType: new Map()\n    });\n  }\n\n  const { pipelineByPipelineType } = s_deviceToResourcesMap.get(device);\n  const pipelineType =\n  isCompatibility && texture.depthOrArrayLayers > 1 ? '2d-array' : '2d';\n  if (!pipelineByPipelineType.get(pipelineType)) {\n    const [textureType, layerCode] =\n    pipelineType === '2d' ? ['texture_2d', ''] : ['texture_2d_array', ', uni.baseArrayLayer'];\n    const module = device.createShaderModule({\n      code: `\n        struct VSOutput {\n          @builtin(position) position: vec4f,\n          @location(0) texcoord: vec2f,\n        };\n\n        struct Uniforms {\n          baseArrayLayer: u32,\n        };\n\n        @vertex fn vs(\n          @builtin(vertex_index) vertexIndex : u32\n        ) -> VSOutput {\n            let pos = array(\n               vec2f(-1, -1),\n               vec2f(-1,  3),\n               vec2f( 3, -1),\n            );\n\n            var vsOutput: VSOutput;\n\n            let xy = pos[vertexIndex];\n\n            vsOutput.position = vec4f(xy, 0.0, 1.0);\n            vsOutput.texcoord = xy * vec2f(0.5, -0.5) + vec2f(0.5);\n\n            return vsOutput;\n         }\n\n         @group(0) @binding(0) var ourSampler: sampler;\n         @group(0) @binding(1) var ourTexture: ${textureType}<f32>;\n         @group(0) @binding(2) var<uniform> uni: Uniforms;\n\n         @fragment fn fs(fsInput: VSOutput) -> @location(0) vec4f {\n            return textureSample(ourTexture, ourSampler, fsInput.texcoord${layerCode});\n         }\n      `\n    });\n    const pipeline = device.createRenderPipeline({\n      layout: 'auto',\n      vertex: {\n        module,\n        entryPoint: 'vs'\n      },\n      fragment: {\n        module,\n        entryPoint: 'fs',\n        targets: [{ format: 'rgba8unorm' }]\n      }\n    });\n    pipelineByPipelineType.set(pipelineType, pipeline);\n  }\n  const pipeline = pipelineByPipelineType.get(pipelineType);\n  return { pipelineType, pipeline };\n}\n\n\n\n\n\n\n\nexport function TextureTestMixin(\nBase)\n{\n  class TextureExpectations extends\n  Base\n\n  {\n    /**\n     * Creates a 1 mip level texture with the contents of a TexelView.\n     */\n    createTextureFromTexelView(\n    texelView,\n    desc)\n    {\n      return createTextureFromTexelViews(this, [texelView], desc);\n    }\n\n    createTextureFromTexelViewsMultipleMipmaps(\n    texelViews,\n    desc)\n    {\n      return createTextureFromTexelViews(this, texelViews, desc);\n    }\n\n    expectTexelViewComparisonIsOkInTexture(\n    src,\n    exp,\n    size,\n    comparisonOptions = {\n      maxIntDiff: 0,\n      maxDiffULPsForNormFormat: 1,\n      maxDiffULPsForFloatFormat: 1\n    })\n    {\n      this.eventualExpectOK(\n        textureContentIsOKByT2B(this, src, size, { expTexelView: exp }, comparisonOptions)\n      );\n    }\n\n    expectSinglePixelComparisonsAreOkInTexture(\n    src,\n    exp,\n    comparisonOptions = {\n      maxIntDiff: 0,\n      maxDiffULPsForNormFormat: 1,\n      maxDiffULPsForFloatFormat: 1\n    })\n    {\n      assert(exp.length > 0, 'must specify at least one pixel comparison');\n      assert(\n        kEncodableTextureFormats.includes(src.texture.format),\n        () => `${src.texture.format} is not an encodable format`\n      );\n      const lowerCorner = [src.texture.width, src.texture.height, src.texture.depthOrArrayLayers];\n      const upperCorner = [0, 0, 0];\n      const expMap = new Map();\n      const coords = [];\n      for (const e of exp) {\n        const coord = reifyOrigin3D(e.coord);\n        const coordKey = JSON.stringify(coord);\n        coords.push(coord);\n\n        // Compute the minimum sub-rect that encompasses all the pixel comparisons. The\n        // `lowerCorner` will become the origin, and the `upperCorner` will be used to compute the\n        // size.\n        lowerCorner[0] = Math.min(lowerCorner[0], coord.x);\n        lowerCorner[1] = Math.min(lowerCorner[1], coord.y);\n        lowerCorner[2] = Math.min(lowerCorner[2], coord.z);\n        upperCorner[0] = Math.max(upperCorner[0], coord.x);\n        upperCorner[1] = Math.max(upperCorner[1], coord.y);\n        upperCorner[2] = Math.max(upperCorner[2], coord.z);\n\n        // Build a sparse map of the coordinates to the expected colors for the texel view.\n        assert(\n          !expMap.has(coordKey),\n          () => `duplicate pixel expectation at coordinate (${coord.x},${coord.y},${coord.z})`\n        );\n        expMap.set(coordKey, e.exp);\n      }\n      const size = [\n      upperCorner[0] - lowerCorner[0] + 1,\n      upperCorner[1] - lowerCorner[1] + 1,\n      upperCorner[2] - lowerCorner[2] + 1];\n\n      let expTexelView;\n      if (Symbol.iterator in exp[0].exp) {\n        expTexelView = TexelView.fromTexelsAsBytes(\n          src.texture.format,\n          (coord) => {\n            const res = expMap.get(JSON.stringify(coord));\n            assert(\n              res !== undefined,\n              () => `invalid coordinate (${coord.x},${coord.y},${coord.z}) in sparse texel view`\n            );\n            return res;\n          }\n        );\n      } else {\n        expTexelView = TexelView.fromTexelsAsColors(\n          src.texture.format,\n          (coord) => {\n            const res = expMap.get(JSON.stringify(coord));\n            assert(\n              res !== undefined,\n              () => `invalid coordinate (${coord.x},${coord.y},${coord.z}) in sparse texel view`\n            );\n            return res;\n          }\n        );\n      }\n      const coordsF = function* () {\n        for (const coord of coords) {\n          yield coord;\n        }\n      }();\n\n      this.eventualExpectOK(\n        textureContentIsOKByT2B(\n          this,\n          { ...src, origin: reifyOrigin3D(lowerCorner) },\n          size,\n          { expTexelView },\n          comparisonOptions,\n          coordsF\n        )\n      );\n    }\n\n    expectTexturesToMatchByRendering(\n    actualTexture,\n    expectedTexture,\n    mipLevel,\n    origin,\n    size)\n    {\n      // Render every layer of both textures at mipLevel to an rgba8unorm texture\n      // that matches the size of the mipLevel. After each render, copy the\n      // result to a buffer and expect the results from both textures to match.\n      const { pipelineType, pipeline } = getPipelineToRenderTextureToRGB8UnormTexture(\n        this.device,\n        actualTexture,\n        this.isCompatibility\n      );\n      const readbackPromisesPerTexturePerLayer = [actualTexture, expectedTexture].map(\n        (texture, ndx) => {\n          const attachmentSize = virtualMipSize('2d', [texture.width, texture.height, 1], mipLevel);\n          const attachment = this.createTextureTracked({\n            label: `readback${ndx}`,\n            size: attachmentSize,\n            format: 'rgba8unorm',\n            usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT\n          });\n\n          const sampler = this.device.createSampler();\n\n          const numLayers = texture.depthOrArrayLayers;\n          const readbackPromisesPerLayer = [];\n\n          const uniformBuffer = this.createBufferTracked({\n            size: 4,\n            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST\n          });\n\n          for (let layer = 0; layer < numLayers; ++layer) {\n            const viewDescriptor = {\n              baseMipLevel: mipLevel,\n              mipLevelCount: 1,\n              ...(!this.isCompatibility && {\n                baseArrayLayer: layer,\n                arrayLayerCount: 1\n              }),\n              dimension: pipelineType\n            };\n\n            const bindGroup = this.device.createBindGroup({\n              layout: pipeline.getBindGroupLayout(0),\n              entries: [\n              { binding: 0, resource: sampler },\n              {\n                binding: 1,\n                resource: texture.createView(viewDescriptor)\n              },\n              ...(pipelineType === '2d-array' ?\n              [\n              {\n                binding: 2,\n                resource: { buffer: uniformBuffer }\n              }] :\n\n              [])]\n\n            });\n\n            this.device.queue.writeBuffer(uniformBuffer, 0, new Uint32Array([layer]));\n\n            const encoder = globalThis._TRAMPOLINE_(\"createCommandEncoder\", this.device, this.device.createCommandEncoder, [], () => this.device.createCommandEncoder());\n            const pass = encoder.beginRenderPass({\n              colorAttachments: [\n              {\n                view: attachment.createView(),\n                clearValue: [0.5, 0.5, 0.5, 0.5],\n                loadOp: 'clear',\n                storeOp: 'store'\n              }]\n\n            });\n            pass.setPipeline(pipeline);\n            pass.setBindGroup(0, bindGroup);\n            pass.draw(3);\n            pass.end();\n            globalThis._TRAMPOLINE_(\"submit\", this, this.queue.submit, [[encoder.finish()]], () => this.queue.submit([encoder.finish()]));\n\n            const buffer = this.copyWholeTextureToNewBufferSimple(attachment, 0);\n\n            readbackPromisesPerLayer.push(\n              this.readGPUBufferRangeTyped(buffer, {\n                type: Uint8Array,\n                typedLength: buffer.size\n              })\n            );\n          }\n          return readbackPromisesPerLayer;\n        }\n      );\n\n      this.eventualAsyncExpectation(async (niceStack) => {\n        const readbacksPerTexturePerLayer = [];\n\n        // Wait for all buffers to be ready\n        for (const readbackPromises of readbackPromisesPerTexturePerLayer) {\n          readbacksPerTexturePerLayer.push(await Promise.all(readbackPromises));\n        }\n\n        function arrayNotAllTheSameValue(arr, msg) {\n          const first = arr[0];\n          return arr.length <= 1 || arr.findIndex((v) => v !== first) >= 0 ?\n          undefined :\n          Error(`array is entirely ${first} so likely nothing was tested: ${msg || ''}`);\n        }\n\n        // Compare each layer of each texture as read from buffer.\n        const [actualReadbacksPerLayer, expectedReadbacksPerLayer] = readbacksPerTexturePerLayer;\n        for (let layer = 0; layer < actualReadbacksPerLayer.length; ++layer) {\n          const actualReadback = actualReadbacksPerLayer[layer];\n          const expectedReadback = expectedReadbacksPerLayer[layer];\n          const sameOk =\n          size.width === 0 ||\n          size.height === 0 ||\n          layer < origin.z ||\n          layer >= origin.z + size.depthOrArrayLayers;\n          this.expectOK(\n            sameOk ? undefined : arrayNotAllTheSameValue(actualReadback.data, 'actualTexture')\n          );\n          this.expectOK(\n            sameOk ? undefined : arrayNotAllTheSameValue(expectedReadback.data, 'expectedTexture')\n          );\n          this.expectOK(checkElementsEqual(actualReadback.data, expectedReadback.data), {\n            mode: 'fail',\n            niceStack\n          });\n          actualReadback.cleanup();\n          expectedReadback.cleanup();\n        }\n      });\n    }\n\n    copyWholeTextureToNewBufferSimple(texture, mipLevel) {\n      const { blockWidth, blockHeight, bytesPerBlock } = kTextureFormatInfo[texture.format];\n      const mipSize = physicalMipSizeFromTexture(texture, mipLevel);\n      assert(bytesPerBlock !== undefined);\n\n      const blocksPerRow = mipSize[0] / blockWidth;\n      const blocksPerColumn = mipSize[1] / blockHeight;\n\n      assert(blocksPerRow % 1 === 0);\n      assert(blocksPerColumn % 1 === 0);\n\n      const bytesPerRow = align(blocksPerRow * bytesPerBlock, 256);\n      const byteLength = bytesPerRow * blocksPerColumn * mipSize[2];\n\n      return this.copyWholeTextureToNewBuffer(\n        { texture, mipLevel },\n        {\n          bytesPerBlock,\n          bytesPerRow,\n          rowsPerImage: blocksPerColumn,\n          byteLength\n        }\n      );\n    }\n\n    copyWholeTextureToNewBuffer(\n    { texture, mipLevel },\n    resultDataLayout)\n\n\n\n\n\n    {\n      const { byteLength, bytesPerRow, rowsPerImage } = resultDataLayout;\n      const buffer = this.createBufferTracked({\n        size: align(byteLength, 4), // this is necessary because we need to copy and map data from this buffer\n        usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST\n      });\n\n      const mipSize = physicalMipSizeFromTexture(texture, mipLevel || 0);\n      const encoder = globalThis._TRAMPOLINE_(\"createCommandEncoder\", this.device, this.device.createCommandEncoder, [], () => this.device.createCommandEncoder());\n      encoder.copyTextureToBuffer(\n        { texture, mipLevel },\n        { buffer, bytesPerRow, rowsPerImage },\n        mipSize\n      );\n      globalThis._TRAMPOLINE_(\"submit\", this.device, this.device.queue.submit, [[encoder.finish()]], () => this.device.queue.submit([encoder.finish()]));\n\n      return buffer;\n    }\n\n    updateLinearTextureDataSubBox(\n    format,\n    copySize,\n    copyParams)\n\n\n\n    {\n      const { src, dest } = copyParams;\n      const rowLength = bytesInACompleteRow(copySize.width, format);\n      for (const texel of this.iterateBlockRows(copySize, format)) {\n        const srcOffsetElements = this.getTexelOffsetInBytes(\n          src.dataLayout,\n          format,\n          texel,\n          src.origin\n        );\n        const dstOffsetElements = this.getTexelOffsetInBytes(\n          dest.dataLayout,\n          format,\n          texel,\n          dest.origin\n        );\n        memcpy(\n          { src: src.data, start: srcOffsetElements, length: rowLength },\n          { dst: dest.data, start: dstOffsetElements }\n        );\n      }\n    }\n\n    /** Offset for a particular texel in the linear texture data */\n    getTexelOffsetInBytes(\n    textureDataLayout,\n    format,\n    texel,\n    origin = { x: 0, y: 0, z: 0 })\n    {\n      const { offset, bytesPerRow, rowsPerImage } = textureDataLayout;\n      const info = kTextureFormatInfo[format];\n\n      assert(texel.x % info.blockWidth === 0);\n      assert(texel.y % info.blockHeight === 0);\n      assert(origin.x % info.blockWidth === 0);\n      assert(origin.y % info.blockHeight === 0);\n\n      const bytesPerImage = rowsPerImage * bytesPerRow;\n\n      return (\n        offset +\n        (texel.z + origin.z) * bytesPerImage +\n        (texel.y + origin.y) / info.blockHeight * bytesPerRow +\n        (texel.x + origin.x) / info.blockWidth * info.color.bytes);\n\n    }\n\n    *iterateBlockRows(\n    size,\n    format)\n    {\n      if (size.width === 0 || size.height === 0 || size.depthOrArrayLayers === 0) {\n        // do not iterate anything for an empty region\n        return;\n      }\n      const info = kTextureFormatInfo[format];\n      assert(size.height % info.blockHeight === 0);\n      // Note: it's important that the order is in increasing memory address order.\n      for (let z = 0; z < size.depthOrArrayLayers; ++z) {\n        for (let y = 0; y < size.height; y += info.blockHeight) {\n          yield {\n            x: 0,\n            y,\n            z\n          };\n        }\n      }\n    }\n  }\n\n  return TextureExpectations;\n}"],"mappings":"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","ignoreList":[]}