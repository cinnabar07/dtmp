{"version":3,"file":"vertex_state.spec.js","names":["description","makeTestGroup","range","CompatibilityTest","g","test","desc","params","u","combine","fn","t","useVertexIndex","useInstanceIndex","numAttribsToReserve","isAsync","numAttribs","device","limits","maxVertexAttributes","numBuiltinsUsed","isValidInCompat","isValidInCore","isValid","isCompatibility","inputs","i","outputs","push","module","createShaderModule","code","join","pipelineDescriptor","layout","vertex","entryPoint","buffers","arrayStride","attributes","shaderLocation","format","offset","fragment","targets","doCreateRenderPipelineTest"],"sources":["../../../../../../src/webgpu/compat/api/validation/render_pipeline/vertex_state.spec.ts"],"sourcesContent":["/**\n* AUTO-GENERATED - DO NOT EDIT. Source: https://github.com/gpuweb/cts\n**/export const description = `\nTests limitations of createRenderPipeline related to vertex state in compat mode.\n`;import { makeTestGroup } from '../../../../../common/framework/test_group.js';\nimport { range } from '../../../../../common/util/util.js';\nimport { CompatibilityTest } from '../../../compatibility_test.js';\n\nexport const g = makeTestGroup(CompatibilityTest);\n\ng.test('maxVertexAttributesVertexIndexInstanceIndex').\ndesc(\n  `\nTests @builtin(vertex_index) and @builtin(instance_index) each count as an attribute.\n\n- Test that you can use maxVertexAttributes\n- Test that you can not use maxVertexAttributes and @builtin(vertex_index)\n- Test that you can not use maxVertexAttributes and @builtin(instance_index)\n- Test that you can use maxVertexAttributes - 1 and @builtin(vertex_index)\n- Test that you can use maxVertexAttributes - 1 and @builtin(instance_index)\n- Test that you can not use maxVertexAttributes - 1 and both @builtin(vertex_index) and @builtin(instance_index)\n- Test that you can use maxVertexAttributes - 2 and both @builtin(vertex_index) and @builtin(instance_index)\n    `\n).\nparams((u) =>\nu.\ncombine('useVertexIndex', [false, true]).\ncombine('useInstanceIndex', [false, true]).\ncombine('numAttribsToReserve', [0, 1, 2]).\ncombine('isAsync', [false, true])\n).\nfn((t) => {\n  const { useVertexIndex, useInstanceIndex, numAttribsToReserve, isAsync } = t.params;\n  const numAttribs = t.device.limits.maxVertexAttributes - numAttribsToReserve;\n\n  const numBuiltinsUsed = (useVertexIndex ? 1 : 0) + (useInstanceIndex ? 1 : 0);\n  const isValidInCompat = numAttribs + numBuiltinsUsed <= t.device.limits.maxVertexAttributes;\n  const isValidInCore = numAttribs <= t.device.limits.maxVertexAttributes;\n  const isValid = t.isCompatibility ? isValidInCompat : isValidInCore;\n\n  const inputs = range(numAttribs, (i) => `@location(${i}) v${i}: vec4f`);\n  const outputs = range(numAttribs, (i) => `v${i}`);\n\n  if (useVertexIndex) {\n    inputs.push('@builtin(vertex_index) vNdx: u32');\n    outputs.push('vec4f(f32(vNdx))');\n  }\n\n  if (useInstanceIndex) {\n    inputs.push('@builtin(instance_index) iNdx: u32');\n    outputs.push('vec4f(f32(iNdx))');\n  }\n\n  const module = t.device.createShaderModule({\n    code: `\n        @fragment fn fs() -> @location(0) vec4f {\n            return vec4f(1);\n        }\n        @vertex fn vs(${inputs.join(', ')}) -> @builtin(position) vec4f {\n            return ${outputs.join(' + ')};\n        }\n      `\n  });\n\n  const pipelineDescriptor = {\n    layout: 'auto',\n    vertex: {\n      module,\n      entryPoint: 'vs',\n      buffers: [\n      {\n        arrayStride: 16,\n        attributes: range(numAttribs, (i) => ({\n          shaderLocation: i,\n          format: 'float32x4',\n          offset: 0\n        }))\n      }]\n\n    },\n    fragment: {\n      module,\n      entryPoint: 'fs',\n      targets: [\n      {\n        format: 'rgba8unorm'\n      }]\n\n    }\n  };\n\n  t.doCreateRenderPipelineTest(isAsync, isValid, pipelineDescriptor);\n});"],"mappings":"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","ignoreList":[]}